(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw ((f.code = "MODULE_NOT_FOUND"), f);
      }
      var l = (n[o] = { exports: {} });
      t[o][0].call(
        l.exports,
        function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        },
        l,
        l.exports,
        e,
        t,
        n,
        r
      );
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s;
})(
  {
    1: [
      function(require, module, exports) {
        (function(global) {
          (function() {
            var undefined;
            var VERSION = "4.17.4";
            var LARGE_ARRAY_SIZE = 200;
            var CORE_ERROR_TEXT =
                "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
              FUNC_ERROR_TEXT = "Expected a function";
            var HASH_UNDEFINED = "__lodash_hash_undefined__";
            var MAX_MEMOIZE_SIZE = 500;
            var PLACEHOLDER = "__lodash_placeholder__";
            var CLONE_DEEP_FLAG = 1,
              CLONE_FLAT_FLAG = 2,
              CLONE_SYMBOLS_FLAG = 4;
            var COMPARE_PARTIAL_FLAG = 1,
              COMPARE_UNORDERED_FLAG = 2;
            var WRAP_BIND_FLAG = 1,
              WRAP_BIND_KEY_FLAG = 2,
              WRAP_CURRY_BOUND_FLAG = 4,
              WRAP_CURRY_FLAG = 8,
              WRAP_CURRY_RIGHT_FLAG = 16,
              WRAP_PARTIAL_FLAG = 32,
              WRAP_PARTIAL_RIGHT_FLAG = 64,
              WRAP_ARY_FLAG = 128,
              WRAP_REARG_FLAG = 256,
              WRAP_FLIP_FLAG = 512;
            var DEFAULT_TRUNC_LENGTH = 30,
              DEFAULT_TRUNC_OMISSION = "...";
            var HOT_COUNT = 800,
              HOT_SPAN = 16;
            var LAZY_FILTER_FLAG = 1,
              LAZY_MAP_FLAG = 2,
              LAZY_WHILE_FLAG = 3;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991,
              MAX_INTEGER = 1.7976931348623157e308,
              NAN = 0 / 0;
            var MAX_ARRAY_LENGTH = 4294967295,
              MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
              HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            var wrapFlags = [
              ["ary", WRAP_ARY_FLAG],
              ["bind", WRAP_BIND_FLAG],
              ["bindKey", WRAP_BIND_KEY_FLAG],
              ["curry", WRAP_CURRY_FLAG],
              ["curryRight", WRAP_CURRY_RIGHT_FLAG],
              ["flip", WRAP_FLIP_FLAG],
              ["partial", WRAP_PARTIAL_FLAG],
              ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
              ["rearg", WRAP_REARG_FLAG]
            ];
            var argsTag = "[object Arguments]",
              arrayTag = "[object Array]",
              asyncTag = "[object AsyncFunction]",
              boolTag = "[object Boolean]",
              dateTag = "[object Date]",
              domExcTag = "[object DOMException]",
              errorTag = "[object Error]",
              funcTag = "[object Function]",
              genTag = "[object GeneratorFunction]",
              mapTag = "[object Map]",
              numberTag = "[object Number]",
              nullTag = "[object Null]",
              objectTag = "[object Object]",
              promiseTag = "[object Promise]",
              proxyTag = "[object Proxy]",
              regexpTag = "[object RegExp]",
              setTag = "[object Set]",
              stringTag = "[object String]",
              symbolTag = "[object Symbol]",
              undefinedTag = "[object Undefined]",
              weakMapTag = "[object WeakMap]",
              weakSetTag = "[object WeakSet]";
            var arrayBufferTag = "[object ArrayBuffer]",
              dataViewTag = "[object DataView]",
              float32Tag = "[object Float32Array]",
              float64Tag = "[object Float64Array]",
              int8Tag = "[object Int8Array]",
              int16Tag = "[object Int16Array]",
              int32Tag = "[object Int32Array]",
              uint8Tag = "[object Uint8Array]",
              uint8ClampedTag = "[object Uint8ClampedArray]",
              uint16Tag = "[object Uint16Array]",
              uint32Tag = "[object Uint32Array]";
            var reEmptyStringLeading = /\b__p \+= '';/g,
              reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
              reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
              reUnescapedHtml = /[&<>"']/g,
              reHasEscapedHtml = RegExp(reEscapedHtml.source),
              reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            var reEscape = /<%-([\s\S]+?)%>/g,
              reEvaluate = /<%([\s\S]+?)%>/g,
              reInterpolate = /<%=([\s\S]+?)%>/g;
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
              reHasRegExpChar = RegExp(reRegExpChar.source);
            var reTrim = /^\s+|\s+$/g,
              reTrimStart = /^\s+/,
              reTrimEnd = /\s+$/;
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
              reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
              reSplitDetails = /,? & /;
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            var reEscapeChar = /\\(\\)?/g;
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            var reFlags = /\w*$/;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsOctal = /^0o[0-7]+$/i;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            var reNoMatch = /($^)/;
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            var rsAstralRange = "\\ud800-\\udfff",
              rsComboMarksRange = "\\u0300-\\u036f",
              reComboHalfMarksRange = "\\ufe20-\\ufe2f",
              rsComboSymbolsRange = "\\u20d0-\\u20ff",
              rsComboRange =
                rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
              rsDingbatRange = "\\u2700-\\u27bf",
              rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
              rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
              rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
              rsPunctuationRange = "\\u2000-\\u206f",
              rsSpaceRange =
                " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
              rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
              rsVarRange = "\\ufe0e\\ufe0f",
              rsBreakRange =
                rsMathOpRange +
                rsNonCharRange +
                rsPunctuationRange +
                rsSpaceRange;
            var rsApos = "['’]",
              rsAstral = "[" + rsAstralRange + "]",
              rsBreak = "[" + rsBreakRange + "]",
              rsCombo = "[" + rsComboRange + "]",
              rsDigits = "\\d+",
              rsDingbat = "[" + rsDingbatRange + "]",
              rsLower = "[" + rsLowerRange + "]",
              rsMisc =
                "[^" +
                rsAstralRange +
                rsBreakRange +
                rsDigits +
                rsDingbatRange +
                rsLowerRange +
                rsUpperRange +
                "]",
              rsFitz = "\\ud83c[\\udffb-\\udfff]",
              rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
              rsNonAstral = "[^" + rsAstralRange + "]",
              rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
              rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
              rsUpper = "[" + rsUpperRange + "]",
              rsZWJ = "\\u200d";
            var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
              rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
              rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
              rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
              reOptMod = rsModifier + "?",
              rsOptVar = "[" + rsVarRange + "]?",
              rsOptJoin =
                "(?:" +
                rsZWJ +
                "(?:" +
                [rsNonAstral, rsRegional, rsSurrPair].join("|") +
                ")" +
                rsOptVar +
                reOptMod +
                ")*",
              rsOrdLower = "\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)",
              rsOrdUpper = "\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)",
              rsSeq = rsOptVar + reOptMod + rsOptJoin,
              rsEmoji =
                "(?:" +
                [rsDingbat, rsRegional, rsSurrPair].join("|") +
                ")" +
                rsSeq,
              rsSymbol =
                "(?:" +
                [
                  rsNonAstral + rsCombo + "?",
                  rsCombo,
                  rsRegional,
                  rsSurrPair,
                  rsAstral
                ].join("|") +
                ")";
            var reApos = RegExp(rsApos, "g");
            var reComboMark = RegExp(rsCombo, "g");
            var reUnicode = RegExp(
              rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq,
              "g"
            );
            var reUnicodeWord = RegExp(
              [
                rsUpper +
                  "?" +
                  rsLower +
                  "+" +
                  rsOptContrLower +
                  "(?=" +
                  [rsBreak, rsUpper, "$"].join("|") +
                  ")",
                rsMiscUpper +
                  "+" +
                  rsOptContrUpper +
                  "(?=" +
                  [rsBreak, rsUpper + rsMiscLower, "$"].join("|") +
                  ")",
                rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                rsUpper + "+" + rsOptContrUpper,
                rsOrdUpper,
                rsOrdLower,
                rsDigits,
                rsEmoji
              ].join("|"),
              "g"
            );
            var reHasUnicode = RegExp(
              "[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"
            );
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            var contextProps = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout"
            ];
            var templateCounter = -1;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
              arrayBufferTag
            ] = cloneableTags[dataViewTag] = cloneableTags[
              boolTag
            ] = cloneableTags[dateTag] = cloneableTags[
              float32Tag
            ] = cloneableTags[float64Tag] = cloneableTags[
              int8Tag
            ] = cloneableTags[int16Tag] = cloneableTags[
              int32Tag
            ] = cloneableTags[mapTag] = cloneableTags[
              numberTag
            ] = cloneableTags[objectTag] = cloneableTags[
              regexpTag
            ] = cloneableTags[setTag] = cloneableTags[
              stringTag
            ] = cloneableTags[symbolTag] = cloneableTags[
              uint8Tag
            ] = cloneableTags[uint8ClampedTag] = cloneableTags[
              uint16Tag
            ] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
              weakMapTag
            ] = false;
            var deburredLetters = {
              À: "A",
              Á: "A",
              Â: "A",
              Ã: "A",
              Ä: "A",
              Å: "A",
              à: "a",
              á: "a",
              â: "a",
              ã: "a",
              ä: "a",
              å: "a",
              Ç: "C",
              ç: "c",
              Ð: "D",
              ð: "d",
              È: "E",
              É: "E",
              Ê: "E",
              Ë: "E",
              è: "e",
              é: "e",
              ê: "e",
              ë: "e",
              Ì: "I",
              Í: "I",
              Î: "I",
              Ï: "I",
              ì: "i",
              í: "i",
              î: "i",
              ï: "i",
              Ñ: "N",
              ñ: "n",
              Ò: "O",
              Ó: "O",
              Ô: "O",
              Õ: "O",
              Ö: "O",
              Ø: "O",
              ò: "o",
              ó: "o",
              ô: "o",
              õ: "o",
              ö: "o",
              ø: "o",
              Ù: "U",
              Ú: "U",
              Û: "U",
              Ü: "U",
              ù: "u",
              ú: "u",
              û: "u",
              ü: "u",
              Ý: "Y",
              ý: "y",
              ÿ: "y",
              Æ: "Ae",
              æ: "ae",
              Þ: "Th",
              þ: "th",
              ß: "ss",
              Ā: "A",
              Ă: "A",
              Ą: "A",
              ā: "a",
              ă: "a",
              ą: "a",
              Ć: "C",
              Ĉ: "C",
              Ċ: "C",
              Č: "C",
              ć: "c",
              ĉ: "c",
              ċ: "c",
              č: "c",
              Ď: "D",
              Đ: "D",
              ď: "d",
              đ: "d",
              Ē: "E",
              Ĕ: "E",
              Ė: "E",
              Ę: "E",
              Ě: "E",
              ē: "e",
              ĕ: "e",
              ė: "e",
              ę: "e",
              ě: "e",
              Ĝ: "G",
              Ğ: "G",
              Ġ: "G",
              Ģ: "G",
              ĝ: "g",
              ğ: "g",
              ġ: "g",
              ģ: "g",
              Ĥ: "H",
              Ħ: "H",
              ĥ: "h",
              ħ: "h",
              Ĩ: "I",
              Ī: "I",
              Ĭ: "I",
              Į: "I",
              İ: "I",
              ĩ: "i",
              ī: "i",
              ĭ: "i",
              į: "i",
              ı: "i",
              Ĵ: "J",
              ĵ: "j",
              Ķ: "K",
              ķ: "k",
              ĸ: "k",
              Ĺ: "L",
              Ļ: "L",
              Ľ: "L",
              Ŀ: "L",
              Ł: "L",
              ĺ: "l",
              ļ: "l",
              ľ: "l",
              ŀ: "l",
              ł: "l",
              Ń: "N",
              Ņ: "N",
              Ň: "N",
              Ŋ: "N",
              ń: "n",
              ņ: "n",
              ň: "n",
              ŋ: "n",
              Ō: "O",
              Ŏ: "O",
              Ő: "O",
              ō: "o",
              ŏ: "o",
              ő: "o",
              Ŕ: "R",
              Ŗ: "R",
              Ř: "R",
              ŕ: "r",
              ŗ: "r",
              ř: "r",
              Ś: "S",
              Ŝ: "S",
              Ş: "S",
              Š: "S",
              ś: "s",
              ŝ: "s",
              ş: "s",
              š: "s",
              Ţ: "T",
              Ť: "T",
              Ŧ: "T",
              ţ: "t",
              ť: "t",
              ŧ: "t",
              Ũ: "U",
              Ū: "U",
              Ŭ: "U",
              Ů: "U",
              Ű: "U",
              Ų: "U",
              ũ: "u",
              ū: "u",
              ŭ: "u",
              ů: "u",
              ű: "u",
              ų: "u",
              Ŵ: "W",
              ŵ: "w",
              Ŷ: "Y",
              ŷ: "y",
              Ÿ: "Y",
              Ź: "Z",
              Ż: "Z",
              Ž: "Z",
              ź: "z",
              ż: "z",
              ž: "z",
              Ĳ: "IJ",
              ĳ: "ij",
              Œ: "Oe",
              œ: "oe",
              ŉ: "'n",
              ſ: "s"
            };
            var htmlEscapes = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;"
            };
            var htmlUnescapes = {
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'"
            };
            var stringEscapes = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029"
            };
            var freeParseFloat = parseFloat,
              freeParseInt = parseInt;
            var freeGlobal =
              typeof global == "object" &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            var freeExports =
              typeof exports == "object" &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == "object" &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return (
                  freeProcess &&
                  freeProcess.binding &&
                  freeProcess.binding("util")
                );
              } catch (e) {}
            })();
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
              nodeIsDate = nodeUtil && nodeUtil.isDate,
              nodeIsMap = nodeUtil && nodeUtil.isMap,
              nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
              nodeIsSet = nodeUtil && nodeUtil.isSet,
              nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function addMapEntry(map, pair) {
              map.set(pair[0], pair[1]);
              return map;
            }
            function addSetEntry(set, value) {
              set.add(value);
              return set;
            }
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index = -1,
                length = array == null ? 0 : array.length;
              while (++index < length) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            function arrayEach(array, iteratee) {
              var index = -1,
                length = array == null ? 0 : array.length;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEvery(array, predicate) {
              var index = -1,
                length = array == null ? 0 : array.length;
              while (++index < length) {
                if (!predicate(array[index], index, array)) {
                  return false;
                }
              }
              return true;
            }
            function arrayFilter(array, predicate) {
              var index = -1,
                length = array == null ? 0 : array.length,
                resIndex = 0,
                result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            function arrayIncludesWith(array, value, comparator) {
              var index = -1,
                length = array == null ? 0 : array.length;
              while (++index < length) {
                if (comparator(value, array[index])) {
                  return true;
                }
              }
              return false;
            }
            function arrayMap(array, iteratee) {
              var index = -1,
                length = array == null ? 0 : array.length,
                result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            function arrayPush(array, values) {
              var index = -1,
                length = values.length,
                offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1,
                length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(
                  accumulator,
                  array[length],
                  length,
                  array
                );
              }
              return accumulator;
            }
            function arraySome(array, predicate) {
              var index = -1,
                length = array == null ? 0 : array.length;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            var asciiSize = baseProperty("length");
            function asciiToArray(string) {
              return string.split("");
            }
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function(value, key, collection) {
                if (predicate(value, key, collection)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length,
                index = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
              return value === value
                ? strictIndexOf(array, value, fromIndex)
                : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index = fromIndex - 1,
                length = array.length;
              while (++index < length) {
                if (comparator(array[index], value)) {
                  return index;
                }
              }
              return -1;
            }
            function baseIsNaN(value) {
              return value !== value;
            }
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function basePropertyOf(object) {
              return function(key) {
                return object == null ? undefined : object[key];
              };
            }
            function baseReduce(
              collection,
              iteratee,
              accumulator,
              initAccum,
              eachFunc
            ) {
              eachFunc(collection, function(value, index, collection) {
                accumulator = initAccum
                  ? ((initAccum = false), value)
                  : iteratee(accumulator, value, index, collection);
              });
              return accumulator;
            }
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            function baseSum(array, iteratee) {
              var result,
                index = -1,
                length = array.length;
              while (++index < length) {
                var current = iteratee(array[index]);
                if (current !== undefined) {
                  result = result === undefined ? current : result + current;
                }
              }
              return result;
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseToPairs(object, props) {
              return arrayMap(props, function(key) {
                return [key, object[key]];
              });
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function baseValues(object, props) {
              return arrayMap(props, function(key) {
                return object[key];
              });
            }
            function cacheHas(cache, key) {
              return cache.has(key);
            }
            function charsStartIndex(strSymbols, chrSymbols) {
              var index = -1,
                length = strSymbols.length;
              while (
                ++index < length &&
                baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
              ) {}
              return index;
            }
            function charsEndIndex(strSymbols, chrSymbols) {
              var index = strSymbols.length;
              while (
                index-- &&
                baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
              ) {}
              return index;
            }
            function countHolders(array, placeholder) {
              var length = array.length,
                result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            var deburrLetter = basePropertyOf(deburredLetters);
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            function escapeStringChar(chr) {
              return "\\" + stringEscapes[chr];
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }
            function iteratorToArray(iterator) {
              var data,
                result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function replaceHolders(array, placeholder) {
              var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];
              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            function setToPairs(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = [value, value];
              });
              return result;
            }
            function strictIndexOf(array, value, fromIndex) {
              var index = fromIndex - 1,
                length = array.length;
              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }
            function strictLastIndexOf(array, value, fromIndex) {
              var index = fromIndex + 1;
              while (index--) {
                if (array[index] === value) {
                  return index;
                }
              }
              return index;
            }
            function stringSize(string) {
              return hasUnicode(string)
                ? unicodeSize(string)
                : asciiSize(string);
            }
            function stringToArray(string) {
              return hasUnicode(string)
                ? unicodeToArray(string)
                : asciiToArray(string);
            }
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            function unicodeSize(string) {
              var result = (reUnicode.lastIndex = 0);
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }
            var runInContext = function runInContext(context) {
              context =
                context == null
                  ? root
                  : _.defaults(
                      root.Object(),
                      context,
                      _.pick(root, contextProps)
                    );
              var Array = context.Array,
                Date = context.Date,
                Error = context.Error,
                Function = context.Function,
                Math = context.Math,
                Object = context.Object,
                RegExp = context.RegExp,
                String = context.String,
                TypeError = context.TypeError;
              var arrayProto = Array.prototype,
                funcProto = Function.prototype,
                objectProto = Object.prototype;
              var coreJsData = context["__core-js_shared__"];
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var idCounter = 0;
              var maskSrcKey = (function() {
                var uid = /[^.]+$/.exec(
                  (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                    ""
                );
                return uid ? "Symbol(src)_1." + uid : "";
              })();
              var nativeObjectToString = objectProto.toString;
              var objectCtorString = funcToString.call(Object);
              var oldDash = root._;
              var reIsNative = RegExp(
                "^" +
                  funcToString
                    .call(hasOwnProperty)
                    .replace(reRegExpChar, "\\$&")
                    .replace(
                      /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                      "$1.*?"
                    ) +
                  "$"
              );
              var Buffer = moduleExports ? context.Buffer : undefined,
                Symbol = context.Symbol,
                Uint8Array = context.Uint8Array,
                allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                getPrototype = overArg(Object.getPrototypeOf, Object),
                objectCreate = Object.create,
                propertyIsEnumerable = objectProto.propertyIsEnumerable,
                splice = arrayProto.splice,
                spreadableSymbol = Symbol
                  ? Symbol.isConcatSpreadable
                  : undefined,
                symIterator = Symbol ? Symbol.iterator : undefined,
                symToStringTag = Symbol ? Symbol.toStringTag : undefined;
              var defineProperty = (function() {
                try {
                  var func = getNative(Object, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {}
              })();
              var ctxClearTimeout =
                  context.clearTimeout !== root.clearTimeout &&
                  context.clearTimeout,
                ctxNow = Date && Date.now !== root.Date.now && Date.now,
                ctxSetTimeout =
                  context.setTimeout !== root.setTimeout && context.setTimeout;
              var nativeCeil = Math.ceil,
                nativeFloor = Math.floor,
                nativeGetSymbols = Object.getOwnPropertySymbols,
                nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                nativeIsFinite = context.isFinite,
                nativeJoin = arrayProto.join,
                nativeKeys = overArg(Object.keys, Object),
                nativeMax = Math.max,
                nativeMin = Math.min,
                nativeNow = Date.now,
                nativeParseInt = context.parseInt,
                nativeRandom = Math.random,
                nativeReverse = arrayProto.reverse;
              var DataView = getNative(context, "DataView"),
                Map = getNative(context, "Map"),
                Promise = getNative(context, "Promise"),
                Set = getNative(context, "Set"),
                WeakMap = getNative(context, "WeakMap"),
                nativeCreate = getNative(Object, "create");
              var metaMap = WeakMap && new WeakMap();
              var realNames = {};
              var dataViewCtorString = toSource(DataView),
                mapCtorString = toSource(Map),
                promiseCtorString = toSource(Promise),
                setCtorString = toSource(Set),
                weakMapCtorString = toSource(WeakMap);
              var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                symbolToString = symbolProto ? symbolProto.toString : undefined;
              function lodash(value) {
                if (
                  isObjectLike(value) &&
                  !isArray(value) &&
                  !(value instanceof LazyWrapper)
                ) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              var baseCreate = (function() {
                function object() {}
                return function(proto) {
                  if (!isObject(proto)) {
                    return {};
                  }
                  if (objectCreate) {
                    return objectCreate(proto);
                  }
                  object.prototype = proto;
                  var result = new object();
                  object.prototype = undefined;
                  return result;
                };
              })();
              function baseLodash() {}
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined;
              }
              lodash.templateSettings = {
                escape: reEscape,
                evaluate: reEvaluate,
                interpolate: reInterpolate,
                variable: "",
                imports: { _: lodash }
              };
              lodash.prototype = baseLodash.prototype;
              lodash.prototype.constructor = lodash;
              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              function lazyClone() {
                var result = new LazyWrapper(this.__wrapped__);
                result.__actions__ = copyArray(this.__actions__);
                result.__dir__ = this.__dir__;
                result.__filtered__ = this.__filtered__;
                result.__iteratees__ = copyArray(this.__iteratees__);
                result.__takeCount__ = this.__takeCount__;
                result.__views__ = copyArray(this.__views__);
                return result;
              }
              function lazyReverse() {
                if (this.__filtered__) {
                  var result = new LazyWrapper(this);
                  result.__dir__ = -1;
                  result.__filtered__ = true;
                } else {
                  result = this.clone();
                  result.__dir__ *= -1;
                }
                return result;
              }
              function lazyValue() {
                var array = this.__wrapped__.value(),
                  dir = this.__dir__,
                  isArr = isArray(array),
                  isRight = dir < 0,
                  arrLength = isArr ? array.length : 0,
                  view = getView(0, arrLength, this.__views__),
                  start = view.start,
                  end = view.end,
                  length = end - start,
                  index = isRight ? end : start - 1,
                  iteratees = this.__iteratees__,
                  iterLength = iteratees.length,
                  resIndex = 0,
                  takeCount = nativeMin(length, this.__takeCount__);
                if (
                  !isArr ||
                  (!isRight && arrLength == length && takeCount == length)
                ) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result = [];
                outer: while (length-- && resIndex < takeCount) {
                  index += dir;
                  var iterIndex = -1,
                    value = array[index];
                  while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex],
                      iteratee = data.iteratee,
                      type = data.type,
                      computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) {
                      value = computed;
                    } else if (!computed) {
                      if (type == LAZY_FILTER_FLAG) {
                        continue outer;
                      } else {
                        break outer;
                      }
                    }
                  }
                  result[resIndex++] = value;
                }
                return result;
              }
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              function Hash(entries) {
                var index = -1,
                  length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
              }
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate
                  ? data[key] !== undefined
                  : hasOwnProperty.call(data, key);
              }
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] =
                  nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
              }
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              function ListCache(entries) {
                var index = -1,
                  length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              function listCacheDelete(key) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              function listCacheGet(key) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                return index < 0 ? undefined : data[index][1];
              }
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              function listCacheSet(key, value) {
                var data = this.__data__,
                  index = assocIndexOf(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              function MapCache(entries) {
                var index = -1,
                  length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  hash: new Hash(),
                  map: new (Map || ListCache)(),
                  string: new Hash()
                };
              }
              function mapCacheDelete(key) {
                var result = getMapData(this, key)["delete"](key);
                this.size -= result ? 1 : 0;
                return result;
              }
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              function mapCacheSet(key, value) {
                var data = getMapData(this, key),
                  size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              function SetCache(values) {
                var index = -1,
                  length = values == null ? 0 : values.length;
                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              function Stack(entries) {
                var data = (this.__data__ = new ListCache(entries));
                this.size = data.size;
              }
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              function stackDelete(key) {
                var data = this.__data__,
                  result = data["delete"](key);
                this.size = data.size;
                return result;
              }
              function stackGet(key) {
                return this.__data__.get(key);
              }
              function stackHas(key) {
                return this.__data__.has(key);
              }
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value),
                  isArg = !isArr && isArguments(value),
                  isBuff = !isArr && !isArg && isBuffer(value),
                  isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                  skipIndexes = isArr || isArg || isBuff || isType,
                  result = skipIndexes ? baseTimes(value.length, String) : [],
                  length = result.length;
                for (var key in value) {
                  if (
                    (inherited || hasOwnProperty.call(value, key)) &&
                    !(
                      skipIndexes &&
                      (key == "length" ||
                        (isBuff && (key == "offset" || key == "parent")) ||
                        (isType &&
                          (key == "buffer" ||
                            key == "byteLength" ||
                            key == "byteOffset")) ||
                        isIndex(key, length))
                    )
                  ) {
                    result.push(key);
                  }
                }
                return result;
              }
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined;
              }
              function arraySampleSize(array, n) {
                return shuffleSelf(
                  copyArray(array),
                  baseClamp(n, 0, array.length)
                );
              }
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }
              function assignMergeValue(object, key, value) {
                if (
                  (value !== undefined && !eq(object[key], value)) ||
                  (value === undefined && !(key in object))
                ) {
                  baseAssignValue(object, key, value);
                }
              }
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (
                  !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                  (value === undefined && !(key in object))
                ) {
                  baseAssignValue(object, key, value);
                }
              }
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              function baseAggregator(
                collection,
                setter,
                iteratee,
                accumulator
              ) {
                baseEach(collection, function(value, key, collection) {
                  setter(accumulator, value, iteratee(value), collection);
                });
                return accumulator;
              }
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }
              function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
              }
              function baseAssignValue(object, key, value) {
                if (key == "__proto__" && defineProperty) {
                  defineProperty(object, key, {
                    configurable: true,
                    enumerable: true,
                    value: value,
                    writable: true
                  });
                } else {
                  object[key] = value;
                }
              }
              function baseAt(object, paths) {
                var index = -1,
                  length = paths.length,
                  result = Array(length),
                  skip = object == null;
                while (++index < length) {
                  result[index] = skip ? undefined : get(object, paths[index]);
                }
                return result;
              }
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              function baseClone(
                value,
                bitmask,
                customizer,
                key,
                object,
                stack
              ) {
                var result,
                  isDeep = bitmask & CLONE_DEEP_FLAG,
                  isFlat = bitmask & CLONE_FLAT_FLAG,
                  isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                  result = object
                    ? customizer(value, key, object, stack)
                    : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result);
                  }
                } else {
                  var tag = getTag(value),
                    isFunc = tag == funcTag || tag == genTag;
                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (
                    tag == objectTag ||
                    tag == argsTag ||
                    (isFunc && !object)
                  ) {
                    result = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                      return isFlat
                        ? copySymbolsIn(value, baseAssignIn(result, value))
                        : copySymbols(value, baseAssign(result, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                  }
                }
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result);
                var keysFunc = isFull
                  ? isFlat ? getAllKeysIn : getAllKeys
                  : isFlat ? keysIn : keys;
                var props = isArr ? undefined : keysFunc(value);
                arrayEach(props || value, function(subValue, key) {
                  if (props) {
                    key = subValue;
                    subValue = value[key];
                  }
                  assignValue(
                    result,
                    key,
                    baseClone(subValue, bitmask, customizer, key, value, stack)
                  );
                });
                return result;
              }
              function baseConforms(source) {
                var props = keys(source);
                return function(object) {
                  return baseConformsTo(object, source, props);
                };
              }
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (length--) {
                  var key = props[length],
                    predicate = source[key],
                    value = object[key];
                  if (
                    (value === undefined && !(key in object)) ||
                    !predicate(value)
                  ) {
                    return false;
                  }
                }
                return true;
              }
              function baseDelay(func, wait, args) {
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return setTimeout(function() {
                  func.apply(undefined, args);
                }, wait);
              }
              function baseDifference(array, values, iteratee, comparator) {
                var index = -1,
                  includes = arrayIncludes,
                  isCommon = true,
                  length = array.length,
                  result = [],
                  valuesLength = values.length;
                if (!length) {
                  return result;
                }
                if (iteratee) {
                  values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                  includes = arrayIncludesWith;
                  isCommon = false;
                } else if (values.length >= LARGE_ARRAY_SIZE) {
                  includes = cacheHas;
                  isCommon = false;
                  values = new SetCache(values);
                }
                outer: while (++index < length) {
                  var value = array[index],
                    computed = iteratee == null ? value : iteratee(value);
                  value = comparator || value !== 0 ? value : 0;
                  if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                      if (values[valuesIndex] === computed) {
                        continue outer;
                      }
                    }
                    result.push(value);
                  } else if (!includes(values, computed, comparator)) {
                    result.push(value);
                  }
                }
                return result;
              }
              var baseEach = createBaseEach(baseForOwn);
              var baseEachRight = createBaseEach(baseForOwnRight, true);
              function baseEvery(collection, predicate) {
                var result = true;
                baseEach(collection, function(value, index, collection) {
                  result = !!predicate(value, index, collection);
                  return result;
                });
                return result;
              }
              function baseExtremum(array, iteratee, comparator) {
                var index = -1,
                  length = array.length;
                while (++index < length) {
                  var value = array[index],
                    current = iteratee(value);
                  if (
                    current != null &&
                    (computed === undefined
                      ? current === current && !isSymbol(current)
                      : comparator(current, computed))
                  ) {
                    var computed = current,
                      result = value;
                  }
                }
                return result;
              }
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end =
                  end === undefined || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              function baseFilter(collection, predicate) {
                var result = [];
                baseEach(collection, function(value, index, collection) {
                  if (predicate(value, index, collection)) {
                    result.push(value);
                  }
                });
                return result;
              }
              function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1,
                  length = array.length;
                predicate || (predicate = isFlattenable);
                result || (result = []);
                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      baseFlatten(
                        value,
                        depth - 1,
                        predicate,
                        isStrict,
                        result
                      );
                    } else {
                      arrayPush(result, value);
                    }
                  } else if (!isStrict) {
                    result[result.length] = value;
                  }
                }
                return result;
              }
              var baseFor = createBaseFor();
              var baseForRight = createBaseFor(true);
              function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
              }
              function baseForOwnRight(object, iteratee) {
                return object && baseForRight(object, iteratee, keys);
              }
              function baseFunctions(object, props) {
                return arrayFilter(props, function(key) {
                  return isFunction(object[key]);
                });
              }
              function baseGet(object, path) {
                path = castPath(path, object);
                var index = 0,
                  length = path.length;
                while (object != null && index < length) {
                  object = object[toKey(path[index++])];
                }
                return index && index == length ? object : undefined;
              }
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object)
                  ? result
                  : arrayPush(result, symbolsFunc(object));
              }
              function baseGetTag(value) {
                if (value == null) {
                  return value === undefined ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value)
                  ? getRawTag(value)
                  : objectToString(value);
              }
              function baseGt(value, other) {
                return value > other;
              }
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }
              function baseHasIn(object, key) {
                return object != null && key in Object(object);
              }
              function baseInRange(number, start, end) {
                return (
                  number >= nativeMin(start, end) &&
                  number < nativeMax(start, end)
                );
              }
              function baseIntersection(arrays, iteratee, comparator) {
                var includes = comparator ? arrayIncludesWith : arrayIncludes,
                  length = arrays[0].length,
                  othLength = arrays.length,
                  othIndex = othLength,
                  caches = Array(othLength),
                  maxLength = Infinity,
                  result = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] =
                    !comparator &&
                    (iteratee || (length >= 120 && array.length >= 120))
                      ? new SetCache(othIndex && array)
                      : undefined;
                }
                array = arrays[0];
                var index = -1,
                  seen = caches[0];
                outer: while (++index < length && result.length < maxLength) {
                  var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                  value = comparator || value !== 0 ? value : 0;
                  if (
                    !(seen
                      ? cacheHas(seen, computed)
                      : includes(result, computed, comparator))
                  ) {
                    othIndex = othLength;
                    while (--othIndex) {
                      var cache = caches[othIndex];
                      if (
                        !(cache
                          ? cacheHas(cache, computed)
                          : includes(arrays[othIndex], computed, comparator))
                      ) {
                        continue outer;
                      }
                    }
                    if (seen) {
                      seen.push(computed);
                    }
                    result.push(value);
                  }
                }
                return result;
              }
              function baseInverter(object, setter, iteratee, accumulator) {
                baseForOwn(object, function(value, key, object) {
                  setter(accumulator, iteratee(value), key, object);
                });
                return accumulator;
              }
              function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined : apply(func, object, args);
              }
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              function baseIsArrayBuffer(value) {
                return (
                  isObjectLike(value) && baseGetTag(value) == arrayBufferTag
                );
              }
              function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
              }
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (
                  value == null ||
                  other == null ||
                  (!isObjectLike(value) && !isObjectLike(other))
                ) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(
                  value,
                  other,
                  bitmask,
                  customizer,
                  baseIsEqual,
                  stack
                );
              }
              function baseIsEqualDeep(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
              ) {
                var objIsArr = isArray(object),
                  othIsArr = isArray(other),
                  objTag = objIsArr ? arrayTag : getTag(object),
                  othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag,
                  othIsObj = othTag == objectTag,
                  isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object)
                    ? equalArrays(
                        object,
                        other,
                        bitmask,
                        customizer,
                        equalFunc,
                        stack
                      )
                    : equalByTag(
                        object,
                        other,
                        objTag,
                        bitmask,
                        customizer,
                        equalFunc,
                        stack
                      );
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped =
                      objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                    othIsWrapped =
                      othIsObj && hasOwnProperty.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object,
                      othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(
                      objUnwrapped,
                      othUnwrapped,
                      bitmask,
                      customizer,
                      stack
                    );
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                );
              }
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }
              function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length,
                  length = index,
                  noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (index--) {
                  var data = matchData[index];
                  if (
                    noCustomizer && data[2]
                      ? data[1] !== object[data[0]]
                      : !(data[0] in object)
                  ) {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0],
                    objValue = object[key],
                    srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result = customizer(
                        objValue,
                        srcValue,
                        key,
                        object,
                        source,
                        stack
                      );
                    }
                    if (
                      !(result === undefined
                        ? baseIsEqual(
                            srcValue,
                            objValue,
                            COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                            customizer,
                            stack
                          )
                        : result)
                    ) {
                      return false;
                    }
                  }
                }
                return true;
              }
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
              }
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }
              function baseIsTypedArray(value) {
                return (
                  isObjectLike(value) &&
                  isLength(value.length) &&
                  !!typedArrayTags[baseGetTag(value)]
                );
              }
              function baseIteratee(value) {
                if (typeof value == "function") {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == "object") {
                  return isArray(value)
                    ? baseMatchesProperty(value[0], value[1])
                    : baseMatches(value);
                }
                return property(value);
              }
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (
                    hasOwnProperty.call(object, key) &&
                    key != "constructor"
                  ) {
                    result.push(key);
                  }
                }
                return result;
              }
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object),
                  result = [];
                for (var key in object) {
                  if (
                    !(
                      key == "constructor" &&
                      (isProto || !hasOwnProperty.call(object, key))
                    )
                  ) {
                    result.push(key);
                  }
                }
                return result;
              }
              function baseLt(value, other) {
                return value < other;
              }
              function baseMap(collection, iteratee) {
                var index = -1,
                  result = isArrayLike(collection)
                    ? Array(collection.length)
                    : [];
                baseEach(collection, function(value, key, collection) {
                  result[++index] = iteratee(value, key, collection);
                });
                return result;
              }
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(
                    matchData[0][0],
                    matchData[0][1]
                  );
                }
                return function(object) {
                  return (
                    object === source || baseIsMatch(object, source, matchData)
                  );
                };
              }
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function(object) {
                  var objValue = get(object, path);
                  return objValue === undefined && objValue === srcValue
                    ? hasIn(object, path)
                    : baseIsEqual(
                        srcValue,
                        objValue,
                        COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                      );
                };
              }
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                baseFor(
                  source,
                  function(srcValue, key) {
                    if (isObject(srcValue)) {
                      stack || (stack = new Stack());
                      baseMergeDeep(
                        object,
                        source,
                        key,
                        srcIndex,
                        baseMerge,
                        customizer,
                        stack
                      );
                    } else {
                      var newValue = customizer
                        ? customizer(
                            object[key],
                            srcValue,
                            key + "",
                            object,
                            source,
                            stack
                          )
                        : undefined;
                      if (newValue === undefined) {
                        newValue = srcValue;
                      }
                      assignMergeValue(object, key, newValue);
                    }
                  },
                  keysIn
                );
              }
              function baseMergeDeep(
                object,
                source,
                key,
                srcIndex,
                mergeFunc,
                customizer,
                stack
              ) {
                var objValue = object[key],
                  srcValue = source[key],
                  stacked = stack.get(srcValue);
                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer
                  ? customizer(
                      objValue,
                      srcValue,
                      key + "",
                      object,
                      source,
                      stack
                    )
                  : undefined;
                var isCommon = newValue === undefined;
                if (isCommon) {
                  var isArr = isArray(srcValue),
                    isBuff = !isArr && isBuffer(srcValue),
                    isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer(srcValue, true);
                    } else if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray(srcValue, true);
                    } else {
                      newValue = [];
                    }
                  } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else if (
                      !isObject(objValue) ||
                      (srcIndex && isFunction(objValue))
                    ) {
                      newValue = initCloneObject(srcValue);
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack["delete"](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined;
              }
              function baseOrderBy(collection, iteratees, orders) {
                var index = -1;
                iteratees = arrayMap(
                  iteratees.length ? iteratees : [identity],
                  baseUnary(getIteratee())
                );
                var result = baseMap(collection, function(
                  value,
                  key,
                  collection
                ) {
                  var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value);
                  });
                  return { criteria: criteria, index: ++index, value: value };
                });
                return baseSortBy(result, function(object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              function basePick(object, paths) {
                return basePickBy(object, paths, function(value, path) {
                  return hasIn(object, path);
                });
              }
              function basePickBy(object, paths, predicate) {
                var index = -1,
                  length = paths.length,
                  result = {};
                while (++index < length) {
                  var path = paths[index],
                    value = baseGet(object, path);
                  if (predicate(value, path)) {
                    baseSet(result, castPath(path, object), value);
                  }
                }
                return result;
              }
              function basePropertyDeep(path) {
                return function(object) {
                  return baseGet(object, path);
                };
              }
              function basePullAll(array, values, iteratee, comparator) {
                var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                  index = -1,
                  length = values.length,
                  seen = array;
                if (array === values) {
                  values = copyArray(values);
                }
                if (iteratee) {
                  seen = arrayMap(array, baseUnary(iteratee));
                }
                while (++index < length) {
                  var fromIndex = 0,
                    value = values[index],
                    computed = iteratee ? iteratee(value) : value;
                  while (
                    (fromIndex = indexOf(
                      seen,
                      computed,
                      fromIndex,
                      comparator
                    )) > -1
                  ) {
                    if (seen !== array) {
                      splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0,
                  lastIndex = length - 1;
                while (length--) {
                  var index = indexes[length];
                  if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) {
                      splice.call(array, index, 1);
                    } else {
                      baseUnset(array, index);
                    }
                  }
                }
                return array;
              }
              function baseRandom(lower, upper) {
                return (
                  lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                );
              }
              function baseRange(start, end, step, fromRight) {
                var index = -1,
                  length = nativeMax(
                    nativeCeil((end - start) / (step || 1)),
                    0
                  ),
                  result = Array(length);
                while (length--) {
                  result[fromRight ? length : ++index] = start;
                  start += step;
                }
                return result;
              }
              function baseRepeat(string, n) {
                var result = "";
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result;
                }
                do {
                  if (n % 2) {
                    result += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);
                return result;
              }
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + "");
              }
              function baseSample(collection) {
                return arraySample(values(collection));
              }
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = castPath(path, object);
                var index = -1,
                  length = path.length,
                  lastIndex = length - 1,
                  nested = object;
                while (nested != null && ++index < length) {
                  var key = toKey(path[index]),
                    newValue = value;
                  if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer
                      ? customizer(objValue, key, nested)
                      : undefined;
                    if (newValue === undefined) {
                      newValue = isObject(objValue)
                        ? objValue
                        : isIndex(path[index + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              var baseSetData = !metaMap
                ? identity
                : function(func, data) {
                    metaMap.set(func, data);
                    return func;
                  };
              var baseSetToString = !defineProperty
                ? identity
                : function(func, string) {
                    return defineProperty(func, "toString", {
                      configurable: true,
                      enumerable: false,
                      value: constant(string),
                      writable: true
                    });
                  };
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }
              function baseSlice(array, start, end) {
                var index = -1,
                  length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : (end - start) >>> 0;
                start >>>= 0;
                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }
              function baseSome(collection, predicate) {
                var result;
                baseEach(collection, function(value, index, collection) {
                  result = predicate(value, index, collection);
                  return !result;
                });
                return !!result;
              }
              function baseSortedIndex(array, value, retHighest) {
                var low = 0,
                  high = array == null ? low : array.length;
                if (
                  typeof value == "number" &&
                  value === value &&
                  high <= HALF_MAX_ARRAY_LENGTH
                ) {
                  while (low < high) {
                    var mid = (low + high) >>> 1,
                      computed = array[mid];
                    if (
                      computed !== null &&
                      !isSymbol(computed) &&
                      (retHighest ? computed <= value : computed < value)
                    ) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }
              function baseSortedIndexBy(array, value, iteratee, retHighest) {
                value = iteratee(value);
                var low = 0,
                  high = array == null ? 0 : array.length,
                  valIsNaN = value !== value,
                  valIsNull = value === null,
                  valIsSymbol = isSymbol(value),
                  valIsUndefined = value === undefined;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2),
                    computed = iteratee(array[mid]),
                    othIsDefined = computed !== undefined,
                    othIsNull = computed === null,
                    othIsReflexive = computed === computed,
                    othIsSymbol = isSymbol(computed);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow =
                      othIsReflexive &&
                      othIsDefined &&
                      (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow =
                      othIsReflexive &&
                      othIsDefined &&
                      !othIsNull &&
                      (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }
              function baseSortedUniq(array, iteratee) {
                var index = -1,
                  length = array.length,
                  resIndex = 0,
                  result = [];
                while (++index < length) {
                  var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                  if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result;
              }
              function baseToNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              function baseUniq(array, iteratee, comparator) {
                var index = -1,
                  includes = arrayIncludes,
                  length = array.length,
                  isCommon = true,
                  result = [],
                  seen = result;
                if (comparator) {
                  isCommon = false;
                  includes = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                  var set = iteratee ? null : createSet(array);
                  if (set) {
                    return setToArray(set);
                  }
                  isCommon = false;
                  includes = cacheHas;
                  seen = new SetCache();
                } else {
                  seen = iteratee ? [] : result;
                }
                outer: while (++index < length) {
                  var value = array[index],
                    computed = iteratee ? iteratee(value) : value;
                  value = comparator || value !== 0 ? value : 0;
                  if (isCommon && computed === computed) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                      if (seen[seenIndex] === computed) {
                        continue outer;
                      }
                    }
                    if (iteratee) {
                      seen.push(computed);
                    }
                    result.push(value);
                  } else if (!includes(seen, computed, comparator)) {
                    if (seen !== result) {
                      seen.push(computed);
                    }
                    result.push(value);
                  }
                }
                return result;
              }
              function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
              }
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(
                  object,
                  path,
                  updater(baseGet(object, path)),
                  customizer
                );
              }
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length,
                  index = fromRight ? length : -1;
                while (
                  (fromRight ? index-- : ++index < length) &&
                  predicate(array[index], index, array)
                ) {}
                return isDrop
                  ? baseSlice(
                      array,
                      fromRight ? 0 : index,
                      fromRight ? index + 1 : length
                    )
                  : baseSlice(
                      array,
                      fromRight ? index + 1 : 0,
                      fromRight ? length : index
                    );
              }
              function baseWrapperValue(value, actions) {
                var result = value;
                if (result instanceof LazyWrapper) {
                  result = result.value();
                }
                return arrayReduce(
                  actions,
                  function(result, action) {
                    return action.func.apply(
                      action.thisArg,
                      arrayPush([result], action.args)
                    );
                  },
                  result
                );
              }
              function baseXor(arrays, iteratee, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index = -1,
                  result = Array(length);
                while (++index < length) {
                  var array = arrays[index],
                    othIndex = -1;
                  while (++othIndex < length) {
                    if (othIndex != index) {
                      result[index] = baseDifference(
                        result[index] || array,
                        arrays[othIndex],
                        iteratee,
                        comparator
                      );
                    }
                  }
                }
                return baseUniq(baseFlatten(result, 1), iteratee, comparator);
              }
              function baseZipObject(props, values, assignFunc) {
                var index = -1,
                  length = props.length,
                  valsLength = values.length,
                  result = {};
                while (++index < length) {
                  var value = index < valsLength ? values[index] : undefined;
                  assignFunc(result, props[index], value);
                }
                return result;
              }
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }
              function castFunction(value) {
                return typeof value == "function" ? value : identity;
              }
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object)
                  ? [value]
                  : stringToPath(toString(value));
              }
              var castRest = baseRest;
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined ? length : end;
                return !start && end >= length
                  ? array
                  : baseSlice(array, start, end);
              }
              var clearTimeout =
                ctxClearTimeout ||
                function(id) {
                  return root.clearTimeout(id);
                };
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length,
                  result = allocUnsafe
                    ? allocUnsafe(length)
                    : new buffer.constructor(length);
                buffer.copy(result);
                return result;
              }
              function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(
                  arrayBuffer.byteLength
                );
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
              }
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep
                  ? cloneArrayBuffer(dataView.buffer)
                  : dataView.buffer;
                return new dataView.constructor(
                  buffer,
                  dataView.byteOffset,
                  dataView.byteLength
                );
              }
              function cloneMap(map, isDeep, cloneFunc) {
                var array = isDeep
                  ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG)
                  : mapToArray(map);
                return arrayReduce(array, addMapEntry, new map.constructor());
              }
              function cloneRegExp(regexp) {
                var result = new regexp.constructor(
                  regexp.source,
                  reFlags.exec(regexp)
                );
                result.lastIndex = regexp.lastIndex;
                return result;
              }
              function cloneSet(set, isDeep, cloneFunc) {
                var array = isDeep
                  ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG)
                  : setToArray(set);
                return arrayReduce(array, addSetEntry, new set.constructor());
              }
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep
                  ? cloneArrayBuffer(typedArray.buffer)
                  : typedArray.buffer;
                return new typedArray.constructor(
                  buffer,
                  typedArray.byteOffset,
                  typedArray.length
                );
              }
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined,
                    valIsNull = value === null,
                    valIsReflexive = value === value,
                    valIsSymbol = isSymbol(value);
                  var othIsDefined = other !== undefined,
                    othIsNull = other === null,
                    othIsReflexive = other === other,
                    othIsSymbol = isSymbol(other);
                  if (
                    (!othIsNull &&
                      !othIsSymbol &&
                      !valIsSymbol &&
                      value > other) ||
                    (valIsSymbol &&
                      othIsDefined &&
                      othIsReflexive &&
                      !othIsNull &&
                      !othIsSymbol) ||
                    (valIsNull && othIsDefined && othIsReflexive) ||
                    (!valIsDefined && othIsReflexive) ||
                    !valIsReflexive
                  ) {
                    return 1;
                  }
                  if (
                    (!valIsNull &&
                      !valIsSymbol &&
                      !othIsSymbol &&
                      value < other) ||
                    (othIsSymbol &&
                      valIsDefined &&
                      valIsReflexive &&
                      !valIsNull &&
                      !valIsSymbol) ||
                    (othIsNull && valIsDefined && valIsReflexive) ||
                    (!othIsDefined && valIsReflexive) ||
                    !othIsReflexive
                  ) {
                    return -1;
                  }
                }
                return 0;
              }
              function compareMultiple(object, other, orders) {
                var index = -1,
                  objCriteria = object.criteria,
                  othCriteria = other.criteria,
                  length = objCriteria.length,
                  ordersLength = orders.length;
                while (++index < length) {
                  var result = compareAscending(
                    objCriteria[index],
                    othCriteria[index]
                  );
                  if (result) {
                    if (index >= ordersLength) {
                      return result;
                    }
                    var order = orders[index];
                    return result * (order == "desc" ? -1 : 1);
                  }
                }
                return object.index - other.index;
              }
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1,
                  argsLength = args.length,
                  holdersLength = holders.length,
                  leftIndex = -1,
                  leftLength = partials.length,
                  rangeLength = nativeMax(argsLength - holdersLength, 0),
                  result = Array(leftLength + rangeLength),
                  isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result[leftIndex++] = args[argsIndex++];
                }
                return result;
              }
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1,
                  argsLength = args.length,
                  holdersIndex = -1,
                  holdersLength = holders.length,
                  rightIndex = -1,
                  rightLength = partials.length,
                  rangeLength = nativeMax(argsLength - holdersLength, 0),
                  result = Array(rangeLength + rightLength),
                  isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result;
              }
              function copyArray(source, array) {
                var index = -1,
                  length = source.length;
                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1,
                  length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer
                    ? customizer(object[key], source[key], key, object, source)
                    : undefined;
                  if (newValue === undefined) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }
              function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
              }
              function createAggregator(setter, initializer) {
                return function(collection, iteratee) {
                  var func = isArray(collection)
                      ? arrayAggregator
                      : baseAggregator,
                    accumulator = initializer ? initializer() : {};
                  return func(
                    collection,
                    setter,
                    getIteratee(iteratee, 2),
                    accumulator
                  );
                };
              }
              function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                  var index = -1,
                    length = sources.length,
                    customizer = length > 1 ? sources[length - 1] : undefined,
                    guard = length > 2 ? sources[2] : undefined;
                  customizer =
                    assigner.length > 3 && typeof customizer == "function"
                      ? (length--, customizer)
                      : undefined;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                  }
                  object = Object(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }
              function createBaseEach(eachFunc, fromRight) {
                return function(collection, iteratee) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                  }
                  var length = collection.length,
                    index = fromRight ? length : -1,
                    iterable = Object(collection);
                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              function createBaseFor(fromRight) {
                return function(object, iteratee, keysFunc) {
                  var index = -1,
                    iterable = Object(object),
                    props = keysFunc(object),
                    length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG,
                  Ctor = createCtor(func);
                function wrapper() {
                  var fn =
                    this && this !== root && this instanceof wrapper
                      ? Ctor
                      : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              function createCaseFirst(methodName) {
                return function(string) {
                  string = toString(string);
                  var strSymbols = hasUnicode(string)
                    ? stringToArray(string)
                    : undefined;
                  var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                  var trailing = strSymbols
                    ? castSlice(strSymbols, 1).join("")
                    : string.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              function createCompounder(callback) {
                return function(string) {
                  return arrayReduce(
                    words(deburr(string).replace(reApos, "")),
                    callback,
                    ""
                  );
                };
              }
              function createCtor(Ctor) {
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return new Ctor();
                    case 1:
                      return new Ctor(args[0]);
                    case 2:
                      return new Ctor(args[0], args[1]);
                    case 3:
                      return new Ctor(args[0], args[1], args[2]);
                    case 4:
                      return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                      return new Ctor(
                        args[0],
                        args[1],
                        args[2],
                        args[3],
                        args[4]
                      );
                    case 6:
                      return new Ctor(
                        args[0],
                        args[1],
                        args[2],
                        args[3],
                        args[4],
                        args[5]
                      );
                    case 7:
                      return new Ctor(
                        args[0],
                        args[1],
                        args[2],
                        args[3],
                        args[4],
                        args[5],
                        args[6]
                      );
                  }
                  var thisBinding = baseCreate(Ctor.prototype),
                    result = Ctor.apply(thisBinding, args);
                  return isObject(result) ? result : thisBinding;
                };
              }
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length,
                    args = Array(length),
                    index = length,
                    placeholder = getHolder(wrapper);
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  var holders =
                    length < 3 &&
                    args[0] !== placeholder &&
                    args[length - 1] !== placeholder
                      ? []
                      : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      undefined,
                      args,
                      holders,
                      undefined,
                      undefined,
                      arity - length
                    );
                  }
                  var fn =
                    this && this !== root && this instanceof wrapper
                      ? Ctor
                      : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }
              function createFind(findIndexFunc) {
                return function(collection, predicate, fromIndex) {
                  var iterable = Object(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function(key) {
                      return iteratee(iterable[key], key, iterable);
                    };
                  }
                  var index = findIndexFunc(collection, predicate, fromIndex);
                  return index > -1
                    ? iterable[iteratee ? collection[index] : index]
                    : undefined;
                };
              }
              function createFlow(fromRight) {
                return flatRest(function(funcs) {
                  var length = funcs.length,
                    index = length,
                    prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index--) {
                    var func = funcs[index];
                    if (typeof func != "function") {
                      throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index = wrapper ? index : length;
                  while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func),
                      data = funcName == "wrapper" ? getData(func) : undefined;
                    if (
                      data &&
                      isLaziable(data[0]) &&
                      data[1] ==
                        (WRAP_ARY_FLAG |
                          WRAP_CURRY_FLAG |
                          WRAP_PARTIAL_FLAG |
                          WRAP_REARG_FLAG) &&
                      !data[4].length &&
                      data[9] == 1
                    ) {
                      wrapper = wrapper[getFuncName(data[0])].apply(
                        wrapper,
                        data[3]
                      );
                    } else {
                      wrapper =
                        func.length == 1 && isLaziable(func)
                          ? wrapper[funcName]()
                          : wrapper.thru(func);
                    }
                  }
                  return function() {
                    var args = arguments,
                      value = args[0];
                    if (wrapper && args.length == 1 && isArray(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index = 0,
                      result = length ? funcs[index].apply(this, args) : value;
                    while (++index < length) {
                      result = funcs[index].call(this, result);
                    }
                    return result;
                  };
                });
              }
              function createHybrid(
                func,
                bitmask,
                thisArg,
                partials,
                holders,
                partialsRight,
                holdersRight,
                argPos,
                ary,
                arity
              ) {
                var isAry = bitmask & WRAP_ARY_FLAG,
                  isBind = bitmask & WRAP_BIND_FLAG,
                  isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                  isCurried =
                    bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                  isFlip = bitmask & WRAP_FLIP_FLAG,
                  Ctor = isBindKey ? undefined : createCtor(func);
                function wrapper() {
                  var length = arguments.length,
                    args = Array(length),
                    index = length;
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper),
                      holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(
                      args,
                      partialsRight,
                      holdersRight,
                      isCurried
                    );
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      thisArg,
                      args,
                      newHolders,
                      argPos,
                      ary,
                      arity - length
                    );
                  }
                  var thisBinding = isBind ? thisArg : this,
                    fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary < length) {
                    args.length = ary;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              function createInverter(setter, toIteratee) {
                return function(object, iteratee) {
                  return baseInverter(object, setter, toIteratee(iteratee), {});
                };
              }
              function createMathOperation(operator, defaultValue) {
                return function(value, other) {
                  var result;
                  if (value === undefined && other === undefined) {
                    return defaultValue;
                  }
                  if (value !== undefined) {
                    result = value;
                  }
                  if (other !== undefined) {
                    if (result === undefined) {
                      return other;
                    }
                    if (typeof value == "string" || typeof other == "string") {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result = operator(value, other);
                  }
                  return result;
                };
              }
              function createOver(arrayFunc) {
                return flatRest(function(iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                      return apply(iteratee, thisArg, args);
                    });
                  });
                });
              }
              function createPadding(length, chars) {
                chars = chars === undefined ? " " : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result = baseRepeat(
                  chars,
                  nativeCeil(length / stringSize(chars))
                );
                return hasUnicode(chars)
                  ? castSlice(stringToArray(result), 0, length).join("")
                  : result.slice(0, length);
              }
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG,
                  Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1,
                    argsLength = arguments.length,
                    leftIndex = -1,
                    leftLength = partials.length,
                    args = Array(leftLength + argsLength),
                    fn =
                      this && this !== root && this instanceof wrapper
                        ? Ctor
                        : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              function createRange(fromRight) {
                return function(start, end, step) {
                  if (
                    step &&
                    typeof step != "number" &&
                    isIterateeCall(start, end, step)
                  ) {
                    end = step = undefined;
                  }
                  start = toFinite(start);
                  if (end === undefined) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step =
                    step === undefined
                      ? start < end ? 1 : -1
                      : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              function createRelationalOperation(operator) {
                return function(value, other) {
                  if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }
              function createRecurry(
                func,
                bitmask,
                wrapFunc,
                placeholder,
                thisArg,
                partials,
                holders,
                argPos,
                ary,
                arity
              ) {
                var isCurry = bitmask & WRAP_CURRY_FLAG,
                  newHolders = isCurry ? holders : undefined,
                  newHoldersRight = isCurry ? undefined : holders,
                  newPartials = isCurry ? partials : undefined,
                  newPartialsRight = isCurry ? undefined : partials;
                bitmask |= isCurry
                  ? WRAP_PARTIAL_FLAG
                  : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry
                  ? WRAP_PARTIAL_RIGHT_FLAG
                  : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                }
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  newPartials,
                  newHolders,
                  newPartialsRight,
                  newHoldersRight,
                  argPos,
                  ary,
                  arity
                ];
                var result = wrapFunc.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return setWrapToString(result, func, bitmask);
              }
              function createRound(methodName) {
                var func = Math[methodName];
                return function(number, precision) {
                  number = toNumber(number);
                  precision =
                    precision == null
                      ? 0
                      : nativeMin(toInteger(precision), 292);
                  if (precision) {
                    var pair = (toString(number) + "e").split("e"),
                      value = func(pair[0] + "e" + (+pair[1] + precision));
                    pair = (toString(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              var createSet = !(
                Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY
              )
                ? noop
                : function(values) {
                    return new Set(values);
                  };
              function createToPairs(keysFunc) {
                return function(object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              function createWrap(
                func,
                bitmask,
                thisArg,
                partials,
                holders,
                argPos,
                ary,
                arity
              ) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                  partials = holders = undefined;
                }
                ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                arity = arity === undefined ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials,
                    holdersRight = holders;
                  partials = holders = undefined;
                }
                var data = isBindKey ? undefined : getData(func);
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  partialsRight,
                  holdersRight,
                  argPos,
                  ary,
                  arity
                ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] =
                  newData[9] === undefined
                    ? isBindKey ? 0 : func.length
                    : nativeMax(newData[9] - length, 0);
                if (
                  !arity &&
                  bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)
                ) {
                  bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result = createBind(func, bitmask, thisArg);
                } else if (
                  bitmask == WRAP_CURRY_FLAG ||
                  bitmask == WRAP_CURRY_RIGHT_FLAG
                ) {
                  result = createCurry(func, bitmask, arity);
                } else if (
                  (bitmask == WRAP_PARTIAL_FLAG ||
                    bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
                  !holders.length
                ) {
                  result = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result = createHybrid.apply(undefined, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result, newData), func, bitmask);
              }
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (
                  objValue === undefined ||
                  (eq(objValue, objectProto[key]) &&
                    !hasOwnProperty.call(object, key))
                ) {
                  return srcValue;
                }
                return objValue;
              }
              function customDefaultsMerge(
                objValue,
                srcValue,
                key,
                object,
                source,
                stack
              ) {
                if (isObject(objValue) && isObject(srcValue)) {
                  stack.set(srcValue, objValue);
                  baseMerge(
                    objValue,
                    srcValue,
                    undefined,
                    customDefaultsMerge,
                    stack
                  );
                  stack["delete"](srcValue);
                }
                return objValue;
              }
              function customOmitClone(value) {
                return isPlainObject(value) ? undefined : value;
              }
              function equalArrays(
                array,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
              ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                  arrLength = array.length,
                  othLength = other.length;
                if (
                  arrLength != othLength &&
                  !(isPartial && othLength > arrLength)
                ) {
                  return false;
                }
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var index = -1,
                  result = true,
                  seen =
                    bitmask & COMPARE_UNORDERED_FLAG
                      ? new SetCache()
                      : undefined;
                stack.set(array, other);
                stack.set(other, array);
                while (++index < arrLength) {
                  var arrValue = array[index],
                    othValue = other[index];
                  if (customizer) {
                    var compared = isPartial
                      ? customizer(
                          othValue,
                          arrValue,
                          index,
                          other,
                          array,
                          stack
                        )
                      : customizer(
                          arrValue,
                          othValue,
                          index,
                          array,
                          other,
                          stack
                        );
                  }
                  if (compared !== undefined) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  if (seen) {
                    if (
                      !arraySome(other, function(othValue, othIndex) {
                        if (
                          !cacheHas(seen, othIndex) &&
                          (arrValue === othValue ||
                            equalFunc(
                              arrValue,
                              othValue,
                              bitmask,
                              customizer,
                              stack
                            ))
                        ) {
                          return seen.push(othIndex);
                        }
                      })
                    ) {
                      result = false;
                      break;
                    }
                  } else if (
                    !(
                      arrValue === othValue ||
                      equalFunc(arrValue, othValue, bitmask, customizer, stack)
                    )
                  ) {
                    result = false;
                    break;
                  }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result;
              }
              function equalByTag(
                object,
                other,
                tag,
                bitmask,
                customizer,
                equalFunc,
                stack
              ) {
                switch (tag) {
                  case dataViewTag:
                    if (
                      object.byteLength != other.byteLength ||
                      object.byteOffset != other.byteOffset
                    ) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag:
                    if (
                      object.byteLength != other.byteLength ||
                      !equalFunc(new Uint8Array(object), new Uint8Array(other))
                    ) {
                      return false;
                    }
                    return true;
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return (
                      object.name == other.name &&
                      object.message == other.message
                    );
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result = equalArrays(
                      convert(object),
                      convert(other),
                      bitmask,
                      customizer,
                      equalFunc,
                      stack
                    );
                    stack["delete"](object);
                    return result;
                  case symbolTag:
                    if (symbolValueOf) {
                      return (
                        symbolValueOf.call(object) == symbolValueOf.call(other)
                      );
                    }
                }
                return false;
              }
              function equalObjects(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
              ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                  objProps = getAllKeys(object),
                  objLength = objProps.length,
                  othProps = getAllKeys(other),
                  othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (
                    !(isPartial
                      ? key in other
                      : hasOwnProperty.call(other, key))
                  ) {
                    return false;
                  }
                }
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key],
                    othValue = other[key];
                  if (customizer) {
                    var compared = isPartial
                      ? customizer(
                          othValue,
                          objValue,
                          key,
                          other,
                          object,
                          stack
                        )
                      : customizer(
                          objValue,
                          othValue,
                          key,
                          object,
                          other,
                          stack
                        );
                  }
                  if (
                    !(compared === undefined
                      ? objValue === othValue ||
                        equalFunc(
                          objValue,
                          othValue,
                          bitmask,
                          customizer,
                          stack
                        )
                      : compared)
                  ) {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor,
                    othCtor = other.constructor;
                  if (
                    objCtor != othCtor &&
                    ("constructor" in object && "constructor" in other) &&
                    !(
                      typeof objCtor == "function" &&
                      objCtor instanceof objCtor &&
                      typeof othCtor == "function" &&
                      othCtor instanceof othCtor
                    )
                  ) {
                    result = false;
                  }
                }
                stack["delete"](object);
                stack["delete"](other);
                return result;
              }
              function flatRest(func) {
                return setToString(
                  overRest(func, undefined, flatten),
                  func + ""
                );
              }
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }
              var getData = !metaMap
                ? noop
                : function(func) {
                    return metaMap.get(func);
                  };
              function getFuncName(func) {
                var result = func.name + "",
                  array = realNames[result],
                  length = hasOwnProperty.call(realNames, result)
                    ? array.length
                    : 0;
                while (length--) {
                  var data = array[length],
                    otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result;
              }
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash, "placeholder")
                  ? lodash
                  : func;
                return object.placeholder;
              }
              function getIteratee() {
                var result = lodash.iteratee || iteratee;
                result = result === iteratee ? baseIteratee : result;
                return arguments.length
                  ? result(arguments[0], arguments[1])
                  : result;
              }
              function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key)
                  ? data[typeof key == "string" ? "string" : "hash"]
                  : data.map;
              }
              function getMatchData(object) {
                var result = keys(object),
                  length = result.length;
                while (length--) {
                  var key = result[length],
                    value = object[key];
                  result[length] = [key, value, isStrictComparable(value)];
                }
                return result;
              }
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag),
                  tag = value[symToStringTag];
                try {
                  value[symToStringTag] = undefined;
                  var unmasked = true;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              var getSymbols = !nativeGetSymbols
                ? stubArray
                : function(object) {
                    if (object == null) {
                      return [];
                    }
                    object = Object(object);
                    return arrayFilter(nativeGetSymbols(object), function(
                      symbol
                    ) {
                      return propertyIsEnumerable.call(object, symbol);
                    });
                  };
              var getSymbolsIn = !nativeGetSymbols
                ? stubArray
                : function(object) {
                    var result = [];
                    while (object) {
                      arrayPush(result, getSymbols(object));
                      object = getPrototype(object);
                    }
                    return result;
                  };
              var getTag = baseGetTag;
              if (
                (DataView &&
                  getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                (Map && getTag(new Map()) != mapTag) ||
                (Promise && getTag(Promise.resolve()) != promiseTag) ||
                (Set && getTag(new Set()) != setTag) ||
                (WeakMap && getTag(new WeakMap()) != weakMapTag)
              ) {
                getTag = function(value) {
                  var result = baseGetTag(value),
                    Ctor = result == objectTag ? value.constructor : undefined,
                    ctorString = Ctor ? toSource(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              function getView(start, end, transforms) {
                var index = -1,
                  length = transforms.length;
                while (++index < length) {
                  var data = transforms[index],
                    size = data.size;
                  switch (data.type) {
                    case "drop":
                      start += size;
                      break;
                    case "dropRight":
                      end -= size;
                      break;
                    case "take":
                      end = nativeMin(end, start + size);
                      break;
                    case "takeRight":
                      start = nativeMax(start, end - size);
                      break;
                  }
                }
                return { start: start, end: end };
              }
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index = -1,
                  length = path.length,
                  result = false;
                while (++index < length) {
                  var key = toKey(path[index]);
                  if (!(result = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result || ++index != length) {
                  return result;
                }
                length = object == null ? 0 : object.length;
                return (
                  !!length &&
                  isLength(length) &&
                  isIndex(key, length) &&
                  (isArray(object) || isArguments(object))
                );
              }
              function initCloneArray(array) {
                var length = array.length,
                  result = array.constructor(length);
                if (
                  length &&
                  typeof array[0] == "string" &&
                  hasOwnProperty.call(array, "index")
                ) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }
              function initCloneObject(object) {
                return typeof object.constructor == "function" &&
                  !isPrototype(object)
                  ? baseCreate(getPrototype(object))
                  : {};
              }
              function initCloneByTag(object, tag, cloneFunc, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);
                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);
                  case dataViewTag:
                    return cloneDataView(object, isDeep);
                  case float32Tag:
                  case float64Tag:
                  case int8Tag:
                  case int16Tag:
                  case int32Tag:
                  case uint8Tag:
                  case uint8ClampedTag:
                  case uint16Tag:
                  case uint32Tag:
                    return cloneTypedArray(object, isDeep);
                  case mapTag:
                    return cloneMap(object, isDeep, cloneFunc);
                  case numberTag:
                  case stringTag:
                    return new Ctor(object);
                  case regexpTag:
                    return cloneRegExp(object);
                  case setTag:
                    return cloneSet(object, isDeep, cloneFunc);
                  case symbolTag:
                    return cloneSymbol(object);
                }
              }
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] =
                  (length > 1 ? "& " : "") + details[lastIndex];
                details = details.join(length > 2 ? ", " : " ");
                return source.replace(
                  reWrapComment,
                  "{\n/* [wrapped with " + details + "] */\n"
                );
              }
              function isFlattenable(value) {
                return (
                  isArray(value) ||
                  isArguments(value) ||
                  !!(spreadableSymbol && value && value[spreadableSymbol])
                );
              }
              function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return (
                  !!length &&
                  (typeof value == "number" || reIsUint.test(value)) &&
                  (value > -1 && value % 1 == 0 && value < length)
                );
              }
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (
                  type == "number"
                    ? isArrayLike(object) && isIndex(index, object.length)
                    : type == "string" && index in object
                ) {
                  return eq(object[index], value);
                }
                return false;
              }
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (
                  type == "number" ||
                  type == "symbol" ||
                  type == "boolean" ||
                  value == null ||
                  isSymbol(value)
                ) {
                  return true;
                }
                return (
                  reIsPlainProp.test(value) ||
                  !reIsDeepProp.test(value) ||
                  (object != null && value in Object(object))
                );
              }
              function isKeyable(value) {
                var type = typeof value;
                return type == "string" ||
                  type == "number" ||
                  type == "symbol" ||
                  type == "boolean"
                  ? value !== "__proto__"
                  : value === null;
              }
              function isLaziable(func) {
                var funcName = getFuncName(func),
                  other = lodash[funcName];
                if (
                  typeof other != "function" ||
                  !(funcName in LazyWrapper.prototype)
                ) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              var isMaskable = coreJsData ? isFunction : stubFalse;
              function isPrototype(value) {
                var Ctor = value && value.constructor,
                  proto =
                    (typeof Ctor == "function" && Ctor.prototype) ||
                    objectProto;
                return value === proto;
              }
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              function matchesStrictComparable(key, srcValue) {
                return function(object) {
                  if (object == null) {
                    return false;
                  }
                  return (
                    object[key] === srcValue &&
                    (srcValue !== undefined || key in Object(object))
                  );
                };
              }
              function memoizeCapped(func) {
                var result = memoize(func, function(key) {
                  if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                  }
                  return key;
                });
                var cache = result.cache;
                return result;
              }
              function mergeData(data, source) {
                var bitmask = data[1],
                  srcBitmask = source[1],
                  newBitmask = bitmask | srcBitmask,
                  isCommon =
                    newBitmask <
                    (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo =
                  (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG) ||
                  (srcBitmask == WRAP_ARY_FLAG &&
                    bitmask == WRAP_REARG_FLAG &&
                    data[7].length <= source[8]) ||
                  (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
                    source[7].length <= source[8] &&
                    bitmask == WRAP_CURRY_FLAG);
                if (!(isCommon || isCombo)) {
                  return data;
                }
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  newBitmask |=
                    bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials
                    ? composeArgs(partials, value, source[4])
                    : value;
                  data[4] = partials
                    ? replaceHolders(data[3], PLACEHOLDER)
                    : source[4];
                }
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials
                    ? composeArgsRight(partials, value, source[6])
                    : value;
                  data[6] = partials
                    ? replaceHolders(data[5], PLACEHOLDER)
                    : source[6];
                }
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] =
                    data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                if (data[9] == null) {
                  data[9] = source[9];
                }
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                  for (var key in Object(object)) {
                    result.push(key);
                  }
                }
                return result;
              }
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              function overRest(func, start, transform) {
                start = nativeMax(
                  start === undefined ? func.length - 1 : start,
                  0
                );
                return function() {
                  var args = arguments,
                    index = -1,
                    length = nativeMax(args.length - start, 0),
                    array = Array(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }
              function parent(object, path) {
                return path.length < 2
                  ? object
                  : baseGet(object, baseSlice(path, 0, -1));
              }
              function reorder(array, indexes) {
                var arrLength = array.length,
                  length = nativeMin(indexes.length, arrLength),
                  oldArray = copyArray(array);
                while (length--) {
                  var index = indexes[length];
                  array[length] = isIndex(index, arrLength)
                    ? oldArray[index]
                    : undefined;
                }
                return array;
              }
              var setData = shortOut(baseSetData);
              var setTimeout =
                ctxSetTimeout ||
                function(func, wait) {
                  return root.setTimeout(func, wait);
                };
              var setToString = shortOut(baseSetToString);
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + "";
                return setToString(
                  wrapper,
                  insertWrapDetails(
                    source,
                    updateWrapDetails(getWrapDetails(source), bitmask)
                  )
                );
              }
              function shortOut(func) {
                var count = 0,
                  lastCalled = 0;
                return function() {
                  var stamp = nativeNow(),
                    remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined, arguments);
                };
              }
              function shuffleSelf(array, size) {
                var index = -1,
                  length = array.length,
                  lastIndex = length - 1;
                size = size === undefined ? length : size;
                while (++index < size) {
                  var rand = baseRandom(index, lastIndex),
                    value = array[rand];
                  array[rand] = array[index];
                  array[index] = value;
                }
                array.length = size;
                return array;
              }
              var stringToPath = memoizeCapped(function(string) {
                var result = [];
                if (reLeadingDot.test(string)) {
                  result.push("");
                }
                string.replace(rePropName, function(
                  match,
                  number,
                  quote,
                  string
                ) {
                  result.push(
                    quote ? string.replace(reEscapeChar, "$1") : number || match
                  );
                });
                return result;
              });
              function toKey(value) {
                if (typeof value == "string" || isSymbol(value)) {
                  return value;
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {}
                  try {
                    return func + "";
                  } catch (e) {}
                }
                return "";
              }
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function(pair) {
                  var value = "_." + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result = new LodashWrapper(
                  wrapper.__wrapped__,
                  wrapper.__chain__
                );
                result.__actions__ = copyArray(wrapper.__actions__);
                result.__index__ = wrapper.__index__;
                result.__values__ = wrapper.__values__;
                return result;
              }
              function chunk(array, size, guard) {
                if (
                  guard
                    ? isIterateeCall(array, size, guard)
                    : size === undefined
                ) {
                  size = 1;
                } else {
                  size = nativeMax(toInteger(size), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size < 1) {
                  return [];
                }
                var index = 0,
                  resIndex = 0,
                  result = Array(nativeCeil(length / size));
                while (index < length) {
                  result[resIndex++] = baseSlice(array, index, (index += size));
                }
                return result;
              }
              function compact(array) {
                var index = -1,
                  length = array == null ? 0 : array.length,
                  resIndex = 0,
                  result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array(length - 1),
                  array = arguments[0],
                  index = length;
                while (index--) {
                  args[index - 1] = arguments[index];
                }
                return arrayPush(
                  isArray(array) ? copyArray(array) : [array],
                  baseFlatten(args, 1)
                );
              }
              var difference = baseRest(function(array, values) {
                return isArrayLikeObject(array)
                  ? baseDifference(
                      array,
                      baseFlatten(values, 1, isArrayLikeObject, true)
                    )
                  : [];
              });
              var differenceBy = baseRest(function(array, values) {
                var iteratee = last(values);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return isArrayLikeObject(array)
                  ? baseDifference(
                      array,
                      baseFlatten(values, 1, isArrayLikeObject, true),
                      getIteratee(iteratee, 2)
                    )
                  : [];
              });
              var differenceWith = baseRest(function(array, values) {
                var comparator = last(values);
                if (isArrayLikeObject(comparator)) {
                  comparator = undefined;
                }
                return isArrayLikeObject(array)
                  ? baseDifference(
                      array,
                      baseFlatten(values, 1, isArrayLikeObject, true),
                      undefined,
                      comparator
                    )
                  : [];
              });
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function dropRightWhile(array, predicate) {
                return array && array.length
                  ? baseWhile(array, getIteratee(predicate, 3), true, true)
                  : [];
              }
              function dropWhile(array, predicate) {
                return array && array.length
                  ? baseWhile(array, getIteratee(predicate, 3), true)
                  : [];
              }
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (
                  start &&
                  typeof start != "number" &&
                  isIterateeCall(array, value, start)
                ) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index);
              }
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length - 1;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index =
                    fromIndex < 0
                      ? nativeMax(length + index, 0)
                      : nativeMin(index, length - 1);
                }
                return baseFindIndex(
                  array,
                  getIteratee(predicate, 3),
                  index,
                  true
                );
              }
              function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              function fromPairs(pairs) {
                var index = -1,
                  length = pairs == null ? 0 : pairs.length,
                  result = {};
                while (++index < length) {
                  var pair = pairs[index];
                  result[pair[0]] = pair[1];
                }
                return result;
              }
              function head(array) {
                return array && array.length ? array[0] : undefined;
              }
              function indexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseIndexOf(array, value, index);
              }
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
              }
              var intersection = baseRest(function(arrays) {
                var mapped = arrayMap(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0]
                  ? baseIntersection(mapped)
                  : [];
              });
              var intersectionBy = baseRest(function(arrays) {
                var iteratee = last(arrays),
                  mapped = arrayMap(arrays, castArrayLikeObject);
                if (iteratee === last(mapped)) {
                  iteratee = undefined;
                } else {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0]
                  ? baseIntersection(mapped, getIteratee(iteratee, 2))
                  : [];
              });
              var intersectionWith = baseRest(function(arrays) {
                var comparator = last(arrays),
                  mapped = arrayMap(arrays, castArrayLikeObject);
                comparator =
                  typeof comparator == "function" ? comparator : undefined;
                if (comparator) {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0]
                  ? baseIntersection(mapped, undefined, comparator)
                  : [];
              });
              function join(array, separator) {
                return array == null ? "" : nativeJoin.call(array, separator);
              }
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined;
              }
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index =
                    index < 0
                      ? nativeMax(length + index, 0)
                      : nativeMin(index, length - 1);
                }
                return value === value
                  ? strictLastIndexOf(array, value, index)
                  : baseFindIndex(array, baseIsNaN, index, true);
              }
              function nth(array, n) {
                return array && array.length
                  ? baseNth(array, toInteger(n))
                  : undefined;
              }
              var pull = baseRest(pullAll);
              function pullAll(array, values) {
                return array && array.length && values && values.length
                  ? basePullAll(array, values)
                  : array;
              }
              function pullAllBy(array, values, iteratee) {
                return array && array.length && values && values.length
                  ? basePullAll(array, values, getIteratee(iteratee, 2))
                  : array;
              }
              function pullAllWith(array, values, comparator) {
                return array && array.length && values && values.length
                  ? basePullAll(array, values, undefined, comparator)
                  : array;
              }
              var pullAt = flatRest(function(array, indexes) {
                var length = array == null ? 0 : array.length,
                  result = baseAt(array, indexes);
                basePullAt(
                  array,
                  arrayMap(indexes, function(index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending)
                );
                return result;
              });
              function remove(array, predicate) {
                var result = [];
                if (!(array && array.length)) {
                  return result;
                }
                var index = -1,
                  indexes = [],
                  length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                  }
                }
                basePullAt(array, indexes);
                return result;
              }
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (
                  end &&
                  typeof end != "number" &&
                  isIterateeCall(array, start, end)
                ) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              function sortedIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(
                  array,
                  value,
                  getIteratee(iteratee, 2)
                );
              }
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value);
                  if (index < length && eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              function sortedLastIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(
                  array,
                  value,
                  getIteratee(iteratee, 2),
                  true
                );
              }
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              function sortedUniqBy(array, iteratee) {
                return array && array.length
                  ? baseSortedUniq(array, getIteratee(iteratee, 2))
                  : [];
              }
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
              }
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }
              function takeRightWhile(array, predicate) {
                return array && array.length
                  ? baseWhile(array, getIteratee(predicate, 3), false, true)
                  : [];
              }
              function takeWhile(array, predicate) {
                return array && array.length
                  ? baseWhile(array, getIteratee(predicate, 3))
                  : [];
              }
              var union = baseRest(function(arrays) {
                return baseUniq(
                  baseFlatten(arrays, 1, isArrayLikeObject, true)
                );
              });
              var unionBy = baseRest(function(arrays) {
                var iteratee = last(arrays);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return baseUniq(
                  baseFlatten(arrays, 1, isArrayLikeObject, true),
                  getIteratee(iteratee, 2)
                );
              });
              var unionWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator =
                  typeof comparator == "function" ? comparator : undefined;
                return baseUniq(
                  baseFlatten(arrays, 1, isArrayLikeObject, true),
                  undefined,
                  comparator
                );
              });
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              function uniqBy(array, iteratee) {
                return array && array.length
                  ? baseUniq(array, getIteratee(iteratee, 2))
                  : [];
              }
              function uniqWith(array, comparator) {
                comparator =
                  typeof comparator == "function" ? comparator : undefined;
                return array && array.length
                  ? baseUniq(array, undefined, comparator)
                  : [];
              }
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function(group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function(index) {
                  return arrayMap(array, baseProperty(index));
                });
              }
              function unzipWith(array, iteratee) {
                if (!(array && array.length)) {
                  return [];
                }
                var result = unzip(array);
                if (iteratee == null) {
                  return result;
                }
                return arrayMap(result, function(group) {
                  return apply(iteratee, undefined, group);
                });
              }
              var without = baseRest(function(array, values) {
                return isArrayLikeObject(array)
                  ? baseDifference(array, values)
                  : [];
              });
              var xor = baseRest(function(arrays) {
                return baseXor(arrayFilter(arrays, isArrayLikeObject));
              });
              var xorBy = baseRest(function(arrays) {
                var iteratee = last(arrays);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return baseXor(
                  arrayFilter(arrays, isArrayLikeObject),
                  getIteratee(iteratee, 2)
                );
              });
              var xorWith = baseRest(function(arrays) {
                var comparator = last(arrays);
                comparator =
                  typeof comparator == "function" ? comparator : undefined;
                return baseXor(
                  arrayFilter(arrays, isArrayLikeObject),
                  undefined,
                  comparator
                );
              });
              var zip = baseRest(unzip);
              function zipObject(props, values) {
                return baseZipObject(props || [], values || [], assignValue);
              }
              function zipObjectDeep(props, values) {
                return baseZipObject(props || [], values || [], baseSet);
              }
              var zipWith = baseRest(function(arrays) {
                var length = arrays.length,
                  iteratee = length > 1 ? arrays[length - 1] : undefined;
                iteratee =
                  typeof iteratee == "function"
                    ? (arrays.pop(), iteratee)
                    : undefined;
                return unzipWith(arrays, iteratee);
              });
              function chain(value) {
                var result = lodash(value);
                result.__chain__ = true;
                return result;
              }
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              function thru(value, interceptor) {
                return interceptor(value);
              }
              var wrapperAt = flatRest(function(paths) {
                var length = paths.length,
                  start = length ? paths[0] : 0,
                  value = this.__wrapped__,
                  interceptor = function(object) {
                    return baseAt(object, paths);
                  };
                if (
                  length > 1 ||
                  this.__actions__.length ||
                  !(value instanceof LazyWrapper) ||
                  !isIndex(start)
                ) {
                  return this.thru(interceptor);
                }
                value = value.slice(start, +start + (length ? 1 : 0));
                value.__actions__.push({
                  func: thru,
                  args: [interceptor],
                  thisArg: undefined
                });
                return new LodashWrapper(value, this.__chain__).thru(function(
                  array
                ) {
                  if (length && !array.length) {
                    array.push(undefined);
                  }
                  return array;
                });
              });
              function wrapperChain() {
                return chain(this);
              }
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              function wrapperNext() {
                if (this.__values__ === undefined) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length,
                  value = done ? undefined : this.__values__[this.__index__++];
                return { done: done, value: value };
              }
              function wrapperToIterator() {
                return this;
              }
              function wrapperPlant(value) {
                var result,
                  parent = this;
                while (parent instanceof baseLodash) {
                  var clone = wrapperClone(parent);
                  clone.__index__ = 0;
                  clone.__values__ = undefined;
                  if (result) {
                    previous.__wrapped__ = clone;
                  } else {
                    result = clone;
                  }
                  var previous = clone;
                  parent = parent.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result;
              }
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    func: thru,
                    args: [reverse],
                    thisArg: undefined
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              var countBy = createAggregator(function(result, value, key) {
                if (hasOwnProperty.call(result, key)) {
                  ++result[key];
                } else {
                  baseAssignValue(result, key, 1);
                }
              });
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              var find = createFind(findIndex);
              var findLast = createFind(findLastIndex);
              function flatMap(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), 1);
              }
              function flatMapDeep(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), INFINITY);
              }
              function flatMapDepth(collection, iteratee, depth) {
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee), depth);
              }
              function forEach(collection, iteratee) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee, 3));
              }
              function forEachRight(collection, iteratee) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee, 3));
              }
              var groupBy = createAggregator(function(result, value, key) {
                if (hasOwnProperty.call(result, key)) {
                  result[key].push(value);
                } else {
                  baseAssignValue(result, key, [value]);
                }
              });
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection)
                  ? collection
                  : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection)
                  ? fromIndex <= length &&
                      collection.indexOf(value, fromIndex) > -1
                  : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              var invokeMap = baseRest(function(collection, path, args) {
                var index = -1,
                  isFunc = typeof path == "function",
                  result = isArrayLike(collection)
                    ? Array(collection.length)
                    : [];
                baseEach(collection, function(value) {
                  result[++index] = isFunc
                    ? apply(path, value, args)
                    : baseInvoke(value, path, args);
                });
                return result;
              });
              var keyBy = createAggregator(function(result, value, key) {
                baseAssignValue(result, key, value);
              });
              function map(collection, iteratee) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee, 3));
              }
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              var partition = createAggregator(
                function(result, value, key) {
                  result[key ? 0 : 1].push(value);
                },
                function() {
                  return [[], []];
                }
              );
              function reduce(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce,
                  initAccum = arguments.length < 3;
                return func(
                  collection,
                  getIteratee(iteratee, 4),
                  accumulator,
                  initAccum,
                  baseEach
                );
              }
              function reduceRight(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce,
                  initAccum = arguments.length < 3;
                return func(
                  collection,
                  getIteratee(iteratee, 4),
                  accumulator,
                  initAccum,
                  baseEachRight
                );
              }
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              function sample(collection) {
                var func = isArray(collection) ? arraySample : baseSample;
                return func(collection);
              }
              function sampleSize(collection, n, guard) {
                if (
                  guard ? isIterateeCall(collection, n, guard) : n === undefined
                ) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray(collection)
                  ? arraySampleSize
                  : baseSampleSize;
                return func(collection, n);
              }
              function shuffle(collection) {
                var func = isArray(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection)
                    ? stringSize(collection)
                    : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              var sortBy = baseRest(function(collection, iteratees) {
                if (collection == null) {
                  return [];
                }
                var length = iteratees.length;
                if (
                  length > 1 &&
                  isIterateeCall(collection, iteratees[0], iteratees[1])
                ) {
                  iteratees = [];
                } else if (
                  length > 2 &&
                  isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
                ) {
                  iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
              });
              var now =
                ctxNow ||
                function() {
                  return root.Date.now();
                };
              function after(n, func) {
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              function ary(func, n, guard) {
                n = guard ? undefined : n;
                n = func && n == null ? func.length : n;
                return createWrap(
                  func,
                  WRAP_ARY_FLAG,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  n
                );
              }
              function before(n, func) {
                var result;
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function() {
                  if (--n > 0) {
                    result = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined;
                  }
                  return result;
                };
              }
              var bind = baseRest(function(func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bind));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
              });
              var bindKey = baseRest(function(object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bindKey));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
              });
              function curry(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(
                  func,
                  WRAP_CURRY_FLAG,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  arity
                );
                result.placeholder = curry.placeholder;
                return result;
              }
              function curryRight(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(
                  func,
                  WRAP_CURRY_RIGHT_FLAG,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  undefined,
                  arity
                );
                result.placeholder = curryRight.placeholder;
                return result;
              }
              function debounce(func, wait, options) {
                var lastArgs,
                  lastThis,
                  maxWait,
                  result,
                  timerId,
                  lastCallTime,
                  lastInvokeTime = 0,
                  leading = false,
                  maxing = false,
                  trailing = true;
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = "maxWait" in options;
                  maxWait = maxing
                    ? nativeMax(toNumber(options.maxWait) || 0, wait)
                    : maxWait;
                  trailing =
                    "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs,
                    thisArg = lastThis;
                  lastArgs = lastThis = undefined;
                  lastInvokeTime = time;
                  result = func.apply(thisArg, args);
                  return result;
                }
                function leadingEdge(time) {
                  lastInvokeTime = time;
                  timerId = setTimeout(timerExpired, wait);
                  return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke = time - lastInvokeTime,
                    result = wait - timeSinceLastCall;
                  return maxing
                    ? nativeMin(result, maxWait - timeSinceLastInvoke)
                    : result;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke = time - lastInvokeTime;
                  return (
                    lastCallTime === undefined ||
                    timeSinceLastCall >= wait ||
                    timeSinceLastCall < 0 ||
                    (maxing && timeSinceLastInvoke >= maxWait)
                  );
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = undefined;
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined;
                  return result;
                }
                function cancel() {
                  if (timerId !== undefined) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined;
                }
                function flush() {
                  return timerId === undefined ? result : trailingEdge(now());
                }
                function debounced() {
                  var time = now(),
                    isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === undefined) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      timerId = setTimeout(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                  }
                  return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              var defer = baseRest(function(func, args) {
                return baseDelay(func, 1, args);
              });
              var delay = baseRest(function(func, wait, args) {
                return baseDelay(func, toNumber(wait) || 0, args);
              });
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }
              function memoize(func, resolver) {
                if (
                  typeof func != "function" ||
                  (resolver != null && typeof resolver != "function")
                ) {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function() {
                  var args = arguments,
                    key = resolver ? resolver.apply(this, args) : args[0],
                    cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result = func.apply(this, args);
                  memoized.cache = cache.set(key, result) || cache;
                  return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              memoize.Cache = MapCache;
              function negate(predicate) {
                if (typeof predicate != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return !predicate.call(this);
                    case 1:
                      return !predicate.call(this, args[0]);
                    case 2:
                      return !predicate.call(this, args[0], args[1]);
                    case 3:
                      return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              function once(func) {
                return before(2, func);
              }
              var overArgs = castRest(function(func, transforms) {
                transforms =
                  transforms.length == 1 && isArray(transforms[0])
                    ? arrayMap(transforms[0], baseUnary(getIteratee()))
                    : arrayMap(
                        baseFlatten(transforms, 1),
                        baseUnary(getIteratee())
                      );
                var funcsLength = transforms.length;
                return baseRest(function(args) {
                  var index = -1,
                    length = nativeMin(args.length, funcsLength);
                  while (++index < length) {
                    args[index] = transforms[index].call(this, args[index]);
                  }
                  return apply(func, this, args);
                });
              });
              var partial = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(
                  func,
                  WRAP_PARTIAL_FLAG,
                  undefined,
                  partials,
                  holders
                );
              });
              var partialRight = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(
                  func,
                  WRAP_PARTIAL_RIGHT_FLAG,
                  undefined,
                  partials,
                  holders
                );
              });
              var rearg = flatRest(function(func, indexes) {
                return createWrap(
                  func,
                  WRAP_REARG_FLAG,
                  undefined,
                  undefined,
                  undefined,
                  indexes
                );
              });
              function rest(func, start) {
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start === undefined ? start : toInteger(start);
                return baseRest(func, start);
              }
              function spread(func, start) {
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start == null ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function(args) {
                  var array = args[start],
                    otherArgs = castSlice(args, 0, start);
                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }
              function throttle(func, wait, options) {
                var leading = true,
                  trailing = true;
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = "leading" in options ? !!options.leading : leading;
                  trailing =
                    "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  leading: leading,
                  maxWait: wait,
                  trailing: trailing
                });
              }
              function unary(func) {
                return ary(func, 1);
              }
              function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
              }
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }
              function cloneWith(value, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }
              function cloneDeepWith(value, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                return baseClone(
                  value,
                  CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG,
                  customizer
                );
              }
              function conformsTo(object, source) {
                return (
                  source == null || baseConformsTo(object, source, keys(source))
                );
              }
              function eq(value, other) {
                return value === other || (value !== value && other !== other);
              }
              var gt = createRelationalOperation(baseGt);
              var gte = createRelationalOperation(function(value, other) {
                return value >= other;
              });
              var isArguments = baseIsArguments(
                (function() {
                  return arguments;
                })()
              )
                ? baseIsArguments
                : function(value) {
                    return (
                      isObjectLike(value) &&
                      hasOwnProperty.call(value, "callee") &&
                      !propertyIsEnumerable.call(value, "callee")
                    );
                  };
              var isArray = Array.isArray;
              var isArrayBuffer = nodeIsArrayBuffer
                ? baseUnary(nodeIsArrayBuffer)
                : baseIsArrayBuffer;
              function isArrayLike(value) {
                return (
                  value != null && isLength(value.length) && !isFunction(value)
                );
              }
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              function isBoolean(value) {
                return (
                  value === true ||
                  value === false ||
                  (isObjectLike(value) && baseGetTag(value) == boolTag)
                );
              }
              var isBuffer = nativeIsBuffer || stubFalse;
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
              function isElement(value) {
                return (
                  isObjectLike(value) &&
                  value.nodeType === 1 &&
                  !isPlainObject(value)
                );
              }
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (
                  isArrayLike(value) &&
                  (isArray(value) ||
                    typeof value == "string" ||
                    typeof value.splice == "function" ||
                    isBuffer(value) ||
                    isTypedArray(value) ||
                    isArguments(value))
                ) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !baseKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              function isEqualWith(value, other, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                var result = customizer ? customizer(value, other) : undefined;
                return result === undefined
                  ? baseIsEqual(value, other, undefined, customizer)
                  : !!result;
              }
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return (
                  tag == errorTag ||
                  tag == domExcTag ||
                  (typeof value.message == "string" &&
                    typeof value.name == "string" &&
                    !isPlainObject(value))
                );
              }
              function isFinite(value) {
                return typeof value == "number" && nativeIsFinite(value);
              }
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return (
                  tag == funcTag ||
                  tag == genTag ||
                  tag == asyncTag ||
                  tag == proxyTag
                );
              }
              function isInteger(value) {
                return typeof value == "number" && value == toInteger(value);
              }
              function isLength(value) {
                return (
                  typeof value == "number" &&
                  value > -1 &&
                  value % 1 == 0 &&
                  value <= MAX_SAFE_INTEGER
                );
              }
              function isObject(value) {
                var type = typeof value;
                return (
                  value != null && (type == "object" || type == "function")
                );
              }
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
              function isMatch(object, source) {
                return (
                  object === source ||
                  baseIsMatch(object, source, getMatchData(source))
                );
              }
              function isMatchWith(object, source, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                return baseIsMatch(
                  object,
                  source,
                  getMatchData(source),
                  customizer
                );
              }
              function isNaN(value) {
                return isNumber(value) && value != +value;
              }
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
              }
              function isNull(value) {
                return value === null;
              }
              function isNil(value) {
                return value == null;
              }
              function isNumber(value) {
                return (
                  typeof value == "number" ||
                  (isObjectLike(value) && baseGetTag(value) == numberTag)
                );
              }
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor =
                  hasOwnProperty.call(proto, "constructor") &&
                  proto.constructor;
                return (
                  typeof Ctor == "function" &&
                  Ctor instanceof Ctor &&
                  funcToString.call(Ctor) == objectCtorString
                );
              }
              var isRegExp = nodeIsRegExp
                ? baseUnary(nodeIsRegExp)
                : baseIsRegExp;
              function isSafeInteger(value) {
                return (
                  isInteger(value) &&
                  value >= -MAX_SAFE_INTEGER &&
                  value <= MAX_SAFE_INTEGER
                );
              }
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
              function isString(value) {
                return (
                  typeof value == "string" ||
                  (!isArray(value) &&
                    isObjectLike(value) &&
                    baseGetTag(value) == stringTag)
                );
              }
              function isSymbol(value) {
                return (
                  typeof value == "symbol" ||
                  (isObjectLike(value) && baseGetTag(value) == symbolTag)
                );
              }
              var isTypedArray = nodeIsTypedArray
                ? baseUnary(nodeIsTypedArray)
                : baseIsTypedArray;
              function isUndefined(value) {
                return value === undefined;
              }
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }
              function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
              }
              var lt = createRelationalOperation(baseLt);
              var lte = createRelationalOperation(function(value, other) {
                return value <= other;
              });
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value)
                    ? stringToArray(value)
                    : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value),
                  func =
                    tag == mapTag
                      ? mapToArray
                      : tag == setTag ? setToArray : values;
                return func(value);
              }
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              function toInteger(value) {
                var result = toFinite(value),
                  remainder = result % 1;
                return result === result
                  ? remainder ? result - remainder : result
                  : 0;
              }
              function toLength(value) {
                return value
                  ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH)
                  : 0;
              }
              function toNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other =
                    typeof value.valueOf == "function"
                      ? value.valueOf()
                      : value;
                  value = isObject(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value)
                  ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                  : reIsBadHex.test(value) ? NAN : +value;
              }
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }
              function toSafeInteger(value) {
                return value
                  ? baseClamp(
                      toInteger(value),
                      -MAX_SAFE_INTEGER,
                      MAX_SAFE_INTEGER
                    )
                  : value === 0 ? value : 0;
              }
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              var assign = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                  copyObject(source, keys(source), object);
                  return;
                }
                for (var key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                  }
                }
              });
              var assignIn = createAssigner(function(object, source) {
                copyObject(source, keysIn(source), object);
              });
              var assignInWith = createAssigner(function(
                object,
                source,
                srcIndex,
                customizer
              ) {
                copyObject(source, keysIn(source), object, customizer);
              });
              var assignWith = createAssigner(function(
                object,
                source,
                srcIndex,
                customizer
              ) {
                copyObject(source, keys(source), object, customizer);
              });
              var at = flatRest(baseAt);
              function create(prototype, properties) {
                var result = baseCreate(prototype);
                return properties == null
                  ? result
                  : baseAssign(result, properties);
              }
              var defaults = baseRest(function(args) {
                args.push(undefined, customDefaultsAssignIn);
                return apply(assignInWith, undefined, args);
              });
              var defaultsDeep = baseRest(function(args) {
                args.push(undefined, customDefaultsMerge);
                return apply(mergeWith, undefined, args);
              });
              function findKey(object, predicate) {
                return baseFindKey(
                  object,
                  getIteratee(predicate, 3),
                  baseForOwn
                );
              }
              function findLastKey(object, predicate) {
                return baseFindKey(
                  object,
                  getIteratee(predicate, 3),
                  baseForOwnRight
                );
              }
              function forIn(object, iteratee) {
                return object == null
                  ? object
                  : baseFor(object, getIteratee(iteratee, 3), keysIn);
              }
              function forInRight(object, iteratee) {
                return object == null
                  ? object
                  : baseForRight(object, getIteratee(iteratee, 3), keysIn);
              }
              function forOwn(object, iteratee) {
                return object && baseForOwn(object, getIteratee(iteratee, 3));
              }
              function forOwnRight(object, iteratee) {
                return (
                  object && baseForOwnRight(object, getIteratee(iteratee, 3))
                );
              }
              function functions(object) {
                return object == null
                  ? []
                  : baseFunctions(object, keys(object));
              }
              function functionsIn(object) {
                return object == null
                  ? []
                  : baseFunctions(object, keysIn(object));
              }
              function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path);
                return result === undefined ? defaultValue : result;
              }
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              var invert = createInverter(function(result, value, key) {
                result[value] = key;
              }, constant(identity));
              var invertBy = createInverter(function(result, value, key) {
                if (hasOwnProperty.call(result, value)) {
                  result[value].push(key);
                } else {
                  result[value] = [key];
                }
              }, getIteratee);
              var invoke = baseRest(baseInvoke);
              function keys(object) {
                return isArrayLike(object)
                  ? arrayLikeKeys(object)
                  : baseKeys(object);
              }
              function keysIn(object) {
                return isArrayLike(object)
                  ? arrayLikeKeys(object, true)
                  : baseKeysIn(object);
              }
              function mapKeys(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function(value, key, object) {
                  baseAssignValue(result, iteratee(value, key, object), value);
                });
                return result;
              }
              function mapValues(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);
                baseForOwn(object, function(value, key, object) {
                  baseAssignValue(result, key, iteratee(value, key, object));
                });
                return result;
              }
              var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
              });
              var mergeWith = createAssigner(function(
                object,
                source,
                srcIndex,
                customizer
              ) {
                baseMerge(object, source, srcIndex, customizer);
              });
              var omit = flatRest(function(object, paths) {
                var result = {};
                if (object == null) {
                  return result;
                }
                var isDeep = false;
                paths = arrayMap(paths, function(path) {
                  path = castPath(path, object);
                  isDeep || (isDeep = path.length > 1);
                  return path;
                });
                copyObject(object, getAllKeysIn(object), result);
                if (isDeep) {
                  result = baseClone(
                    result,
                    CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
                    customOmitClone
                  );
                }
                var length = paths.length;
                while (length--) {
                  baseUnset(result, paths[length]);
                }
                return result;
              });
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              var pick = flatRest(function(object, paths) {
                return object == null ? {} : basePick(object, paths);
              });
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                  return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function(value, path) {
                  return predicate(value, path[0]);
                });
              }
              function result(object, path, defaultValue) {
                path = castPath(path, object);
                var index = -1,
                  length = path.length;
                if (!length) {
                  length = 1;
                  object = undefined;
                }
                while (++index < length) {
                  var value =
                    object == null ? undefined : object[toKey(path[index])];
                  if (value === undefined) {
                    index = length;
                    value = defaultValue;
                  }
                  object = isFunction(value) ? value.call(object) : value;
                }
                return object;
              }
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              function setWith(object, path, value, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                return object == null
                  ? object
                  : baseSet(object, path, value, customizer);
              }
              var toPairs = createToPairs(keys);
              var toPairsIn = createToPairs(keysIn);
              function transform(object, iteratee, accumulator) {
                var isArr = isArray(object),
                  isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                iteratee = getIteratee(iteratee, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else if (isObject(object)) {
                    accumulator = isFunction(Ctor)
                      ? baseCreate(getPrototype(object))
                      : {};
                  } else {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function(
                  value,
                  index,
                  object
                ) {
                  return iteratee(accumulator, value, index, object);
                });
                return accumulator;
              }
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              function update(object, path, updater) {
                return object == null
                  ? object
                  : baseUpdate(object, path, castFunction(updater));
              }
              function updateWith(object, path, updater, customizer) {
                customizer =
                  typeof customizer == "function" ? customizer : undefined;
                return object == null
                  ? object
                  : baseUpdate(object, path, castFunction(updater), customizer);
              }
              function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
              }
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }
              function clamp(number, lower, upper) {
                if (upper === undefined) {
                  upper = lower;
                  lower = undefined;
                }
                if (upper !== undefined) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }
              function random(lower, upper, floating) {
                if (
                  floating &&
                  typeof floating != "boolean" &&
                  isIterateeCall(lower, upper, floating)
                ) {
                  upper = floating = undefined;
                }
                if (floating === undefined) {
                  if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined;
                  } else if (typeof lower == "boolean") {
                    floating = lower;
                    lower = undefined;
                  }
                }
                if (lower === undefined && upper === undefined) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(
                    lower +
                      rand *
                        (upper -
                          lower +
                          freeParseFloat("1e-" + ((rand + "").length - 1))),
                    upper
                  );
                }
                return baseRandom(lower, upper);
              }
              var camelCase = createCompounder(function(result, word, index) {
                word = word.toLowerCase();
                return result + (index ? capitalize(word) : word);
              });
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }
              function deburr(string) {
                string = toString(string);
                return (
                  string &&
                  string.replace(reLatin, deburrLetter).replace(reComboMark, "")
                );
              }
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position =
                  position === undefined
                    ? length
                    : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }
              function escape(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string)
                  ? string.replace(reUnescapedHtml, escapeHtmlChar)
                  : string;
              }
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string)
                  ? string.replace(reRegExpChar, "\\$&")
                  : string;
              }
              var kebabCase = createCompounder(function(result, word, index) {
                return result + (index ? "-" : "") + word.toLowerCase();
              });
              var lowerCase = createCompounder(function(result, word, index) {
                return result + (index ? " " : "") + word.toLowerCase();
              });
              var lowerFirst = createCaseFirst("toLowerCase");
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return (
                  createPadding(nativeFloor(mid), chars) +
                  string +
                  createPadding(nativeCeil(mid), chars)
                );
              }
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length
                  ? string + createPadding(length - strLength, chars)
                  : string;
              }
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length
                  ? createPadding(length - strLength, chars) + string
                  : string;
              }
              function parseInt(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(
                  toString(string).replace(reTrimStart, ""),
                  radix || 0
                );
              }
              function repeat(string, n, guard) {
                if (
                  guard ? isIterateeCall(string, n, guard) : n === undefined
                ) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }
              function replace() {
                var args = arguments,
                  string = toString(args[0]);
                return args.length < 3
                  ? string
                  : string.replace(args[1], args[2]);
              }
              var snakeCase = createCompounder(function(result, word, index) {
                return result + (index ? "_" : "") + word.toLowerCase();
              });
              function split(string, separator, limit) {
                if (
                  limit &&
                  typeof limit != "number" &&
                  isIterateeCall(string, separator, limit)
                ) {
                  separator = limit = undefined;
                }
                limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (
                  string &&
                  (typeof separator == "string" ||
                    (separator != null && !isRegExp(separator)))
                ) {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }
              var startCase = createCompounder(function(result, word, index) {
                return result + (index ? " " : "") + upperFirst(word);
              });
              function startsWith(string, target, position) {
                string = toString(string);
                position =
                  position == null
                    ? 0
                    : baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return (
                  string.slice(position, position + target.length) == target
                );
              }
              function template(string, options, guard) {
                var settings = lodash.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined;
                }
                string = toString(string);
                options = assignInWith(
                  {},
                  options,
                  settings,
                  customDefaultsAssignIn
                );
                var imports = assignInWith(
                    {},
                    options.imports,
                    settings.imports,
                    customDefaultsAssignIn
                  ),
                  importsKeys = keys(imports),
                  importsValues = baseValues(imports, importsKeys);
                var isEscaping,
                  isEvaluating,
                  index = 0,
                  interpolate = options.interpolate || reNoMatch,
                  source = "__p += '";
                var reDelimiters = RegExp(
                  (options.escape || reNoMatch).source +
                    "|" +
                    interpolate.source +
                    "|" +
                    (interpolate === reInterpolate ? reEsTemplate : reNoMatch)
                      .source +
                    "|" +
                    (options.evaluate || reNoMatch).source +
                    "|$",
                  "g"
                );
                var sourceURL =
                  "//# sourceURL=" +
                  ("sourceURL" in options
                    ? options.sourceURL
                    : "lodash.templateSources[" + ++templateCounter + "]") +
                  "\n";
                string.replace(reDelimiters, function(
                  match,
                  escapeValue,
                  interpolateValue,
                  esTemplateValue,
                  evaluateValue,
                  offset
                ) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  source += string
                    .slice(index, offset)
                    .replace(reUnescapedString, escapeStringChar);
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source +=
                      "' +\n((__t = (" +
                      interpolateValue +
                      ")) == null ? '' : __t) +\n'";
                  }
                  index = offset + match.length;
                  return match;
                });
                source += "';\n";
                var variable = options.variable;
                if (!variable) {
                  source = "with (obj) {\n" + source + "\n}\n";
                }
                source = (isEvaluating
                  ? source.replace(reEmptyStringLeading, "")
                  : source
                )
                  .replace(reEmptyStringMiddle, "$1")
                  .replace(reEmptyStringTrailing, "$1;");
                source =
                  "function(" +
                  (variable || "obj") +
                  ") {\n" +
                  (variable ? "" : "obj || (obj = {});\n") +
                  "var __t, __p = ''" +
                  (isEscaping ? ", __e = _.escape" : "") +
                  (isEvaluating
                    ? ", __j = Array.prototype.join;\n" +
                      "function print() { __p += __j.call(arguments, '') }\n"
                    : ";\n") +
                  source +
                  "return __p\n}";
                var result = attempt(function() {
                  return Function(
                    importsKeys,
                    sourceURL + "return " + source
                  ).apply(undefined, importsValues);
                });
                result.source = source;
                if (isError(result)) {
                  throw result;
                }
                return result;
              }
              function toLower(value) {
                return toString(value).toLowerCase();
              }
              function toUpper(value) {
                return toString(value).toUpperCase();
              }
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrim, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                  chrSymbols = stringToArray(chars),
                  start = charsStartIndex(strSymbols, chrSymbols),
                  end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start, end).join("");
              }
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimEnd, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                  end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end).join("");
              }
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimStart, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                  start = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start).join("");
              }
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH,
                  omission = DEFAULT_TRUNC_OMISSION;
                if (isObject(options)) {
                  var separator =
                    "separator" in options ? options.separator : separator;
                  length =
                    "length" in options ? toInteger(options.length) : length;
                  omission =
                    "omission" in options
                      ? baseToString(options.omission)
                      : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result = strSymbols
                  ? castSlice(strSymbols, 0, end).join("")
                  : string.slice(0, end);
                if (separator === undefined) {
                  return result + omission;
                }
                if (strSymbols) {
                  end += result.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match,
                      substring = result;
                    if (!separator.global) {
                      separator = RegExp(
                        separator.source,
                        toString(reFlags.exec(separator)) + "g"
                      );
                    }
                    separator.lastIndex = 0;
                    while ((match = separator.exec(substring))) {
                      var newEnd = match.index;
                    }
                    result = result.slice(
                      0,
                      newEnd === undefined ? end : newEnd
                    );
                  }
                } else if (
                  string.indexOf(baseToString(separator), end) != end
                ) {
                  var index = result.lastIndexOf(separator);
                  if (index > -1) {
                    result = result.slice(0, index);
                  }
                }
                return result + omission;
              }
              function unescape(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string)
                  ? string.replace(reEscapedHtml, unescapeHtmlChar)
                  : string;
              }
              var upperCase = createCompounder(function(result, word, index) {
                return result + (index ? " " : "") + word.toUpperCase();
              });
              var upperFirst = createCaseFirst("toUpperCase");
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined : pattern;
                if (pattern === undefined) {
                  return hasUnicodeWord(string)
                    ? unicodeWords(string)
                    : asciiWords(string);
                }
                return string.match(pattern) || [];
              }
              var attempt = baseRest(function(func, args) {
                try {
                  return apply(func, undefined, args);
                } catch (e) {
                  return isError(e) ? e : new Error(e);
                }
              });
              var bindAll = flatRest(function(object, methodNames) {
                arrayEach(methodNames, function(key) {
                  key = toKey(key);
                  baseAssignValue(object, key, bind(object[key], object));
                });
                return object;
              });
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length,
                  toIteratee = getIteratee();
                pairs = !length
                  ? []
                  : arrayMap(pairs, function(pair) {
                      if (typeof pair[1] != "function") {
                        throw new TypeError(FUNC_ERROR_TEXT);
                      }
                      return [toIteratee(pair[0]), pair[1]];
                    });
                return baseRest(function(args) {
                  var index = -1;
                  while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }
              function constant(value) {
                return function() {
                  return value;
                };
              }
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              var flow = createFlow();
              var flowRight = createFlow(true);
              function identity(value) {
                return value;
              }
              function iteratee(func) {
                return baseIteratee(
                  typeof func == "function"
                    ? func
                    : baseClone(func, CLONE_DEEP_FLAG)
                );
              }
              function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
              }
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(
                  path,
                  baseClone(srcValue, CLONE_DEEP_FLAG)
                );
              }
              var method = baseRest(function(path, args) {
                return function(object) {
                  return baseInvoke(object, path, args);
                };
              });
              var methodOf = baseRest(function(object, args) {
                return function(path) {
                  return baseInvoke(object, path, args);
                };
              });
              function mixin(object, source, options) {
                var props = keys(source),
                  methodNames = baseFunctions(source, props);
                if (
                  options == null &&
                  !(isObject(source) && (methodNames.length || !props.length))
                ) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain =
                    !(isObject(options) && "chain" in options) ||
                    !!options.chain,
                  isFunc = isFunction(object);
                arrayEach(methodNames, function(methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function() {
                      var chainAll = this.__chain__;
                      if (chain || chainAll) {
                        var result = object(this.__wrapped__),
                          actions = (result.__actions__ = copyArray(
                            this.__actions__
                          ));
                        actions.push({
                          func: func,
                          args: arguments,
                          thisArg: object
                        });
                        result.__chain__ = chainAll;
                        return result;
                      }
                      return func.apply(
                        object,
                        arrayPush([this.value()], arguments)
                      );
                    };
                  }
                });
                return object;
              }
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }
              function noop() {}
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function(args) {
                  return baseNth(args, n);
                });
              }
              var over = createOver(arrayMap);
              var overEvery = createOver(arrayEvery);
              var overSome = createOver(arraySome);
              function property(path) {
                return isKey(path)
                  ? baseProperty(toKey(path))
                  : basePropertyDeep(path);
              }
              function propertyOf(object) {
                return function(path) {
                  return object == null ? undefined : baseGet(object, path);
                };
              }
              var range = createRange();
              var rangeRight = createRange(true);
              function stubArray() {
                return [];
              }
              function stubFalse() {
                return false;
              }
              function stubObject() {
                return {};
              }
              function stubString() {
                return "";
              }
              function stubTrue() {
                return true;
              }
              function times(n, iteratee) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index = MAX_ARRAY_LENGTH,
                  length = nativeMin(n, MAX_ARRAY_LENGTH);
                iteratee = getIteratee(iteratee);
                n -= MAX_ARRAY_LENGTH;
                var result = baseTimes(length, iteratee);
                while (++index < n) {
                  iteratee(index);
                }
                return result;
              }
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value)
                  ? [value]
                  : copyArray(stringToPath(toString(value)));
              }
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }
              var add = createMathOperation(function(augend, addend) {
                return augend + addend;
              }, 0);
              var ceil = createRound("ceil");
              var divide = createMathOperation(function(dividend, divisor) {
                return dividend / divisor;
              }, 1);
              var floor = createRound("floor");
              function max(array) {
                return array && array.length
                  ? baseExtremum(array, identity, baseGt)
                  : undefined;
              }
              function maxBy(array, iteratee) {
                return array && array.length
                  ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
                  : undefined;
              }
              function mean(array) {
                return baseMean(array, identity);
              }
              function meanBy(array, iteratee) {
                return baseMean(array, getIteratee(iteratee, 2));
              }
              function min(array) {
                return array && array.length
                  ? baseExtremum(array, identity, baseLt)
                  : undefined;
              }
              function minBy(array, iteratee) {
                return array && array.length
                  ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
                  : undefined;
              }
              var multiply = createMathOperation(function(
                multiplier,
                multiplicand
              ) {
                return multiplier * multiplicand;
              }, 1);
              var round = createRound("round");
              var subtract = createMathOperation(function(minuend, subtrahend) {
                return minuend - subtrahend;
              }, 0);
              function sum(array) {
                return array && array.length ? baseSum(array, identity) : 0;
              }
              function sumBy(array, iteratee) {
                return array && array.length
                  ? baseSum(array, getIteratee(iteratee, 2))
                  : 0;
              }
              lodash.after = after;
              lodash.ary = ary;
              lodash.assign = assign;
              lodash.assignIn = assignIn;
              lodash.assignInWith = assignInWith;
              lodash.assignWith = assignWith;
              lodash.at = at;
              lodash.before = before;
              lodash.bind = bind;
              lodash.bindAll = bindAll;
              lodash.bindKey = bindKey;
              lodash.castArray = castArray;
              lodash.chain = chain;
              lodash.chunk = chunk;
              lodash.compact = compact;
              lodash.concat = concat;
              lodash.cond = cond;
              lodash.conforms = conforms;
              lodash.constant = constant;
              lodash.countBy = countBy;
              lodash.create = create;
              lodash.curry = curry;
              lodash.curryRight = curryRight;
              lodash.debounce = debounce;
              lodash.defaults = defaults;
              lodash.defaultsDeep = defaultsDeep;
              lodash.defer = defer;
              lodash.delay = delay;
              lodash.difference = difference;
              lodash.differenceBy = differenceBy;
              lodash.differenceWith = differenceWith;
              lodash.drop = drop;
              lodash.dropRight = dropRight;
              lodash.dropRightWhile = dropRightWhile;
              lodash.dropWhile = dropWhile;
              lodash.fill = fill;
              lodash.filter = filter;
              lodash.flatMap = flatMap;
              lodash.flatMapDeep = flatMapDeep;
              lodash.flatMapDepth = flatMapDepth;
              lodash.flatten = flatten;
              lodash.flattenDeep = flattenDeep;
              lodash.flattenDepth = flattenDepth;
              lodash.flip = flip;
              lodash.flow = flow;
              lodash.flowRight = flowRight;
              lodash.fromPairs = fromPairs;
              lodash.functions = functions;
              lodash.functionsIn = functionsIn;
              lodash.groupBy = groupBy;
              lodash.initial = initial;
              lodash.intersection = intersection;
              lodash.intersectionBy = intersectionBy;
              lodash.intersectionWith = intersectionWith;
              lodash.invert = invert;
              lodash.invertBy = invertBy;
              lodash.invokeMap = invokeMap;
              lodash.iteratee = iteratee;
              lodash.keyBy = keyBy;
              lodash.keys = keys;
              lodash.keysIn = keysIn;
              lodash.map = map;
              lodash.mapKeys = mapKeys;
              lodash.mapValues = mapValues;
              lodash.matches = matches;
              lodash.matchesProperty = matchesProperty;
              lodash.memoize = memoize;
              lodash.merge = merge;
              lodash.mergeWith = mergeWith;
              lodash.method = method;
              lodash.methodOf = methodOf;
              lodash.mixin = mixin;
              lodash.negate = negate;
              lodash.nthArg = nthArg;
              lodash.omit = omit;
              lodash.omitBy = omitBy;
              lodash.once = once;
              lodash.orderBy = orderBy;
              lodash.over = over;
              lodash.overArgs = overArgs;
              lodash.overEvery = overEvery;
              lodash.overSome = overSome;
              lodash.partial = partial;
              lodash.partialRight = partialRight;
              lodash.partition = partition;
              lodash.pick = pick;
              lodash.pickBy = pickBy;
              lodash.property = property;
              lodash.propertyOf = propertyOf;
              lodash.pull = pull;
              lodash.pullAll = pullAll;
              lodash.pullAllBy = pullAllBy;
              lodash.pullAllWith = pullAllWith;
              lodash.pullAt = pullAt;
              lodash.range = range;
              lodash.rangeRight = rangeRight;
              lodash.rearg = rearg;
              lodash.reject = reject;
              lodash.remove = remove;
              lodash.rest = rest;
              lodash.reverse = reverse;
              lodash.sampleSize = sampleSize;
              lodash.set = set;
              lodash.setWith = setWith;
              lodash.shuffle = shuffle;
              lodash.slice = slice;
              lodash.sortBy = sortBy;
              lodash.sortedUniq = sortedUniq;
              lodash.sortedUniqBy = sortedUniqBy;
              lodash.split = split;
              lodash.spread = spread;
              lodash.tail = tail;
              lodash.take = take;
              lodash.takeRight = takeRight;
              lodash.takeRightWhile = takeRightWhile;
              lodash.takeWhile = takeWhile;
              lodash.tap = tap;
              lodash.throttle = throttle;
              lodash.thru = thru;
              lodash.toArray = toArray;
              lodash.toPairs = toPairs;
              lodash.toPairsIn = toPairsIn;
              lodash.toPath = toPath;
              lodash.toPlainObject = toPlainObject;
              lodash.transform = transform;
              lodash.unary = unary;
              lodash.union = union;
              lodash.unionBy = unionBy;
              lodash.unionWith = unionWith;
              lodash.uniq = uniq;
              lodash.uniqBy = uniqBy;
              lodash.uniqWith = uniqWith;
              lodash.unset = unset;
              lodash.unzip = unzip;
              lodash.unzipWith = unzipWith;
              lodash.update = update;
              lodash.updateWith = updateWith;
              lodash.values = values;
              lodash.valuesIn = valuesIn;
              lodash.without = without;
              lodash.words = words;
              lodash.wrap = wrap;
              lodash.xor = xor;
              lodash.xorBy = xorBy;
              lodash.xorWith = xorWith;
              lodash.zip = zip;
              lodash.zipObject = zipObject;
              lodash.zipObjectDeep = zipObjectDeep;
              lodash.zipWith = zipWith;
              lodash.entries = toPairs;
              lodash.entriesIn = toPairsIn;
              lodash.extend = assignIn;
              lodash.extendWith = assignInWith;
              mixin(lodash, lodash);
              lodash.add = add;
              lodash.attempt = attempt;
              lodash.camelCase = camelCase;
              lodash.capitalize = capitalize;
              lodash.ceil = ceil;
              lodash.clamp = clamp;
              lodash.clone = clone;
              lodash.cloneDeep = cloneDeep;
              lodash.cloneDeepWith = cloneDeepWith;
              lodash.cloneWith = cloneWith;
              lodash.conformsTo = conformsTo;
              lodash.deburr = deburr;
              lodash.defaultTo = defaultTo;
              lodash.divide = divide;
              lodash.endsWith = endsWith;
              lodash.eq = eq;
              lodash.escape = escape;
              lodash.escapeRegExp = escapeRegExp;
              lodash.every = every;
              lodash.find = find;
              lodash.findIndex = findIndex;
              lodash.findKey = findKey;
              lodash.findLast = findLast;
              lodash.findLastIndex = findLastIndex;
              lodash.findLastKey = findLastKey;
              lodash.floor = floor;
              lodash.forEach = forEach;
              lodash.forEachRight = forEachRight;
              lodash.forIn = forIn;
              lodash.forInRight = forInRight;
              lodash.forOwn = forOwn;
              lodash.forOwnRight = forOwnRight;
              lodash.get = get;
              lodash.gt = gt;
              lodash.gte = gte;
              lodash.has = has;
              lodash.hasIn = hasIn;
              lodash.head = head;
              lodash.identity = identity;
              lodash.includes = includes;
              lodash.indexOf = indexOf;
              lodash.inRange = inRange;
              lodash.invoke = invoke;
              lodash.isArguments = isArguments;
              lodash.isArray = isArray;
              lodash.isArrayBuffer = isArrayBuffer;
              lodash.isArrayLike = isArrayLike;
              lodash.isArrayLikeObject = isArrayLikeObject;
              lodash.isBoolean = isBoolean;
              lodash.isBuffer = isBuffer;
              lodash.isDate = isDate;
              lodash.isElement = isElement;
              lodash.isEmpty = isEmpty;
              lodash.isEqual = isEqual;
              lodash.isEqualWith = isEqualWith;
              lodash.isError = isError;
              lodash.isFinite = isFinite;
              lodash.isFunction = isFunction;
              lodash.isInteger = isInteger;
              lodash.isLength = isLength;
              lodash.isMap = isMap;
              lodash.isMatch = isMatch;
              lodash.isMatchWith = isMatchWith;
              lodash.isNaN = isNaN;
              lodash.isNative = isNative;
              lodash.isNil = isNil;
              lodash.isNull = isNull;
              lodash.isNumber = isNumber;
              lodash.isObject = isObject;
              lodash.isObjectLike = isObjectLike;
              lodash.isPlainObject = isPlainObject;
              lodash.isRegExp = isRegExp;
              lodash.isSafeInteger = isSafeInteger;
              lodash.isSet = isSet;
              lodash.isString = isString;
              lodash.isSymbol = isSymbol;
              lodash.isTypedArray = isTypedArray;
              lodash.isUndefined = isUndefined;
              lodash.isWeakMap = isWeakMap;
              lodash.isWeakSet = isWeakSet;
              lodash.join = join;
              lodash.kebabCase = kebabCase;
              lodash.last = last;
              lodash.lastIndexOf = lastIndexOf;
              lodash.lowerCase = lowerCase;
              lodash.lowerFirst = lowerFirst;
              lodash.lt = lt;
              lodash.lte = lte;
              lodash.max = max;
              lodash.maxBy = maxBy;
              lodash.mean = mean;
              lodash.meanBy = meanBy;
              lodash.min = min;
              lodash.minBy = minBy;
              lodash.stubArray = stubArray;
              lodash.stubFalse = stubFalse;
              lodash.stubObject = stubObject;
              lodash.stubString = stubString;
              lodash.stubTrue = stubTrue;
              lodash.multiply = multiply;
              lodash.nth = nth;
              lodash.noConflict = noConflict;
              lodash.noop = noop;
              lodash.now = now;
              lodash.pad = pad;
              lodash.padEnd = padEnd;
              lodash.padStart = padStart;
              lodash.parseInt = parseInt;
              lodash.random = random;
              lodash.reduce = reduce;
              lodash.reduceRight = reduceRight;
              lodash.repeat = repeat;
              lodash.replace = replace;
              lodash.result = result;
              lodash.round = round;
              lodash.runInContext = runInContext;
              lodash.sample = sample;
              lodash.size = size;
              lodash.snakeCase = snakeCase;
              lodash.some = some;
              lodash.sortedIndex = sortedIndex;
              lodash.sortedIndexBy = sortedIndexBy;
              lodash.sortedIndexOf = sortedIndexOf;
              lodash.sortedLastIndex = sortedLastIndex;
              lodash.sortedLastIndexBy = sortedLastIndexBy;
              lodash.sortedLastIndexOf = sortedLastIndexOf;
              lodash.startCase = startCase;
              lodash.startsWith = startsWith;
              lodash.subtract = subtract;
              lodash.sum = sum;
              lodash.sumBy = sumBy;
              lodash.template = template;
              lodash.times = times;
              lodash.toFinite = toFinite;
              lodash.toInteger = toInteger;
              lodash.toLength = toLength;
              lodash.toLower = toLower;
              lodash.toNumber = toNumber;
              lodash.toSafeInteger = toSafeInteger;
              lodash.toString = toString;
              lodash.toUpper = toUpper;
              lodash.trim = trim;
              lodash.trimEnd = trimEnd;
              lodash.trimStart = trimStart;
              lodash.truncate = truncate;
              lodash.unescape = unescape;
              lodash.uniqueId = uniqueId;
              lodash.upperCase = upperCase;
              lodash.upperFirst = upperFirst;
              lodash.each = forEach;
              lodash.eachRight = forEachRight;
              lodash.first = head;
              mixin(
                lodash,
                (function() {
                  var source = {};
                  baseForOwn(lodash, function(func, methodName) {
                    if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                      source[methodName] = func;
                    }
                  });
                  return source;
                })(),
                { chain: false }
              );
              lodash.VERSION = VERSION;
              arrayEach(
                [
                  "bind",
                  "bindKey",
                  "curry",
                  "curryRight",
                  "partial",
                  "partialRight"
                ],
                function(methodName) {
                  lodash[methodName].placeholder = lodash;
                }
              );
              arrayEach(["drop", "take"], function(methodName, index) {
                LazyWrapper.prototype[methodName] = function(n) {
                  n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                  var result =
                    this.__filtered__ && !index
                      ? new LazyWrapper(this)
                      : this.clone();
                  if (result.__filtered__) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                  } else {
                    result.__views__.push({
                      size: nativeMin(n, MAX_ARRAY_LENGTH),
                      type: methodName + (result.__dir__ < 0 ? "Right" : "")
                    });
                  }
                  return result;
                };
                LazyWrapper.prototype[methodName + "Right"] = function(n) {
                  return this.reverse()
                    [methodName](n)
                    .reverse();
                };
              });
              arrayEach(["filter", "map", "takeWhile"], function(
                methodName,
                index
              ) {
                var type = index + 1,
                  isFilter =
                    type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function(iteratee) {
                  var result = this.clone();
                  result.__iteratees__.push({
                    iteratee: getIteratee(iteratee, 3),
                    type: type
                  });
                  result.__filtered__ = result.__filtered__ || isFilter;
                  return result;
                };
              });
              arrayEach(["head", "last"], function(methodName, index) {
                var takeName = "take" + (index ? "Right" : "");
                LazyWrapper.prototype[methodName] = function() {
                  return this[takeName](1).value()[0];
                };
              });
              arrayEach(["initial", "tail"], function(methodName, index) {
                var dropName = "drop" + (index ? "" : "Right");
                LazyWrapper.prototype[methodName] = function() {
                  return this.__filtered__
                    ? new LazyWrapper(this)
                    : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function() {
                return this.filter(identity);
              };
              LazyWrapper.prototype.find = function(predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function(predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                if (typeof path == "function") {
                  return new LazyWrapper(this);
                }
                return this.map(function(value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function(predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function(start, end) {
                start = toInteger(start);
                var result = this;
                if (result.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result);
                }
                if (start < 0) {
                  result = result.takeRight(-start);
                } else if (start) {
                  result = result.drop(start);
                }
                if (end !== undefined) {
                  end = toInteger(end);
                  result =
                    end < 0 ? result.dropRight(-end) : result.take(end - start);
                }
                return result;
              };
              LazyWrapper.prototype.takeRightWhile = function(predicate) {
                return this.reverse()
                  .takeWhile(predicate)
                  .reverse();
              };
              LazyWrapper.prototype.toArray = function() {
                return this.take(MAX_ARRAY_LENGTH);
              };
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(
                    methodName
                  ),
                  isTaker = /^(?:head|last)$/.test(methodName),
                  lodashFunc =
                    lodash[
                      isTaker
                        ? "take" + (methodName == "last" ? "Right" : "")
                        : methodName
                    ],
                  retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash.prototype[methodName] = function() {
                  var value = this.__wrapped__,
                    args = isTaker ? [1] : arguments,
                    isLazy = value instanceof LazyWrapper,
                    iteratee = args[0],
                    useLazy = isLazy || isArray(value);
                  var interceptor = function(value) {
                    var result = lodashFunc.apply(
                      lodash,
                      arrayPush([value], args)
                    );
                    return isTaker && chainAll ? result[0] : result;
                  };
                  if (
                    useLazy &&
                    checkIteratee &&
                    typeof iteratee == "function" &&
                    iteratee.length != 1
                  ) {
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__,
                    isHybrid = !!this.__actions__.length,
                    isUnwrapped = retUnwrapped && !chainAll,
                    onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                      func: thru,
                      args: [interceptor],
                      thisArg: undefined
                    });
                    return new LodashWrapper(result, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result = this.thru(interceptor);
                  return isUnwrapped
                    ? isTaker ? result.value()[0] : result.value()
                    : result;
                };
              });
              arrayEach(
                ["pop", "push", "shift", "sort", "splice", "unshift"],
                function(methodName) {
                  var func = arrayProto[methodName],
                    chainName = /^(?:push|sort|unshift)$/.test(methodName)
                      ? "tap"
                      : "thru",
                    retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                  lodash.prototype[methodName] = function() {
                    var args = arguments;
                    if (retUnwrapped && !this.__chain__) {
                      var value = this.value();
                      return func.apply(isArray(value) ? value : [], args);
                    }
                    return this[chainName](function(value) {
                      return func.apply(isArray(value) ? value : [], args);
                    });
                  };
                }
              );
              baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var lodashFunc = lodash[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + "",
                    names = realNames[key] || (realNames[key] = []);
                  names.push({ name: methodName, func: lodashFunc });
                }
              });
              realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
                { name: "wrapper", func: undefined }
              ];
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              lodash.prototype.at = wrapperAt;
              lodash.prototype.chain = wrapperChain;
              lodash.prototype.commit = wrapperCommit;
              lodash.prototype.next = wrapperNext;
              lodash.prototype.plant = wrapperPlant;
              lodash.prototype.reverse = wrapperReverse;
              lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
              lodash.prototype.first = lodash.prototype.head;
              if (symIterator) {
                lodash.prototype[symIterator] = wrapperToIterator;
              }
              return lodash;
            };
            var _ = runInContext();
            if (
              typeof define == "function" &&
              typeof define.amd == "object" &&
              define.amd
            ) {
              root._ = _;
              define(function() {
                return _;
              });
            } else if (freeModule) {
              (freeModule.exports = _)._ = _;
              freeExports._ = _;
            } else {
              root._ = _;
            }
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {}
    ],
    2: [
      function(require, module, exports) {
        module.exports = {
          name: "thrust-platform",
          author: "Hayesmaker Media Ltd @hayes_maker",
          license: "ISC",
          version: "1.1.0",
          private: true,
          scripts: {
            getAssets: "curl -O $THRUST_ASSETS_PACK && tar -xzf assets.tar.gz",
            "debug:android":
              "echo 'Ensure Android device is connected, and has USB debugging enabled' && adb forward tcp:9222 localabstract:chrome_devtools_remote",
            "deploy:skipTests": "npm run heroku",
            preversion: "npm test -s",
            pretest:
              "npm config set travis_build && echo 'Starting tests' && npm run jshint",
            test: "./bin/test.sh",
            "test:old": "npm run test:units && npm run test:e2e",
            "test:units": "npm run mocha",
            "test:e2e": "npm run e2e:travis",
            start: "pm2 start ./bin/www",
            postinstall: "./bin/custom-build.sh",
            prebuild: "mkdir -p public/javascripts/browserify",
            build:
              "npm run browserify:test && npm run browserify:canvas && npm run browserify:main && npm run browserify:mobile && npm run browserify:webgl && npm run browserify:gobbapeas",
            "build:all":
              "npm run build && npm run build:cordova && npm run yuidoc",
            "build:webgl": "npm run browserify:webgl",
            "build:custom": "npm run browserify:gobbapeas",
            postbuild: "npm run uglify:canvas",
            "browserify:test":
              "echo 'browserify:test' && browserify --version && browserify -p proxyquireify/plugin -e src/test/tests.js -o public/javascripts/test/tests.js -d",
            "browserify:canvas":
              "echo 'browserifying canvas build' && browserify --version && browserify -e src/app/main-canvas.js -o public/javascripts/browserify/thrust-engine-canvas.js -d",
            "browserify:mobile":
              "echo 'browserifying mobile build' && browserify --version && browserify -e src/app/main-mobile.js -o public/javascripts/browserify/thrust-engine-mobile.js -d",
            "browserify:webgl":
              "echo 'browserifying webgl build' && browserify --version && browserify -e src/app/main-webgl.js -o public/javascripts/browserify/thrust-engine-webgl.js -d",
            "browserify:main":
              "echo 'browserifying auto build' && browserify --version && browserify -e src/app/main-auto.js -o public/javascripts/browserify/thrust-engine-auto.js -d",
            "browserify:cordova":
              "echo 'browserifying cordova build' && browserify --version && browserify -e src/app/main-cordova.js -o public/javascripts/browserify/thrust-engine-cordova.js -d",
            "browserify:gobbapeas":
              "echo 'browserifying gobbapeas build' && browserify --version && browserify -e src/app/main-gobbapeas.js -o public/javascripts/browserify/thrust-engine-gobbapeas.js -d",
            "uglify:canvas":
              "echo 'Uglifying bundle' && uglifyjs public/javascripts/browserify/thrust-engine-canvas.js -o public/javascripts/browserify/thrust-engine-canvas.min.js --source-map public/javascripts/browserify/thrust-engine.min.js.map --screw-ie8",
            "build:app": "npm run browserify:canvas",
            "build:cordova": "npm run browserify:cordova",
            "build:test":
              "npm run browserify:canvas && npm run browserify:test && npm run test:units",
            "build:mobile": "npm run build:app && npm run browserify:mobile",
            yuidoc:
              "echo 'Compiling source   documentation' && ./node_modules/.bin/yuidoc ./src/app -o ./public/yuidoc",
            nightwatch:
              "echo 'Attempting Local Nightwatch test sweep' && cd test/e2e/nightwatch && nightwatch && cd ../../..",
            mocha:
              "echo 'Attempting to run mocha bdd style unit tests' && phantomjs ./node_modules/mocha-phantomjs-core/mocha-phantomjs-core.js ./public/javascripts/test/index.html",
            jshint:
              "echo 'Static Analysis' && jshint src/app/**/*.js --reporter=node_modules/jshint-stylish",
            "e2e:setup":
              "echo 'Starting Browserstack Local' && ./bin/BrowserStackLocal ${BROWSERSTACK_ACCESS_KEY}",
            selenium:
              "java -jar /usr/local/bin/selenium-server-standalone-2.53.0.jar",
            "e2e:local":
              "echo 'Attempting Local Browserstack test sweep' && cd test/e2e/nightwatch && nightwatch -e browserstack && cd ../../..",
            "e2e:travis":
              "echo 'Travis attempting Browserstack test sweep' && cd test/e2e/nightwatch && nightwatch -c nightwatch.json -e travis && cd ../../..",
            e2e:
              "echo 'Ensure selenium server is running' && npm run nightwatch",
            changelog:
              "echo 'updating changelog' && github_changelog_generator",
            "tweet:deploy": "node ./bin/tweet-deploy",
            assets: "./bin/assets.sh",
            heroku:
              "echo 'Deploying to heroku master' && git push heroku master",
            "update:audio":
              "echo 'run audiosprite task from dev before running this' && cp -rf ../thrust-platform-dev/_dev/audio/result/ ./public/assets/audiosprite/",
            jade: "jade --client --no-debug filename.jade",
            "heroku:rebuild":
              "git commit --allow-empty -m 'empty commit' && git push heroku master"
          },
          dependencies: {
            "basic-auth": "^1.1.0",
            "body-parser": "~1.12.0",
            browserify: "^10.2.1",
            "browserify-shim": "^3.8.6",
            chai: "^3.4.1",
            "cookie-parser": "~1.3.4",
            debug: "~2.1.1",
            express: "~4.12.0",
            "express-authentication": "^0.3.2",
            "express-authentication-basic": "^0.3.1",
            "express-authorization": "^1.0.0",
            install: "^0.8.3",
            jade: "~1.9.2",
            lodash: "^4.0.0",
            morgan: "~1.5.1",
            nightwatch: "^0.8.9",
            npm: "^4.0.5",
            "phase-2-e": "^0.1.3",
            phaser: "^2.6.2",
            "phaser-ce": "^2.7.2",
            pm2: "^0.15.10",
            proxyquire: "^1.7.3",
            "proxyquire-universal": "^1.0.8",
            proxyquireify: "^3.0.0",
            "serve-favicon": "~2.2.0",
            "serve-index": "^1.7.2",
            sinon: "^1.17.2",
            "sinon-chai": "^2.8.0",
            twitter: "^1.2.5",
            "uglify-js": "^2.6.1",
            yuidocjs: "^0.10.2"
          },
          description:
            "Thrust: an awesome 8 bit physics based puzzle/blaster.  Thrust-Platform: A Canvas based HTML5 game engine for making games similar to Thrust",
          main: "bin/www",
          keywords: ["thrust", "phaser"],
          browserify: { transform: ["browserify-shim"] },
          "browserify-shim": {},
          browser: {
            Stats: "./src/libs/stats.js/stats.min.js",
            camera: "./src/app/environment/Camera.js",
            states: "./src/app/states/index.js",
            mocks: "./src/test/mocks/index.js"
          },
          devDependencies: {
            "browserify-istanbul": "^0.2.1",
            istanbul: "^0.3.15",
            istanbulify: "^0.1.0",
            jade: "^1.9.2",
            jshint: "^2.8.0",
            "jshint-stylish": "^2.1.0",
            mocha: "^2.2.5",
            "mocha-phantomjs-core": "^2.0.1",
            "mochify-istanbul": "^2.2.2",
            phantomjs: "^2.1.3"
          }
        };
      },
      {}
    ],
    3: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var _ = require("lodash");
        var options = require("../data/options-model");
        function Background(levelData, groups) {
          this.groups = groups;
          this.levelData = levelData;
          this.gradientBg = game.make.tileSprite(
            0,
            0,
            properties.width,
            490,
            "combined",
            "gradient-bg.png"
          );
          var requiredHeight = this.levelData.mapPosition.y;
          if (options.display.fx.background) {
            this.sprite = game.make.tileSprite(
              0,
              0,
              properties.width,
              requiredHeight,
              "combined",
              "stars-tile.png"
            );
            this.sprite.fixedToCamera = true;
            this.gradientBg.fixedToCamera = true;
            var numStars = Math.floor(Math.random() * 40);
            var stars = [
              "star-1.png",
              "star-2.png",
              "star-3.png",
              "star-4.png"
            ];
            _.times(
              numStars,
              function() {
                var x = Math.floor(Math.random() * properties.width);
                var y = Math.floor(Math.random() * requiredHeight);
                var frame = _.sample(stars);
                var star = game.make.sprite(x, y, "combined", frame);
                this.sprite.addChild(star);
              }.bind(this)
            );
            this.groups.background.add(this.gradientBg);
            this.enable();
          }
        }
        var p = Background.prototype;
        p.enabled = false;
        p.update = function() {
          this.sprite.tilePosition.set(
            -game.camera.x * 0.2,
            -game.camera.y * 0.2
          );
        };
        p.enable = function() {
          this.enabled = true;
          this.groups.background.add(this.sprite);
        };
        p.disable = function() {
          this.enabled = false;
          this.groups.background.remove(this.sprite);
        };
        module.exports = Background;
      },
      { "../data/options-model": 20, "../properties": 31, lodash: 1 }
    ],
    4: [
      function(require, module, exports) {
        function Bullet(collisions, isPlayer) {
          this.isPlayer = isPlayer;
          var bulletBitmap;
          if (isPlayer) {
            bulletBitmap = this.drawPlayerBullet();
          } else {
            bulletBitmap = this.drawEnemyBullet();
          }
          Phaser.Sprite.call(this, game, 0, 0, bulletBitmap);
          this.collisions = collisions;
          this.collisionGroup = isPlayer
            ? this.collisions.bullets
            : this.collisions.enemyBullets;
          this.collidesArr = isPlayer
            ? [
                this.collisions.terrain,
                this.collisions.enemies,
                this.collisions.fuels,
                this.collisions.orb
              ]
            : [
                this.collisions.terrain,
                this.collisions.enemies,
                this.collisions.fuels,
                this.collisions.players,
                this.collisions.orb
              ];
          this.anchor.set(0.5);
          this.checkWorldBounds = true;
          this.outOfBoundsKill = true;
          this.exists = false;
        }
        var p = (Bullet.prototype = Object.create(Phaser.Sprite.prototype, {
          constructor: Bullet
        }));
        p.drawPlayerBullet = function() {
          var bulletBitmap = game.make.bitmapData(15, 2);
          bulletBitmap.ctx.beginPath();
          bulletBitmap.ctx.strokeStyle = "#4affff";
          bulletBitmap.ctx.lineWidth = 2;
          bulletBitmap.ctx.moveTo(1, 1);
          bulletBitmap.ctx.lineTo(15, 1);
          bulletBitmap.ctx.stroke();
          return bulletBitmap;
        };
        p.drawEnemyBullet = function() {
          var bulletBitmap = game.make.bitmapData(4, 4);
          bulletBitmap.ctx.fillStyle = "#ff93ff";
          bulletBitmap.ctx.beginPath();
          bulletBitmap.ctx.lineWidth = 1;
          bulletBitmap.ctx.arc(2, 2, 2, 0, Math.PI * 2, true);
          bulletBitmap.ctx.closePath();
          bulletBitmap.ctx.fill();
          return bulletBitmap;
        };
        p.fire = function(x, y, angle, speed, lifespan) {
          this.reset(x, y);
          this.exists = true;
          this.body.velocity.x = speed * Math.cos(angle);
          this.body.velocity.y = speed * Math.sin(angle);
          this.body.collideWorldBounds = false;
          this.body.setCollisionGroup(this.collisionGroup);
          this.body.collides(this.collidesArr, this.remove, this);
          this.lifespan = lifespan;
          this.body.rotation = angle;
        };
        p.remove = function() {
          this.exists = false;
        };
        module.exports = Bullet;
      },
      {}
    ],
    5: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var sound = require("../utils/sound");
        var gameState = require("../data/game-state");
        function Drone(x, y, width, rotation, groups, collisions) {
          this.groups = groups;
          this.collisions = collisions;
          this.rotation = rotation;
          this.drawFlags(x, y, width, rotation);
          this.initPhysics(width, rotation);
        }
        var p = Drone.prototype;
        p.onTrainingComplete = null;
        p.rotation = 0;
        p.groups = null;
        p.collisions = null;
        p.flag1 = null;
        p.flag2 = null;
        p.sensor = null;
        p.hasPassed = false;
        p.nextDrone = null;
        p.drawFlags = function(x, y, width, rotation) {
          var pos = new Phaser.Point();
          pos.x = Math.cos(rotation) * width;
          pos.y = Math.sin(rotation) * width;
          this.flag1 = game.add.sprite(
            x - pos.x,
            y + pos.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          this.flag2 = game.add.sprite(
            x + pos.x,
            y - pos.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          var bmd = game.make.bitmapData(1, 1);
          bmd.rect(0, 0, 1, 1, "rgba(0, 255, 0, 0)");
          this.sensor = game.add.sprite(x + this.flag1.width / 2, y, bmd);
          this.sensor.width = width * 2 - this.flag1.width;
          this.sensor.height = 10;
          this.deactivate();
        };
        p.initPhysics = function(width, rotation) {
          game.physics.p2.enable(this.sensor, properties.dev.debugPhysics);
          this.sensor.body.clearShapes();
          var box = this.sensor.body.addRectangle(
            this.sensor.width,
            10,
            0,
            0,
            0
          );
          box.sensor = true;
          this.sensor.body.rotation = -rotation;
          this.sensor.body.motionState = 2;
          this.sensor.body.setCollisionGroup(this.collisions.drones);
          this.sensor.body.collides([this.collisions.players]);
          this.sensor.body.onBeginContact.add(this.contactStart, this);
          this.sensor.body.onEndContact.add(this.contactLost, this);
        };
        p.lastDrone = function() {
          this.onTrainingComplete = new Phaser.Signal();
        };
        p.contactLost = function() {};
        p.deactivate = function() {
          this.active = false;
          this.flag1.alpha = 0.25;
          this.flag2.alpha = 0.25;
        };
        p.activate = function() {
          this.active = true;
          this.flag1.alpha = 1;
          this.flag2.alpha = 1;
        };
        p.contactStart = function() {
          if (!this.hasPassed && this.active) {
            this.hasPassed = true;
            this.flag1.tint = 65280;
            this.flag2.tint = 65280;
            if (this.nextDrone) {
              this.nextDrone.activate();
              gameState.score += 1;
              sound.playSound(sound.TRAINING_DRONE_PASSED, 1, false);
            } else {
              this.onTrainingComplete.dispatch();
            }
          }
        };
        module.exports = Drone;
      },
      { "../data/game-state": 18, "../properties": 31, "../utils/sound": 71 }
    ],
    6: [
      function(require, module, exports) {
        (function(global) {
          "use strict";
          var PhysicsActor = require("./PhysicsActor");
          var FuelParticlesSystem = require("../environment/particles/FuelParticlesSystem");
          var gameState = require("../data/game-state");
          var _ = require("lodash");
          var particles = require("../environment/particles/manager");
          var TweenLite = global.TweenLite;
          var sound = require("../utils/sound");
          var properties = require("../properties");
          function Fuel(
            collisions,
            groups,
            imageCacheKey,
            imageFrameKey,
            x,
            y,
            player
          ) {
            PhysicsActor.call(
              this,
              collisions,
              groups,
              imageCacheKey,
              imageFrameKey,
              x,
              y
            );
            this.health = 250;
            this.player = player;
            this.init();
          }
          var p = (Fuel.prototype = Object.create(PhysicsActor.prototype, {
            constructor: Fuel
          }));
          module.exports = Fuel;
          p.particles = null;
          p.refuelAmount = 2;
          p.isRefuelling = false;
          p.isAnimating = false;
          p.init = function() {
            this.createParticles();
            this.initCustomPhysics(true);
            this.drawSensor();
            this.initSensorPhysics();
            this.setPhysicsShape();
            this.createFuelAnim();
          };
          p.createFuelAnim = function() {
            this.fuelAnim = game.add.sprite(
              this.x,
              this.y,
              "combined",
              "Fuel_Anim_001.png"
            );
            this.fuelAnim.x -= this.width;
            this.fuelAnim.y -= this.height / 2 + this.fuelAnim.height / 2;
            this.fuelAnim.animations.add(
              "refuelling",
              [
                "Fuel_Anim_001.png",
                "Fuel_Anim_002.png",
                "Fuel_Anim_003.png",
                "Fuel_Anim_004.png",
                "Fuel_Anim_005.png",
                "Fuel_Anim_006.png",
                "Fuel_Anim_007.png",
                "Fuel_Anim_008.png",
                "Fuel_Anim_009.png",
                "Fuel_Anim_010.png",
                "Fuel_Anim_011.png",
                "Fuel_Anim_012.png",
                "Fuel_Anim_013.png",
                "Fuel_Anim_014.png",
                "Fuel_Anim_015.png",
                "Fuel_Anim_016.png",
                "Fuel_Anim_017.png",
                "Fuel_Anim_018.png",
                "Fuel_Anim_019.png",
                "Fuel_Anim_020.png",
                "Fuel_Anim_021.png",
                "Fuel_Anim_022.png",
                "Fuel_Anim_023.png",
                "Fuel_Anim_024.png",
                "Fuel_Anim_025.png",
                "Fuel_Anim_026.png",
                "Fuel_Anim_027.png",
                "Fuel_Anim_028.png",
                "Fuel_Anim_029.png",
                "Fuel_Anim_030.png"
              ],
              60,
              true
            );
            this.fuelAnim.visible = true;
            this.fuelAnim.play("refuelling");
          };
          p.drawSensor = function() {
            var bmd = game.make.bitmapData(1, 1);
            bmd.rect(0, 0, 1, 1, "rgba(0, 255, 0, 0)");
            this.sensor = game.add.sprite(this.x, this.y - this.height, bmd);
            this.sensor.width = this.width;
            this.sensor.height = this.height;
            this.sensor.x -= this.sensor.width / 2;
            this.sensor.y -= this.sensor.height / 2;
          };
          p.initSensorPhysics = function() {
            game.physics.p2.enable(this.sensor, properties.dev.debugPhysics);
            this.sensor.body.clearShapes();
            var box = this.sensor.body.addRectangle(
              this.sensor.width,
              this.sensor.height,
              this.sensor.width / 2,
              this.sensor.height / 2,
              0
            );
            box.sensor = true;
            this.sensor.body.motionState = 2;
            this.sensor.body.setCollisionGroup(this.collisions.fuels);
            this.sensor.body.collides([this.collisions.players]);
            this.sensor.body.onBeginContact.add(this.contactStart, this);
            this.sensor.body.onEndContact.add(this.contactLost, this);
          };
          p.contactLost = function() {
            this.isRefuelling = false;
          };
          p.contactStart = function() {
            this.isRefuelling = true;
          };
          p.explode = function() {
            sound.playSound(sound.FUEL_EXPLODE);
            particles.fuelExplode(this.x, this.y + this.height / 2);
            gameState.addScore(gameState.SCORES.FUEL_DESTROYED);
            this.cleanup();
          };
          p.update = function() {
            if (this.isRefuelling) {
              if (!this.particles.isEmitting) {
                this.player.doRefuel();
                this.particles.start(this.position, this.player.position);
                TweenMax.to(this, 0.5, { tint: 16777214, tintAmount: 1 });
              }
              this.particles.update();
              gameState.fuel += this.refuelAmount;
              this.damage(1);
            } else {
              if (this.particles.isEmitting) {
                this.player.clearRefuel();
                this.particles.stop();
                this.tint = 16777215;
              }
            }
          };
          p.createParticles = function() {
            this.particles = new FuelParticlesSystem();
            this.particles.init(this.position);
          };
          p.setPhysicsShape = function() {
            this.fuelPadding = { x: 0, y: 0 };
            this.body.addRectangle(
              this.width - this.fuelPadding.x * 2,
              this.height - this.fuelPadding.y,
              this.fuelPadding.x,
              this.fuelPadding.y
            );
            this.body.setCollisionGroup(this.collisions.fuels);
            this.body.collides(
              [this.collisions.players, this.collisions.bullets],
              this.explode,
              this
            );
          };
          p.kill = function() {
            sound.playSound(sound.FUEL_REFUEL_COMPLETE, 3);
            this.alive = false;
            gameState.addScore(gameState.SCORES.FUEL_COLLECTED);
            TweenLite.to(this, 0.3, {
              alpha: 0,
              ease: Quad.easeOut,
              onComplete: _.bind(this.cleanup, this)
            });
          };
          p.cleanup = function() {
            Phaser.Sprite.prototype.kill.call(this);
            if (this.fuelAnim) {
              this.fuelAnim.kill();
            }
            if (this.body) {
              this.body.removeFromWorld();
              this.body.destroy();
            }
            if (this.sensor) {
              this.sensor.kill();
              this.sensor.body.removeFromWorld();
              this.sensor.body.destroy();
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {
        "../data/game-state": 18,
        "../environment/particles/FuelParticlesSystem": 27,
        "../environment/particles/manager": 29,
        "../properties": 31,
        "../utils/sound": 71,
        "./PhysicsActor": 11,
        lodash: 1
      }
    ],
    7: [
      function(require, module, exports) {
        "use strict";
        var PhysicsActor = require("./PhysicsActor");
        var sound = require("../utils/sound");
        function GateSwitch(
          collisions,
          groups,
          map,
          x,
          y,
          angleDeg,
          gateDuration
        ) {
          this.gateDuration = gateDuration * 1e3 || 6e3;
          var bmd = game.make.bitmapData(50, 50);
          bmd.ctx.strokeStyle = "#ffffff";
          bmd.ctx.lineWidth = 2;
          bmd.ctx.beginPath();
          bmd.ctx.moveTo(25, 25);
          bmd.ctx.arc(25, 25, 20, Math.PI / 2, 3 * Math.PI / 2, false);
          bmd.ctx.closePath();
          bmd.ctx.stroke();
          PhysicsActor.call(this, collisions, groups, bmd, null, x, y);
          this.map = map;
          this.angle = angleDeg;
          this.alive = true;
          this.initCustomPhysics(true);
          this.body.addCircle(22, 0, 0, 0);
          this.body.rotation = game.math.degToRad(this.angle);
          this.body.fixedRotation = true;
          this.body.setCollisionGroup(this.collisions.enemies);
          this.body.collides(this.collisions.bullets, this.hit, this);
        }
        var p = (GateSwitch.prototype = Object.create(PhysicsActor.prototype, {
          constructor: GateSwitch
        }));
        module.exports = GateSwitch;
        p.map = null;
        p.hit = function() {
          this.map.openGate();
          if (!this.timer) {
            this.timer = game.time.events.add(
              this.gateDuration,
              this.closeGate,
              this
            );
          }
          sound.playSound(sound.LIMPET_EXPLODE);
        };
        p.closeGate = function() {
          this.map.closeGate();
          if (this.timer) {
            game.time.events.remove(this.timer);
            this.timer = null;
          }
        };
      },
      { "../utils/sound": 71, "./PhysicsActor": 11 }
    ],
    8: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var sound = require("../utils/sound");
        var gameState = require("../data/game-state");
        function HoverDrone(x, y, width, groups, collisions) {
          this.groups = groups;
          this.collisions = collisions;
          this.drawFlags(x, y, width);
          this.width = width;
          this.onTrainingComplete = new Phaser.Signal();
          this.numActive = 0;
        }
        var p = HoverDrone.prototype;
        p.onTrainingComplete = null;
        p.rotation = 0;
        p.groups = null;
        p.collisions = null;
        p.flag1 = null;
        p.flag2 = null;
        p.flag3 = null;
        p.flag4 = null;
        p.sensor = null;
        p.hasPassed = false;
        p.nextDrone = null;
        p.newContact = false;
        p.timer = null;
        p.numActive = 0;
        p.drawFlags = function(x, y, width) {
          var pos1 = new Phaser.Point(x - width / 2, y);
          var pos2 = new Phaser.Point(x, y - width / 2);
          var pos3 = new Phaser.Point(x + width / 2, y);
          var pos4 = new Phaser.Point(x, y + width / 2);
          this.flag1 = game.add.sprite(
            pos1.x,
            pos1.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          this.flag2 = game.add.sprite(
            pos2.x,
            pos2.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          this.flag3 = game.add.sprite(
            pos3.x,
            pos3.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          this.flag4 = game.add.sprite(
            pos4.x,
            pos4.y,
            "combined",
            "drone.png",
            this.groups.drones
          );
          this.flag1.anchor.setTo(0.5);
          this.flag2.anchor.setTo(0.5);
          this.flag3.anchor.setTo(0.5);
          this.flag4.anchor.setTo(0.5);
          var bmd = game.make.bitmapData(1, 1);
          bmd.rect(0, 0, 1, 1, "rgba(255, 0, 0, 0)");
          this.sensor = game.add.sprite(x, y, bmd);
          this.sensor.anchor.setTo(0.5);
          this.sensor.width = this.sensor.height = width - this.flag1.width;
          this.deactivate();
        };
        p.initPhysics = function() {
          game.physics.p2.enable(this.sensor, properties.dev.debugPhysics);
          this.sensor.body.clearShapes();
          var box = this.sensor.body.addRectangle(
            this.sensor.width,
            this.sensor.width,
            0,
            0,
            0
          );
          box.sensor = true;
          this.sensor.body.motionState = 2;
          this.sensor.body.setCollisionGroup(this.collisions.drones);
          this.sensor.body.collides([this.collisions.players]);
          this.sensor.body.onBeginContact.add(this.contactStart, this);
          this.sensor.body.onEndContact.add(this.contactLost, this);
        };
        p.deactivate = function() {
          this.active = false;
          this.newContact = false;
          this.flag1.alpha = 0.25;
          this.flag2.alpha = 0.25;
          this.flag3.alpha = 0.25;
          this.flag4.alpha = 0.25;
        };
        p.activate = function() {
          this.initPhysics();
          this.newContact = true;
          this.active = true;
          this.flag1.alpha = 1;
          this.flag2.alpha = 1;
          this.flag3.alpha = 1;
          this.flag4.alpha = 1;
        };
        p.isHovering = function() {
          this.newContact = false;
          this.flag1.tint = 16775797;
          this.flag2.tint = 16775797;
          this.flag3.tint = 16775797;
          this.flag4.tint = 16775797;
        };
        p.isNotHovering = function() {
          this.newContact = true;
          this.numActive = 0;
          this.flag1.tint = 16777215;
          this.flag2.tint = 16777215;
          this.flag3.tint = 16777215;
          this.flag4.tint = 16777215;
        };
        p.contactStart = function() {
          if (this.active && !this.hasPassed && this.newContact) {
            this.startTimer();
            this.isHovering();
          }
        };
        p.contactLost = function() {
          if (this.hasPassed) {
            return;
          }
          this.isNotHovering();
          this.resetTimer();
        };
        p.resetTimer = function() {
          game.time.events.remove(this.timer);
          this.timer = null;
        };
        p.startTimer = function() {
          this.timer = game.time.events.loop(
            Phaser.Timer.SECOND,
            this.updateTimer,
            this
          );
          this.updateTimer();
        };
        p.updateTimer = function() {
          switch (this.numActive++) {
            case 1:
              sound.playSound(sound.TRAINING_DRONE_HOVER1, 1, false);
              this.flag1.tint = 1542138;
              break;
            case 2:
              sound.playSound(sound.TRAINING_DRONE_HOVER2, 1, false);
              this.flag2.tint = 1542138;
              break;
            case 3:
              sound.playSound(sound.TRAINING_DRONE_HOVER3, 1, false);
              this.flag3.tint = 1542138;
              break;
            case 4:
              sound.playSound(sound.TRAINING_DRONE_HOVER4, 1, false);
              this.flag4.tint = 1542138;
              this.passed();
              break;
            default:
              break;
          }
        };
        p.passed = function() {
          game.time.events.remove(this.timer);
          this.hasPassed = true;
          this.onTrainingComplete.dispatch();
          this.flag1.tint = 65280;
          this.flag2.tint = 65280;
          this.flag3.tint = 65280;
          this.flag4.tint = 65280;
          gameState.score += 1;
        };
        module.exports = HoverDrone;
      },
      { "../data/game-state": 18, "../properties": 31, "../utils/sound": 71 }
    ],
    9: [
      function(require, module, exports) {
        "use strict";
        var PhysicsActor = require("./PhysicsActor");
        var gameState = require("../data/game-state");
        var particles = require("../environment/particles/manager");
        var sound = require("../utils/sound");
        var levelManager = require("../data/level-manager");
        var utils = require("../utils/index");
        var _ = require("lodash");
        function Limpet(collisions, groups, x, y, angleDeg, player) {
          this.player = player;
          PhysicsActor.call(
            this,
            collisions,
            groups,
            "combined",
            "turret_001.png",
            x,
            y
          );
          this.alive = false;
          this.angle = angleDeg;
          this.fireRate = this.getFireRate();
          if (game.device.pixelRatio > 1) {
          }
          this.animations.add(
            "normal",
            ["turret_001.png", "turret_002.png"],
            5,
            true
          );
          this.animations.add(
            "damaged",
            ["turret-damaged_001.png", "turret-damaged_002.png"],
            5,
            true
          );
          this.play("normal");
          this.initCustomPhysics(true);
          this.body.addRectangle(50, 25, 0, 0);
          this.body.rotation = game.math.degToRad(this.angle);
          this.body.fixedRotation = true;
          this.body.setCollisionGroup(this.collisions.enemies);
          this.body.collides(this.collisions.bullets, this.explode, this);
          this.enemiesDestroyed = new Phaser.Signal();
        }
        var p = (Limpet.prototype = Object.create(PhysicsActor.prototype, {
          constructor: Limpet
        }));
        module.exports = Limpet;
        p.enemiesDestroyed = null;
        p.hasPower = false;
        p.isPlayingNormal = true;
        p.start = function() {
          this.alive = true;
        };
        p.setPower = function(powerStationHealth) {
          this.hasPower = powerStationHealth >= gameState.POWER_STATION_HEALTH;
        };
        p.getFireRate = function() {
          return 1 / (500 - levelManager.currentLevel.enemyFireRate);
        };
        p.update = function() {
          if (this.alive) {
            if (!this.hasPower) {
              if (this.isPlayingNormal) {
                this.isPlayingNormal = false;
                this.play("damaged");
              }
            } else {
              if (!this.isPlayingNormal) {
                this.isPlayingNormal = true;
                this.play("normal");
              }
              if (Math.random() < this.fireRate) {
                if (this.canFire()) {
                  this.groups.bullets.fire(this.position, this.body);
                  sound.playSound(sound.LIMPET_FIRE, 0.7);
                }
              }
            }
          }
        };
        p.explode = function() {
          particles.explode(this.x, this.y);
          this.kill();
          this.body.removeFromWorld();
          this.body.destroy();
          gameState.addScore(gameState.SCORES.LIMPET);
          sound.playSound(sound.LIMPET_EXPLODE, 2);
          var enemiesKilled = _.findIndex(
            this.groups.enemies.children,
            function(limpet) {
              return limpet.exists === true;
            }
          );
          if (enemiesKilled === -1) {
            this.enemiesDestroyed.dispatch();
          }
        };
        p.canFire = function() {
          return utils.distAtoB(this.position, this.player.position) < 600;
        };
      },
      {
        "../data/game-state": 18,
        "../data/level-manager": 19,
        "../environment/particles/manager": 29,
        "../utils/index": 69,
        "../utils/sound": 71,
        "./PhysicsActor": 11,
        lodash: 1
      }
    ],
    10: [
      function(require, module, exports) {
        var properties = require("../properties");
        var gameState = require("../data/game-state");
        function Orb(groups, x, y, collisions) {
          this.groups = groups;
          this.collisions = collisions;
          this.player = null;
          this.sprite = game.add.sprite(
            x,
            y,
            "combined",
            "orb.png",
            this.groups.actors
          );
          this.glowSprite = game.make.sprite(x, y, "combined", "orb-shine.png");
          this.glowSprite.anchor.setTo(0.5);
          this.groups.actors.add(this.glowSprite);
          this.initialPosition = { x: x, y: y };
          this.init();
        }
        var p = Orb.prototype;
        p.init = function() {
          this.initPhysics();
          this.drawSensor();
          this.initSensorPhysics();
        };
        p.initPhysics = function() {
          game.physics.p2.enable(this.sprite, properties.dev.debugPhysics);
          this.body = this.sprite.body;
          this.body.setCircle(13, 0, 0);
          this.body.motionState = 2;
          this.body.setCollisionGroup(this.collisions.orb);
          this.body.collides(
            [
              this.collisions.players,
              this.collisions.terrain,
              this.collisions.fuels
            ],
            this.crash,
            this
          );
        };
        p.drawSensor = function() {
          var bmd = game.make.bitmapData(60, 60);
          bmd.ctx.beginPath();
          bmd.ctx.fillStyle = "rgba(255,0,0, 0)";
          bmd.ctx.arc(30, 30, 30, 0, Math.PI * 2, true);
          bmd.ctx.fill();
          bmd.ctx.closePath();
          this.sensor = game.add.sprite(
            this.body.x,
            this.body.y,
            bmd,
            this.groups.actors
          );
          this.sensor.width = 190;
          this.sensor.height = 190;
        };
        p.initSensorPhysics = function() {
          game.physics.p2.enable(this.sensor, properties.dev.debugPhysics);
          this.sensor.body.clearShapes();
          var box = this.sensor.body.addCircle(this.sensor.width / 2, 0, 0, 0);
          box.sensor = true;
          this.sensor.body.motionState = 2;
          this.sensor.body.setCollisionGroup(this.collisions.orb);
          this.sensor.body.collides([this.collisions.players]);
        };
        p.disposeSensor = function() {
          this.sensor.body.onBeginContact.removeAll();
          this.sensor.body.onEndContact.removeAll();
          this.sensor.body.removeFromWorld();
          this.sensor.body.destroy();
          this.sensor.destroy();
          this.sensor = null;
        };
        p.dispose = function() {
          if (this.sprite && this.sprite.body) {
            this.sprite.body.removeFromWorld();
            this.sprite.destroy();
            this.sprite.body = null;
            this.sprite = null;
          }
          if (this.sensor) {
            this.disposeSensor();
          }
          this.glowSprite.destroy();
          this.glowSprite = null;
        };
        p.bulletHit = function() {
          console.log("bulletHit");
          if (
            !this.sensor &&
            !gameState.cheats.infiniteLives &&
            gameState.cheats.fatalCollisions
          ) {
            this.player.crash();
            this.body.motionState = 1;
            this.sprite.alpha = 0;
          }
        };
        p.setPlayer = function(player) {
          this.player = player;
        };
        p.move = function() {
          console.log("move");
          this.body.motionState = 1;
          this.body.mass = 1;
          this.body.velocity = 0;
          this.body.angularVelocity = 0;
          this.body.angle = 0;
          this.body.collides(
            [this.collisions.bullets, this.collisions.enemyBullets],
            this.bulletHit,
            this
          );
          this.glowSprite.visible = false;
        };
        p.stop = function() {
          this.body.setZeroVelocity();
          this.body.setZeroDamping();
          this.body.setZeroForce();
          this.body.setZeroRotation();
          this.body.motionState = 2;
        };
        p.crash = function() {
          console.warn("this.crash", this.player);
          if (gameState.cheats.fatalCollisions) {
            if (this.player) {
              this.player.crash();
            }
            this.glowSprite.visible = false;
            this.body.motionState = 1;
          }
        };
        p.removeBulletCollisions = function() {
          this.body.removeCollisionGroup([
            this.collisions.bullets,
            this.collisions.enemyBullets
          ]);
        };
        p.respawn = function(withShip) {
          var orbSpawnPosition = new Phaser.Point();
          if (withShip) {
            orbSpawnPosition.copyFrom(this.player.position);
            orbSpawnPosition.y =
              orbSpawnPosition.y + properties.gamePlay.tractorBeamLength;
          } else {
            orbSpawnPosition.copyFrom(this.initialPosition);
          }
          this.body.reset(orbSpawnPosition.x, orbSpawnPosition.y, true, true);
          this.body.motionState = 2;
          this.sprite.alpha = 1;
          this.removeBulletCollisions();
          this.glowSprite.visible = true;
          if (!this.sensor) {
            this.drawSensor();
            this.initSensorPhysics();
          }
        };
        module.exports = Orb;
      },
      { "../data/game-state": 18, "../properties": 31 }
    ],
    11: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        function PhysicsActor(collisions, groups, atlasKey, atlasFrame, x, y) {
          this.collisions = collisions;
          this.groups = groups;
          this.initalPosition = new Phaser.Point(x || 0, y || 0);
          Phaser.Sprite.call(
            this,
            game,
            this.initalPosition.x,
            this.initalPosition.y,
            atlasKey,
            atlasFrame
          );
          this.anchor.setTo(0.5);
        }
        var p = (PhysicsActor.prototype = Object.create(
          Phaser.Sprite.prototype,
          { constructor: PhysicsActor }
        ));
        module.exports = PhysicsActor;
        p.initCustomPhysics = function(isStatic) {
          game.physics.p2.enable(this, properties.dev.debugPhysics);
          this.body.clearShapes();
          this.body.static = isStatic || false;
        };
        p.initPhysics = function(physicsDataKey, physicsDataObjKey) {
          game.physics.p2.enable(this, properties.dev.debugPhysics);
          this.body.clearShapes();
          this.body.loadPolygon(physicsDataKey, physicsDataObjKey);
          this.body.static = true;
        };
        p.start = function() {};
        p.stop = function() {
          this.body.setZeroVelocity();
          this.body.setZeroDamping();
          this.body.setZeroForce();
          this.body.setZeroRotation();
        };
      },
      { "../properties": 31 }
    ],
    12: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var utils = require("../utils");
        var ShipParticle = require("./bitmaps/ShipParticle");
        var particles = require("../environment/particles/manager");
        var levelManager = require("../data/level-manager");
        var gameState = require("../data/game-state");
        var _ = require("lodash");
        var sound = require("../utils/sound");
        var ThrustSound = sound.PLAYER_THRUST_MID;
        function Player(collisions, groups) {
          this.orbActivated = false;
          this.joypadFireButton = true;
          this.inPlay = false;
          this.spawnWithOrb = false;
          this.thrustStarted = false;
          this.collisions = collisions;
          this.groups = groups;
          this.inGameArea = false;
          this.tractorBeam = null;
          this.explodeEmitter = null;
          this.thrustEmitter = null;
          this.initialPos = new Phaser.Point();
          this.isRefuelling = false;
          this.onKilled = new Phaser.Signal();
          this.earlyInterstitial = new Phaser.Signal();
          this.respawnPos = new Phaser.Point();
          this.initialPos.setTo(
            levelManager.currentLevel.spawns[0].x,
            levelManager.currentLevel.spawns[0].y
          );
          this.respawnPos.copyFrom(this.initialPos);
          Phaser.Sprite.call(
            this,
            game,
            this.initialPos.x,
            this.initialPos.y,
            "combined",
            "player.png"
          );
          this.groups.actors.add(this);
          this.thrustAnim = game.add.sprite(
            this.x,
            this.y,
            "combined",
            "rocket_001.png",
            this.groups.actors
          );
          this.thrustAnim.anchor.setTo(0.5, -0.6);
          this.thrustAnim.animations.add(
            "rocket",
            ["rocket_002.png", "rocket_001.png"],
            4,
            true
          );
          this.thrustAnim.visible = false;
          this.refuelAnimSprite = game.add.sprite(
            this.x,
            this.y,
            "combined",
            "Fuel_PU_000.png",
            this.groups.actors
          );
          this.refuelAnimSprite.anchor.setTo(0.5);
          this.refuelAnimSprite.animations.add(
            "refuelling",
            [
              "Fuel_PU_000.png",
              "Fuel_PU_001.png",
              "Fuel_PU_002.png",
              "Fuel_PU_003.png",
              "Fuel_PU_004.png",
              "Fuel_PU_005.png",
              "Fuel_PU_006.png",
              "Fuel_PU_007.png",
              "Fuel_PU_008.png",
              "Fuel_PU_009.png",
              "Fuel_PU_010.png",
              "Fuel_PU_011.png",
              "Fuel_PU_012.png",
              "Fuel_PU_013.png",
              "Fuel_PU_014.png",
              "Fuel_PU_015.png",
              "Fuel_PU_016.png",
              "Fuel_PU_017.png",
              "Fuel_PU_018.png",
              "Fuel_PU_019.png",
              "Fuel_PU_020.png",
              "Fuel_PU_021.png",
              "Fuel_PU_022.png",
              "Fuel_PU_023.png",
              "Fuel_PU_024.png"
            ],
            30,
            true
          );
          this.refuelAnimSprite.visible = false;
          this.alpha = 0;
          this.init();
          this.thrustSfx = game.sfx.get(ThrustSound);
        }
        var p = (Player.prototype = Object.create(Phaser.Sprite.prototype, {
          constructor: Player
        }));
        module.exports = Player;
        p.setStartPosition = function(x, y) {
          this.initialPos.setTo(x, y);
        };
        p.setTractorBeam = function(tractorBeam) {
          this.tractorBeam = tractorBeam;
        };
        p.init = function() {
          this.alive = false;
          this.explodeEmitter = game.add.emitter(this.x, this.y, 20);
          this.explodeEmitter.particleClass = ShipParticle;
          this.explodeEmitter.makeParticles();
          this.explodeEmitter.gravity = 10;
        };
        p.reset = function() {
          this.setStartPosition();
          this.respawn();
        };
        p.start = function(completeCallback, context) {
          game.physics.p2.enable(this, properties.dev.debugPhysics);
          this.body.clearShapes();
          this.body.loadPolygon("playerPhysics", "player");
          this.body.setCollisionGroup(this.collisions.players);
          this.body.collides(
            [
              this.collisions.enemyBullets,
              this.collisions.terrain,
              this.collisions.orb,
              this.collisions.fuels
            ],
            this.crash,
            this
          );
          this.body.collides([this.collisions.drones]);
          this.body.motionState = 2;
          this.body.mass = 1;
          this.respawn(completeCallback, context);
        };
        p.showRefuelAnim = function() {
          this.refuelAnimSprite.visible = true;
          this.refuelAnimSprite.play("refuelling");
          sound.playSound(sound.FUEL_REFUELLING, 1, true);
        };
        p.hideRefuelAnim = function() {
          this.refuelAnimSprite.animations.stop("refuelling", true);
          this.refuelAnimSprite.visible = false;
          game.sfx.stop(sound.FUEL_REFUELLING);
        };
        p.stop = function() {
          this.alive = false;
          this.body.setZeroVelocity();
          this.body.setZeroDamping();
          this.body.setZeroForce();
          this.body.setZeroRotation();
          this.body.motionState = 2;
        };
        p.resume = function() {
          this.alive = true;
          this.body.motionState = 1;
        };
        p.levelExit = function() {
          this.inPlay = false;
          this.stopThrustFx();
        };
        p.tweenOutAndRemove = function(removeWithOrb) {
          TweenMax.to(this, 0.4, { alpha: 0, ease: Quad.easeOut });
          if (removeWithOrb) {
            TweenMax.to(this.tractorBeam.orb.sprite, 0.4, {
              alpha: 0,
              ease: Quad.easeOut
            });
          }
        };
        p.spawn = function() {
          this.inGameArea = true;
          this.body.motionState = 1;
          this.alpha = 0;
          this.visible = true;
          this.alive = true;
          this.inPlay = true;
          TweenMax.to(this, 0.3, { alpha: 1, ease: Quad.easeOut });
        };
        p.respawn = function(completeCallback, thisArg, removeShip) {
          console.log(
            "Player :: respawn :",
            removeShip,
            gameState.cheats.infiniteLives
          );
          this.body.reset(this.respawnPos.x, this.respawnPos.y);
          this.body.setZeroVelocity();
          this.body.setZeroDamping();
          this.body.setZeroForce();
          this.body.setZeroRotation();
          this.body.motionState = 2;
          this.body.angle = 0;
          this.alpha = 0;
          if (removeShip === true && !gameState.cheats.infiniteLives) {
            gameState.lives--;
          }
          sound.playSound(sound.PLAYER_TELEPORT_IN);
          particles.playerTeleport(
            this.respawnPos.x,
            this.respawnPos.y,
            function() {
              if (completeCallback) {
                completeCallback.call(thisArg);
              }
              this.spawn();
              if (this.spawnWithOrb) {
                this.tractorBeam.respawn(true);
              } else {
                if (this.tractorBeam) {
                  this.tractorBeam.respawn(false);
                }
              }
            }.bind(this)
          );
        };
        p.update = function() {
          if (this.body) {
            this.refuelAnimSprite.x = this.body.x;
            this.refuelAnimSprite.y = this.body.y;
            this.exhaustUpdate();
          }
        };
        p.checkPlayerControl = function(cursors, buttonAPressed) {
          if (!this.alive || !this.inGameArea) {
            return;
          }
          this.checkRotate(game.controls.stick, cursors);
          this.checkThrust(buttonAPressed, cursors);
        };
        p.checkPlayerControlJoypad = function() {
          if (!this.alive || !this.inGameArea) {
            return;
          }
          this.checkJoypadFire();
          this.checkThrust(game.externalJoypad.thrustButton.isDown);
          this.checkRotate(null, game.externalJoypad);
        };
        p.checkJoypadFire = function() {
          game.input.gamepad.pad1.onUpCallback = function(buttonCode) {
            if (buttonCode === Phaser.Gamepad.BUTTON_1) {
              this.joypadFireButton = true;
            }
          }.bind(this);
          game.input.gamepad.pad1.onDownCallback = function(buttonCode) {
            if (
              buttonCode === Phaser.Gamepad.BUTTON_1 &&
              this.joypadFireButton
            ) {
              this.joypadFireButton = false;
              this.fire();
            }
          }.bind(this);
        };
        p.checkRotate = function(stick, cursors) {
          if (
            (stick && stick.isDown && stick.direction === Phaser.LEFT) ||
            (cursors && cursors.left.isDown)
          ) {
            this.rotate(-90);
          } else if (
            (stick && stick.isDown && stick.direction === Phaser.RIGHT) ||
            (cursors && cursors.right.isDown)
          ) {
            this.rotate(90);
          } else if (!game.e2e.controlOverride) {
            this.body.setZeroRotation();
          }
        };
        p.checkThrust = function(buttonAPressed, cursors) {
          if ((cursors && cursors.up.isDown) || buttonAPressed) {
            if (gameState.fuel >= 0) {
              if (!this.thrustStarted) {
                this.thrustStarted = true;
                this.thrustAnim.visible = true;
                this.thrustAnim.play("rocket");
                sound.playSound(ThrustSound, 0.6, true);
              }
              this.body.thrust(400);
              if (!this.isRefuelling && !gameState.cheats.infiniteFuel) {
                gameState.fuel--;
              }
            }
          } else {
            this.stopThrustFx();
          }
        };
        p.stopThrustFx = function() {
          this.thrustAnim.visible = false;
          this.thrustAnim.animations.stop("rocket", true);
          this.thrustStarted = false;
          game.sfx.stop(ThrustSound);
        };
        p.connectAttempt = function() {
          var distance = utils.distAtoB(
            this.position,
            this.tractorBeam.orb.sprite.position
          );
          if (distance < this.tractorBeam.length && this.alive) {
            this.tractorBeam.drawBeam(this.position);
          } else if (
            distance >= this.tractorBeam.length &&
            distance < this.tractorBeam.length + this.tractorBeam.variance
          ) {
            if (this.tractorBeam.isLocked && this.alive) {
              this.tractorBeam.grab(this);
            }
          } else {
          }
        };
        p.fire = function() {
          if (this.inPlay) {
            this.groups.playerBullets.fire(this);
            sound.playSound(sound.PLAYER_FIRE);
          }
        };
        p.crash = function() {
          if (
            !properties.fatalCollisions ||
            !gameState.cheats.fatalCollisions
          ) {
            return;
          }
          this.explosion();
          this.death();
        };
        p.rotate = function(val) {
          if (val < 0) {
            this.body.rotateLeft(Math.abs(val));
          } else {
            this.body.rotateRight(val);
          }
        };
        p.explosion = function(force) {
          if (this.alive || force === true) {
            var hasOrb = false;
            this.stopThrustFx();
            if (this.tractorBeam) {
              hasOrb = this.tractorBeam.isLocked;
            }
            this.explodeEmitter.x = this.position.x;
            this.explodeEmitter.y = this.position.y;
            this.explodeEmitter.start(true, 1500, null, 40);
            sound.playSound(sound.PLAYER_EXPLOSION, 3);
            if (hasOrb) {
              this.tractorBeam.breakLink();
            }
            this.visible = false;
            this.stop();
            this.setRespawnPosition(this.position, hasOrb);
          }
        };
        p.setRespawnPosition = function(position, hasOrb) {
          var spawns = levelManager.currentLevel.spawns;
          var distances = [];
          var distance;
          var enemiesKilled = _.findIndex(
            this.groups.enemies.children,
            function(limpet) {
              return limpet.exists === true;
            }
          );
          if (enemiesKilled === -1) {
            enemiesKilled = this.groups.enemies.children.length;
          }
          console.warn(
            "enemies killed %d group =",
            enemiesKilled,
            this.groups.enemies
          );
          _.each(spawns, function(spawnPosition) {
            distance = utils.distAtoB(position, spawnPosition);
            if (enemiesKilled >= spawnPosition.enemies) {
              distances.push(distance);
            }
          });
          if (distances.length > 0) {
            var minDistance = _.min(distances);
            this.respawnPos = spawns[distances.indexOf(minDistance)];
          } else {
            this.respawnPos = spawns[0];
          }
          if (this.respawnPos.orb && hasOrb) {
            this.spawnWithOrb = true;
          }
        };
        p.doRefuel = function() {
          this.isRefuelling = true;
          this.showRefuelAnim();
          this.frameName = "player-refueling.png";
        };
        p.clearRefuel = function() {
          this.isRefuelling = false;
          this.hideRefuelAnim();
          this.frameName = "player.png";
        };
        p.exhaustUpdate = function() {
          this.thrustAnim.x = this.body.x;
          this.thrustAnim.y = this.body.y;
          this.thrustAnim.rotation = this.rotation;
        };
        p.death = function() {
          if (this.inPlay) {
            this.onKilled.dispatch();
            this.inPlay = false;
            this.alive = false;
            game.time.events.add(2e3, _.bind(this.checkRespawn, this));
          }
        };
        p.checkRespawn = function(callback, context) {
          if (gameState.lives - 1 < 0 || gameState.fuel <= 0) {
            console.log("game over");
            gameState.isGameOver = true;
          } else {
            if (!gameState.bonuses.planetBuster) {
              this.respawn(callback, context, true);
            } else {
              if (!gameState.cheats.infiniteLives) {
                gameState.lives--;
              }
              this.earlyInterstitial.dispatch();
            }
          }
        };
      },
      {
        "../data/game-state": 18,
        "../data/level-manager": 19,
        "../environment/particles/manager": 29,
        "../properties": 31,
        "../utils": 69,
        "../utils/sound": 71,
        "./bitmaps/ShipParticle": 15,
        lodash: 1
      }
    ],
    13: [
      function(require, module, exports) {
        "use strict";
        var PhysicsActor = require("./PhysicsActor");
        var gameState = require("../data/game-state");
        var particleManager = require("../environment/particles/manager");
        var sound = require("../utils/sound");
        function PowerStation(
          collisions,
          groups,
          imageCacheKey,
          imageFrame,
          x,
          y
        ) {
          PhysicsActor.call(
            this,
            collisions,
            groups,
            imageCacheKey,
            imageFrame,
            x,
            y
          );
          this.health = gameState.POWER_STATION_HEALTH;
          this.init();
        }
        var p = (PowerStation.prototype = Object.create(
          PhysicsActor.prototype,
          { constructor: PowerStation }
        ));
        module.exports = PowerStation;
        p.particles = null;
        p.destructionSequenceActivated = new Phaser.Signal();
        p.init = function() {
          this.animations.add(
            "normal",
            ["power-station_001.png", "power-station_002.png"],
            1,
            true
          );
          this.animations.add(
            "damaged",
            ["power-station-damaged.png"],
            1,
            true
          );
          this.play("normal");
          this.startParticles();
        };
        p.kill = function() {
          Phaser.Sprite.prototype.kill.call(this);
          this.destructionSequenceActivated.dispatch();
          this.explode();
        };
        p.initCollisions = function() {
          this.body.collides(this.collisions.bullets, this.hit, this);
        };
        p.update = function() {
          if (this.alive && this.health < gameState.POWER_STATION_HEALTH) {
            if (this.isNormal) {
              this.isNormal = false;
              this.play("damaged");
              this.stopParticles();
            }
            this.health += 0.6;
          } else if (this.health >= gameState.POWER_STATION_HEALTH) {
            if (!this.isNormal) {
              this.isNormal = true;
              this.play("normal");
              this.startParticles();
            }
          }
        };
        p.hit = function() {
          this.damage(75);
          sound.playSound(sound.POWER_STATION_HIT);
        };
        p.stopParticles = function() {
          particleManager.stopPower();
        };
        p.startParticles = function() {
          particleManager.emitPower(this.x - this.width / 2.5, this.y);
        };
        p.explode = function() {
          sound.playSound(sound.POWER_STATION_EXPLODE1);
          particleManager.explode(
            this.x - this.width / 2,
            this.y + this.height / 2
          );
          game.time.events.add(
            Math.random() * 500,
            function() {
              sound.playSound(sound.POWER_STATION_EXPLODE2);
              particleManager.explode(this.x, this.y + this.height / 2);
            },
            this
          );
          game.time.events.add(
            Math.random() * 500,
            function() {
              sound.playSound(sound.POWER_STATION_EXPLODE2);
              particleManager.explode(
                this.x + this.width / 2,
                this.y + this.height / 2
              );
            },
            this
          );
        };
      },
      {
        "../data/game-state": 18,
        "../environment/particles/manager": 29,
        "../utils/sound": 71,
        "./PhysicsActor": 11
      }
    ],
    14: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var sound = require("../utils/sound");
        function TractorBeam(orb, player, groups) {
          this.orb = orb;
          this.player = player;
          this.groups = groups;
          this.isLocked = false;
          this.isLocking = false;
          this.hasGrabbed = false;
          this.length = properties.gamePlay.tractorBeamLength;
          this.variance = properties.gamePlay.tractorBeamVariation;
          this.lockingDuration = properties.gamePlay.lockingDuration;
          this.constraint = null;
          this.graphics = null;
          this.timer = null;
          this.init();
        }
        var p = TractorBeam.prototype;
        p.init = function() {
          this.graphics = game.make.graphics();
          this.groups.actors.add(this.graphics);
          this.timer = game.time.create(false);
        };
        p.contactStart = function() {
          if (!this.player.orbActivated) {
            return;
          }
          this.startLocking();
        };
        p.contactLost = function() {
          var player = this.player;
          this.isLocking = false;
          if (this.isLocked && player.alive) {
            this.grab(this);
          }
          if (!this.hasGrabbed) {
            this.breakLink();
          }
        };
        p.update = function() {
          if (this.player && this.player.body) {
            if (this.isLocking || this.hasGrabbed) {
              this.drawBeam();
            }
          }
        };
        p.startLocking = function() {
          if (!this.isLocking) {
            this.isLocking = true;
            this.timer.add(this.lockingDuration, this.lock, this);
            this.timer.start();
            sound.playSound(sound.TRACTOR_BEAM_CONNECTING);
          }
        };
        p.drawBeam = function() {
          this.graphics.clear();
          var colour = this.hasGrabbed ? 5242879 : 15685270;
          var alpha = this.hasGrabbed ? 0.6 : 0.4;
          this.graphics.lineStyle(3, colour, alpha);
          this.graphics.moveTo(this.player.body.x, this.player.body.y);
          this.graphics.lineTo(
            this.orb.sprite.position.x,
            this.orb.sprite.position.y
          );
        };
        p.clearPhysics = function() {
          console.log(
            "TractorBeam :: clear orb sensor Physics, and remove timers"
          );
          this.timer.stop();
          game.time.events.remove(this.timer);
          if (this.orb.body) {
            this.orb.disposeSensor();
          }
        };
        p.unlock = function() {
          this.isLocked = false;
        };
        p.lock = function() {
          this.hasGrabbed = true;
          this.isLocked = true;
        };
        p.lockingRelease = function() {
          if (!this.isLocked) {
            this.isLocking = false;
            this.hasGrabbed = false;
            this.graphics.clear();
            sound.playSound(sound.TRACTOR_BEAM_RELEASE);
            this.timer.stop(true);
          }
        };
        p.grab = function() {
          var player = this.player;
          var maxForce = 2e5;
          var diffX = player.position.x - this.orb.sprite.position.x;
          var diffY = player.position.y - this.orb.sprite.position.y;
          this.constraint = game.physics.p2.createRevoluteConstraint(
            player,
            [0, 0],
            this.orb.sprite,
            [diffX, diffY],
            maxForce
          );
          this.orb.move();
          sound.playSound(sound.TRACTOR_BEAM_GRAB);
          this.clearPhysics();
        };
        p.breakLink = function() {
          this.unlock();
          sound.playSound(sound.TRACTOR_BEAM_BREAK);
          this.lockingRelease();
          game.physics.p2.removeConstraint(this.constraint);
        };
        p.dispose = function() {
          console.log("TractorBeam :: dispose (graphics destroyed)");
          this.graphics.destroy();
        };
        p.respawn = function(withShip) {
          console.log("TractorBeam :: respawn", withShip);
          this.orb.respawn(withShip);
          this.initSignals();
        };
        p.initSignals = function() {
          console.log(
            "TractorBeam:: initSignals",
            this.orb.sensor.body.onBeginContact.getNumListeners()
          );
          if (!this.orb.sensor.body.onBeginContact.getNumListeners()) {
            this.orb.sensor.body.onBeginContact.add(this.contactStart, this);
            this.orb.sensor.body.onEndContact.add(this.contactLost, this);
          }
        };
        module.exports = TractorBeam;
      },
      { "../properties": 31, "../utils/sound": 71 }
    ],
    15: [
      function(require, module, exports) {
        function ShipParticle(game, x, y) {
          var bmd = game.add.bitmapData(3, 3);
          bmd.context.fillStyle = "#ffffff";
          bmd.context.fillRect(0, 0, 3, 3);
          game.cache.addBitmapData("shipParticle", bmd);
          Phaser.Particle.call(
            this,
            game,
            x,
            y,
            game.cache.getBitmapData("shipParticle")
          );
        }
        var p = (ShipParticle.prototype = Object.create(
          Phaser.Particle.prototype
        ));
        module.exports = p.constructor = ShipParticle;
      },
      {}
    ],
    16: [
      function(require, module, exports) {
        var Drone = require("./Drone");
        var HoverDrone = require("./HoverDrone");
        var dialog = require("../ui/mission-dialog");
        var _ = require("lodash");
        module.exports = {
          followOrb: false,
          player: null,
          standardDroneWidth: 75,
          standardDroneData: [
            { x: 1600, y: 1400, rotation: 0 },
            { x: 1600, y: 1200, rotation: 0 },
            { x: 1600, y: 1e3, rotation: 0 },
            { x: 1500, y: 800, rotation: 0 },
            { x: 1700, y: 600, rotation: 0 },
            { x: 1600, y: 400, rotation: 0 },
            { x: 1400, y: 300, rotation: Math.PI / 4 },
            { x: 1200, y: 300, rotation: Math.PI / 2 },
            { x: 1e3, y: 300, rotation: Math.PI / 2 },
            { x: 800, y: 300, rotation: Math.PI / 2 },
            { x: 600, y: 300, rotation: 3 * Math.PI / 4 },
            { x: 500, y: 400, rotation: 3 * Math.PI / 4 },
            { x: 400, y: 500, rotation: 3 * Math.PI / 4 },
            { x: 300, y: 700, rotation: 0 },
            { x: 400, y: 900, rotation: 0 },
            { x: 300, y: 1100, rotation: 0 },
            { x: 200, y: 1300, rotation: 0 },
            { x: 300, y: 1600, rotation: Math.PI / 4 },
            { x: 300, y: 1800, rotation: Math.PI / 4 },
            { x: 800, y: 1900, rotation: Math.PI / 2 },
            { x: 1e3, y: 1900, rotation: Math.PI / 2 },
            { x: 1200, y: 1900, rotation: Math.PI / 2 },
            { x: 1300, y: 1800, rotation: 7 * Math.PI / 4 },
            { x: 1500, y: 1700, rotation: 7 * Math.PI / 4 },
            { x: 1600, y: 1550, rotation: 0 }
          ],
          standardDrones: [],
          hoverDrones: [],
          hoverDroneWidth: 125,
          hoverDroneData: [
            { x: 2300, y: 1550 },
            { x: 2500, y: 1e3 },
            { x: 2400, y: 1300 },
            { x: 2600, y: 1500 },
            { x: 2250, y: 800 }
          ],
          trainingStageIndex: 0,
          init: function(player, groups, collisions) {
            this.trainingStageIndex = 0;
            this.standardDrones = [];
            this.player = player;
            this.groups = groups;
            this.collisions = collisions;
          },
          newHoverDrones: function() {
            _.each(
              this.hoverDroneData,
              function(data) {
                this.hoverDrones.push(
                  new HoverDrone(
                    data.x,
                    data.y,
                    this.hoverDroneWidth,
                    this.groups,
                    this.collisions
                  )
                );
              }.bind(this)
            );
            _.each(
              this.hoverDrones,
              function(drone) {
                drone.onTrainingComplete.add(this.hoverDroneActivated, this);
              }.bind(this)
            );
          },
          newDrones: function() {
            _.each(
              this.standardDroneData,
              function(data) {
                this.standardDrones.push(
                  new Drone(
                    data.x,
                    data.y,
                    this.standardDroneWidth,
                    data.rotation,
                    this.groups,
                    this.collisions
                  )
                );
              }.bind(this)
            );
            _.each(
              this.standardDrones,
              function(drone, i) {
                if (i < this.standardDrones.length - 1) {
                  drone.nextDrone = this.standardDrones[i + 1];
                } else {
                  drone.lastDrone();
                  drone.onTrainingComplete.add(this.nextTrainingStage, this);
                }
              }.bind(this)
            );
            this.standardDrones[0].activate();
          },
          hoverDroneActivated: function() {
            var passedDrones = _.map(this.hoverDrones, function(drone) {
              return drone.hasPassed;
            });
            if (passedDrones.indexOf(false) < 0) {
              this.gotoOrbStage();
            }
          },
          gotoOrbStage: function() {
            this.player.stop();
            this.nextTrainingStage();
          },
          nextTrainingStage: function() {
            this.player.stop();
            if (this.trainingStageIndex === 1) {
              this.followOrb = true;
            }
            dialog.render(
              function() {
                this.trainingStageIndex++;
                this.doStageSpecifics();
                this.player.resume();
                this.followOrb = false;
              }.bind(this),
              this
            );
          },
          activateTimedRun: function(stopwatch) {
            this.stopwatch = stopwatch;
          },
          trainingComplete: function() {
            this.stopwatch.stop();
          },
          doStageSpecifics: function() {
            if (this.trainingStageIndex === 1) {
              _.each(
                this.hoverDrones,
                function(hoverDrone) {
                  hoverDrone.activate();
                }.bind(this)
              );
            } else if (this.trainingStageIndex === 2) {
              this.player.orbActivated = true;
            }
          }
        };
      },
      { "../ui/mission-dialog": 44, "./Drone": 5, "./HoverDrone": 8, lodash: 1 }
    ],
    17: [
      function(require, module, exports) {
        module.exports = {
          getLevelsCompleteText: function() {
            return this.levelsComplete[0];
          },
          levelsComplete: [
            "You have completed all the Thrust Beta Missions\n" +
              "Thrust missions based on the SPECTRUM version level layouts" +
              "\n\n" +
              "Thank you for playing Thrust 30\n" +
              "Coming Soon on IOS & Android \n" +
              "CREDITS: \nMusic: Matt Gray & Martin Keary \n" +
              "PROGRAMMING: ANDY HAYES\n" +
              "SFX MATT GRAY\n" +
              "GRAPHICS: Martin Keary & Andy Hayes\n\n" +
              "You have successfully completed all Classic Thrust Missions\n" +
              "All these levels have been totally redesigned for Thrust 30\n" +
              "based on the original SPECTRUM game's levels\n" +
              "More Levels Will be Available Spring 2017\n" +
              "CREDITS: \nMusic: Matt Gray & Martin Keary \n" +
              "PROGRAMMING: ANDY HAYES\n" +
              "SFX MATT GRAY\n" +
              "GRAPHICS: Martin Keary & Andy Hayes\n\n" +
              "Thank you for playing Thrust 30"
          ],
          training: [
            "Flight training stage 1\n" +
              "Use left, right and thrust to pilot your ship between the highlighted drones.\n" +
              "Try to keep your ship pointed upwards as much as possible, and use your thrust to counter " +
              "the planet's gravity.\n" +
              "Press Fire to begin.",
            "Flight training stage 2\n" +
              "Mastering Thrust requires precise control of your ship despite the gravitational forces acting on it.\n" +
              "Fly to the right to find the drones arranged in diamond formation.  " +
              "Hover between each set of drones for 4 seconds to activate it, then move on to the next.\n" +
              "Press Fire to continue",
            "Flight training stage 3: Recovering The Orb\n" +
              "To complete each mission, you must recover an orb positioned somewhere on or beneath the planet's surface.  " +
              "You can attach the orb by hovering next to it for 1 second.  " +
              "Then pilot your ship high enough from the planet's surface so your warp drive can engage\n" +
              "Press Fire to continue.",
            "Flight Training Complete!\n" +
              "Congratulations, you successfully completed flight training.\n" +
              "You're now ready to begin real life Thrust missions.\n\n" +
              "Press Fire to return to the Menu"
          ]
        };
      },
      {}
    ],
    18: [
      function(require, module, exports) {
        var _ = require("lodash");
        var levelManager = require("./level-manager");
        var utils = require("../utils");
        var options = require("./options-model");
        var sound = require("../utils/sound");
        module.exports = {
          numExtraLives: 0,
          score: 0,
          fuel: 0,
          lives: 0,
          isGameOver: false,
          POWER_STATION_HEALTH: 1e3,
          ENEMY_BULLET_DURATION: 2500,
          PLAYER_BULLET_DURATION: 3e3,
          FUEL_AMOUNT: 600,
          gameScale: 1,
          cheats: {
            enabled: true,
            infiniteFuel: false,
            infiniteLives: false,
            fatalCollisions: true,
            startDebugLevel: false
          },
          trainingMode: false,
          gameComplete: false,
          PLAY_STATES: {
            MENU: "MENU",
            PLAY: "PLAY",
            HIGH_SCORES: "HIGH_SCORES",
            INTERSTITIAL: "INTERSTITIAL",
            GAME_OVER: "GAME_OVER",
            OPTIONS: "OPTIONS",
            COMPLETE: "GAME_COMPLETE",
            GAME_COMPLETE: "GAME_COMPLETE"
          },
          currentState: null,
          highScoreTable: [
            { name: "Andy", score: 6e4 },
            { name: "Joe", score: 5e4 },
            { name: "Malcolm", score: 3e4 },
            { name: "Rodney", score: 2e4 },
            { name: "Simon", score: 1e4 },
            { name: "Christopher", score: 5e3 },
            { name: "Bilbo", score: 2500 },
            { name: "Baggins", score: 200 }
          ],
          shouldEnterHighScore: false,
          shouldUpdateBestTime: false,
          playTime: "0",
          SCORES: {
            FUEL_COLLECTED: 300,
            FUEL_DESTROYED: 150,
            LIMPET: 750,
            PLANET_BUSTER: 2e3,
            ORB_RECOVERED: 2e3,
            LIMPETS_DESTROYED: 500,
            DRONES_PASSED: 29,
            TIMED_RUN: 0,
            XTRA_LIFE: 1e4,
            LEVEL_MULTIPLIER: 400
          },
          counter: 0,
          bestTimeMs: 0,
          stopwatchCacheTxt: "",
          planetBusterMode: false,
          bonuses: { planetBuster: false, orbRecovered: false },
          getScoreIndex: function() {
            return _.findIndex(
              this.highScoreTable,
              function(data) {
                return this.score > data.score;
              }.bind(this)
            );
          },
          insertNewHighScore: function(scoreIndex) {
            this.highScoreTable.splice(scoreIndex, 0, {
              dirty: true,
              name: "",
              score: this.score
            });
            this.highScoreTable.pop();
          },
          newScoreEntered: function(name) {
            _.each(this.highScoreTable, function(data) {
              if (data.dirty) {
                data.name = name;
                data.dirty = false;
              }
            });
            this.setHighscoresStorage();
          },
          getScoreByValueId: function(valueId) {
            console.log(
              "gameState :: getScoreByValueId :",
              valueId,
              this.SCORES[valueId]
            );
            if (valueId === "TIMED_RUN") {
              return this.playTime;
            } else if (valueId === "ORB_RECOVERED") {
              return (
                this.SCORES[valueId] +
                levelManager.levelIndex * this.SCORES.LEVEL_MULTIPLIER
              );
            } else {
              return this.SCORES[valueId];
            }
          },
          init: function() {
            this.gameScale = game.width / 1024;
            this.currentState = this.PLAY_STATES.MENU;
            this.highscoreStorage();
            this.getBestTimeStorage();
            this.newPlayer();
            this.newGame();
            this.levelsCompleted = new Phaser.Signal();
          },
          setBestTimeStorage: function() {
            this.bestTimeMs = this.counter;
            this.bestTimeStr = this.stopwatchCacheTxt;
            if (utils.features.isLocalStorageAvailable) {
              window.localStorage.setItem(
                "bestTime",
                JSON.stringify({
                  bestTimeMs: this.bestTimeMs,
                  bestTimeStr: this.stopwatchCacheTxt
                })
              );
            }
          },
          getBestTimeStorage: function() {
            if (utils.features.isLocalStorageAvailable) {
              if (window.localStorage.getItem("bestTime")) {
                var bestTimesData = JSON.parse(
                  window.localStorage.getItem("bestTime")
                );
                this.bestTimeMs = bestTimesData.bestTimeMs;
                this.bestTimeStr = bestTimesData.bestTimeStr;
              }
            }
          },
          setHighscoresStorage: function() {
            if (utils.features.isLocalStorageAvailable) {
              window.localStorage.setItem(
                "highscores",
                JSON.stringify(this.highScoreTable)
              );
            }
          },
          highscoreStorage: function() {
            if (utils.features.isLocalStorageAvailable) {
              if (window.localStorage.getItem("highscores")) {
                this.highScoreTable = JSON.parse(
                  window.localStorage.getItem("highscores")
                );
              }
            }
          },
          resetBonuses: function() {
            console.log(
              "game-state :: levelStart : currentLevel",
              levelManager.currentLevel
            );
            this.gameComplete = false;
            this.bonuses.planetBuster = false;
            this.bonuses.orbRecovered = false;
          },
          newPlayer: function() {
            this.numExtraLives = 0;
            this.score = 0;
            this.fuel = 5e3;
            this.lives = 4;
          },
          newGame: function() {
            this.resetTimes();
            this.resetBonuses();
            levelManager.newGame();
          },
          startTraining: function() {
            this.resetTimes();
            this.resetBonuses();
            levelManager.startTraining();
          },
          doHighScoreCheck: function(gameComplete) {
            if (gameComplete) {
              this.gameComplete = true;
            }
            this.shouldEnterHighScore = this.getScoreIndex() >= 0;
          },
          doBestTimeCheck: function() {
            if (options.gameModes.speedRun.enabled) {
              this.shouldUpdateBestTime = this.isBestTime();
            }
          },
          isPlanetDestroyed: function() {
            return this.bonuses.planetBuster;
          },
          nextLevelCheck: function() {
            if (levelManager.startDebugLevel) {
              levelManager.nextLevel();
              return;
            }
            if (this.trainingMode) {
              this.startTraining();
              return;
            }
            var isPlanetDestroyed = this.isPlanetDestroyed();
            var objectiveComplete = false;
            if (this.planetBusterMode && isPlanetDestroyed) {
              objectiveComplete = true;
            } else {
              if (this.bonuses.orbRecovered || isPlanetDestroyed) {
                objectiveComplete = true;
              }
            }
            if (objectiveComplete && !this.isGameOver) {
              if (
                levelManager.levels.length - 1 === levelManager.levelIndex &&
                !options.gameModes.endlessMode.enabled
              ) {
                this.levelsCompleted.dispatch();
              } else {
                this.resetBonuses();
                levelManager.nextLevel();
              }
            }
          },
          isBestTime: function() {
            if (this.counter > this.bestTimeMs) {
              this.setBestTimeStorage();
              return true;
            }
            return false;
          },
          cacheTime: function(ms, text) {
            this.counter = ms;
            this.stopwatchCacheTxt = text;
          },
          getCachedTime: function() {
            return this.counter;
          },
          getCachedTimeStr: function() {
            return this.stopwatchCacheTxt;
          },
          resetTimes: function() {
            this.counter = 0;
            this.stopwatchCacheTxt = "";
          },
          setScore: function(value) {
            this.score = value;
            this.check1Up();
          },
          addScore: function(value) {
            this.score += value;
            this.check1Up();
          },
          check1Up: function() {
            if (
              this.score / (this.SCORES.XTRA_LIFE * (this.numExtraLives + 1)) >=
              1
            ) {
              sound.playSound(sound.PLAYER_1UP, 3);
              this.lives += 1;
              this.numExtraLives++;
            }
          }
        };
      },
      {
        "../utils": 69,
        "../utils/sound": 71,
        "./level-manager": 19,
        "./options-model": 20,
        lodash: 1
      }
    ],
    19: [
      function(require, module, exports) {
        var properties = require("../properties");
        var options = require("./options-model");
        module.exports = {
          levels: null,
          levelIndex: null,
          currentLevel: null,
          endlessModeIndex: 0,
          endlessCycle: 0,
          endless: [],
          endlessData: { rate: 1, blink: false, flip: false },
          debugStartLevelIndex: 0,
          startDebugLevel: false,
          allLevels: [],
          init: function(levels) {
            this.endless = levels.endless;
            this.allLevels = levels.data.slice();
            this.levels = levels.data;
            if (options.gameModes.allLevels) {
              this.levels = this.allLevels.slice();
            } else {
              this.levels.splice(3, 3);
            }
            this.currentLevel = this.levels[this.levelIndex];
            this.updateEndlessData();
          },
          onLevelsPurchased: function() {
            this.levels = this.allLevels.slice();
            options.unlockGameModes();
          },
          setNewLevel: function(levelIndex) {
            if (levelIndex !== this.levelIndex) {
              this.startDebugLevel = true;
              this.debugStartLevelIndex = levelIndex;
              return true;
            }
            return false;
          },
          resetToLevel1: function() {
            this.levelIndex = 0;
            this.currentLevel = this.levels[this.levelIndex];
          },
          nextLevel: function() {
            if (this.startDebugLevel) {
              this.startDebugLevel = false;
              this.levelIndex = this.debugStartLevelIndex;
              this.currentLevel = this.levels[this.levelIndex];
              return this.currentLevel;
            }
            if (this.levels.length - 1 === this.levelIndex) {
              this.checkEndlessCycle();
              this.levelIndex = 0;
            } else {
              this.levelIndex++;
            }
            this.currentLevel = this.levels[this.levelIndex];
            return this.currentLevel;
          },
          checkEndlessCycle: function() {
            console.log(
              "checkEndlessCycle this.endless.length, this.endlessModeIndex",
              this.endless.length,
              this.endlessModeIndex
            );
            if (this.endless.length - 1 === this.endlessModeIndex) {
              this.endlessModeIndex = 0;
              this.endlessCycle++;
            } else {
              this.endlessModeIndex++;
            }
            console.log("checkEndlessCycle index:", this.endlessCycle);
            this.updateEndlessData();
          },
          updateEndlessData: function() {
            var endlessObj = this.endless[this.endlessModeIndex];
            this.endlessData.flip = endlessObj.flip;
            this.endlessData.rate = endlessObj.rate;
            this.endlessData.blink = endlessObj.blink;
          },
          newGame: function() {
            this.levelIndex = properties.levels.startLevel - 1;
            this.currentLevel = this.levels[this.levelIndex];
            this.endlessModeIndex = 0;
            this.endlessCycle = 0;
          },
          startTraining: function() {
            this.currentLevel = properties.levels.training;
          }
        };
      },
      { "../properties": 31, "./options-model": 20 }
    ],
    20: [
      function(require, module, exports) {
        var _ = require("lodash");
        module.exports = {
          init: function() {
            this.initFps();
            this.initDisplay();
            this.initEvents();
          },
          setLevels: function(value) {
            this.gameModes.levels.dirty =
              value !== this.gameModes.levels.current;
            this.gameModes.levels.selected = value;
          },
          getLevelsJsonUrl: function() {
            var jsonUrl;
            if (this.gameModes.levels.dirty) {
              this.gameModes.levels.current = this.gameModes.levels.selected;
            }
            switch (this.gameModes.levels.selected) {
              case "classic":
                jsonUrl = "assets/levels/classic.json";
                break;
              case "2016":
                jsonUrl = "assets/levels/2016.json";
                break;
              default:
                jsonUrl = "assets/levels/classic.json";
                console.warn(
                  "no json url found for selected levels - using default classic.json"
                );
                break;
            }
            console.log("getLevelsJsonUrl :: jsonUrl=", jsonUrl);
            return jsonUrl;
          },
          lockGameModes: function() {
            this.gameModes.speedRun.unlocked = false;
            this.gameModes.endlessMode.unlocked = false;
          },
          unlockGameModes: function() {
            this.gameModes.speedRun.unlocked = true;
            this.gameModes.endlessMode.unlocked = true;
          },
          versionSuffix: "",
          gameModes: {
            allLevels: false,
            sandbox: { enabled: false },
            levels: { dirty: false, current: "classic", selected: "classic" },
            speedRun: { unlocked: true, enabled: false },
            endlessMode: { unlocked: true, enabled: false },
            gravity: {
              unlocked: false,
              enabled: false,
              options: { light: 100, heavy: 150 }
            }
          },
          sound: { soundFx: true, music: true },
          display: {
            fps: 60,
            fullscreen: true,
            fx: { background: true, particles: false }
          },
          controls: {
            virtualJoypad: false,
            keyboard: true,
            externalGamepad: false
          },
          general: {},
          initFps: function() {
            if (this.display.fps === 30) {
              game.device.isMobile = true;
              game.time.desiredFps = this.display.fps = 30;
            } else {
              game.time.desiredFps = this.display.fps = 60;
              game.device.isMobile = false;
            }
          },
          initDisplay: function() {
            if (
              game.device.iOS ||
              game.device.android ||
              game.device.windowsPhone
            ) {
              this.display.fx.particles = false;
            }
          },
          getFilterByName: function(name) {
            return _.find(this.display.filters, function(val) {
              return !_.isUndefined(val[name]);
            });
          },
          initEvents: function() {
            this.loadNewLevels = new Phaser.Signal();
            this.fxParticlesOn = new Phaser.Signal();
            this.fxParticlesOff = new Phaser.Signal();
            this.fxBackgroundOn = new Phaser.Signal();
            this.fxBackgroundOff = new Phaser.Signal();
          },
          dispose: function() {
            this.loadNewLevels.removeAll();
            this.loadNewLevels = null;
            this.fxParticlesOn.removeAll();
            this.fxParticlesOn = null;
            this.fxParticlesOff.removeAll();
            this.fxParticlesOff = null;
            this.fxBackgroundOn.removeAll();
            this.fxBackgroundOn = null;
            this.fxBackgroundOff.removeAll();
            this.fxBackgroundOff = null;
          }
        };
      },
      { lodash: 1 }
    ],
    21: [
      function(require, module, exports) {
        var Bullet = require("../actors/Bullet");
        function BulletGroup(maxEntities, collisions) {
          Phaser.Group.call(
            this,
            game,
            game.world,
            "bullets",
            false,
            true,
            Phaser.Physics.P2JS
          );
          var i;
          this.collisions = collisions;
          for (i = 0; i < maxEntities; i++) {
            this.add(new Bullet(collisions));
          }
          return this;
        }
        var p = (BulletGroup.prototype = Object.create(Phaser.Group.prototype, {
          constructor: BulletGroup
        }));
        p.bulletSpeed = 350;
        p.lifespan = 2e3;
        p.playerBulletSpeed = 400;
        p.playerBulletLifespan = 2500;
        p.halfPi = Math.PI * 0.5;
        p.fire = function(position, body) {
          var x = position.x;
          var y = position.y;
          var angle = body.rotation + Math.PI + Math.random() * Math.PI;
          this.getFirstExists(false).fire(
            x,
            y,
            angle,
            this.bulletSpeed,
            this.lifespan
          );
        };
        module.exports = BulletGroup;
      },
      { "../actors/Bullet": 4 }
    ],
    22: [
      function(require, module, exports) {
        var levelManager = require("../data/level-manager");
        var options = require("../data/options-model");
        function Collisions() {
          this.startSystem();
          this.init();
        }
        var p = Collisions.prototype;
        p.startSystem = function() {
          game.physics.startSystem(Phaser.Physics.P2JS);
          game.physics.p2.setImpactEvents(true);
          var heavyGravity = 150;
          var lightGravity = 100;
          var currentGravity = options.gameModes.gravity.enabled
            ? heavyGravity
            : lightGravity;
          game.physics.p2.gravity.y = levelManager.endlessData.flip
            ? -lightGravity
            : currentGravity;
        };
        p.init = function() {
          this.players = game.physics.p2.createCollisionGroup();
          this.terrain = game.physics.p2.createCollisionGroup();
          this.orb = game.physics.p2.createCollisionGroup();
          this.bullets = game.physics.p2.createCollisionGroup();
          this.enemyBullets = game.physics.p2.createCollisionGroup();
          this.enemies = game.physics.p2.createCollisionGroup();
          this.fuels = game.physics.p2.createCollisionGroup();
          this.drones = game.physics.p2.createCollisionGroup();
          game.physics.p2.updateBoundsCollisionGroup();
        };
        p.set = function(sprite, collisionGroups) {
          sprite.body.collides(collisionGroups);
        };
        module.exports = Collisions;
      },
      { "../data/level-manager": 19, "../data/options-model": 20 }
    ],
    23: [
      function(require, module, exports) {
        var BulletGroup = require("./BulletGroup");
        var PlayerBulletGroup = require("./PlayerBulletGroup");
        function Groups(collisions) {
          this.collisions = collisions;
          this.init();
        }
        var p = Groups.prototype;
        p.init = function() {
          this.background = game.add.group();
          this.actors = game.add.group();
          this.fuels = game.add.group();
          this.enemies = game.add.group();
          this.terrain = game.add.group();
          this.bullets = new BulletGroup(30, this.collisions);
          this.playerBullets = new PlayerBulletGroup(30, this.collisions);
          this.drones = game.add.group();
        };
        p.swapTerrain = function() {
          game.world.swap(this.terrain, this.actors);
        };
        module.exports = Groups;
      },
      { "./BulletGroup": 21, "./PlayerBulletGroup": 24 }
    ],
    24: [
      function(require, module, exports) {
        var Bullet = require("../actors/Bullet");
        function BulletGroup(maxEntities, collisions) {
          Phaser.Group.call(
            this,
            game,
            game.world,
            "bullets",
            false,
            true,
            Phaser.Physics.P2JS
          );
          var i;
          this.collisions = collisions;
          for (i = 0; i < maxEntities; i++) {
            this.add(new Bullet(collisions, true));
          }
          return this;
        }
        var p = (BulletGroup.prototype = Object.create(Phaser.Group.prototype, {
          constructor: BulletGroup
        }));
        p.bulletSpeed = 800;
        p.lifespan = 1500;
        p.halfPi = Math.PI * 0.5;
        p.fire = function(player) {
          var angle = player.body.rotation - this.halfPi;
          var r = player.width * 0.5;
          var x = player.x + Math.cos(angle) * r;
          var y = player.y + Math.sin(angle) * r;
          this.getFirstExists(false).fire(
            x,
            y,
            angle,
            this.bulletSpeed,
            this.lifespan
          );
        };
        module.exports = BulletGroup;
      },
      { "../actors/Bullet": 4 }
    ],
    25: [
      function(require, module, exports) {
        function UserControl(features) {
          this.features = features;
          this.initExternalJoypad();
          if (!this.externalGamePadDetected && this.features.isTouchScreen) {
            this.useVirtualJoypad = true;
            this.pad = game.plugins.add(Phaser.VirtualJoystick);
          }
          this.initKeys();
        }
        var p = UserControl.prototype;
        p.gamepad = null;
        p.useKeys = false;
        p.useVirtualJoypad = false;
        p.useExternalJoypad = false;
        p.externalGamePadDetected = false;
        p.virtualJoyInit = false;
        p.isHidden = false;
        p.initExternalJoypad = function() {
          this.gamepad = game.input.gamepad.pad1;
          this.gamepad.addCallbacks(this, {
            onConnect: function() {
              this.useExternalJoypad = true;
              this.useVirtualJoypad = false;
              game.externalJoypad = {};
              game.externalJoypad.fireButton = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_1
              );
              game.externalJoypad.thrustButton = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_0
              );
              game.externalJoypad.up = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_12
              );
              game.externalJoypad.down = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_13
              );
              game.externalJoypad.left = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_14
              );
              game.externalJoypad.right = this.gamepad.getButton(
                Phaser.Gamepad.BUTTON_15
              );
            }.bind(this)
          });
          game.input.gamepad.start();
        };
        p.initKeys = function() {
          this.useKeys = true;
          this.cursors = game.input.keyboard.createCursorKeys();
          this.spacePress = game.input.keyboard.addKey(
            Phaser.Keyboard.SPACEBAR
          );
          this.xKey = game.input.keyboard.addKey(Phaser.Keyboard.X);
          this.esc = game.input.keyboard.addKey(Phaser.Keyboard.ESC);
        };
        p.reInit = function() {
          console.log(
            "virtualJoypadReinitialised",
            this.stick,
            this.buttonA,
            this.buttonB
          );
        };
        p.destroy = function() {
          if (this.useVirtualJoypad) {
            this.virtualJoyInit = false;
            this.pad.destroy();
          }
        };
        p.show = function() {
          this.isHidden = false;
          this.stick.visible = true;
          this.buttonA.visible = true;
          this.buttonB.visible = true;
        };
        p.hide = function() {
          this.isHidden = true;
          this.stick.visible = false;
          this.buttonA.visible = false;
          this.buttonB.visible = false;
        };
        p.initVirtualJoypad = function() {
          if (this.virtualJoyInit || this.isHidden) {
            this.reInit();
            return;
          }
          this.virtualJoyInit = true;
          this.stick = this.pad.addDPad(
            game.width * 0.15,
            game.height * 0.8,
            200,
            "dpad"
          );
          this.buttonA = this.pad.addButton(
            game.width * 0.78,
            game.height * 0.85,
            "dpad",
            "button1-up",
            "button1-down"
          );
          this.buttonB = this.pad.addButton(
            game.width * 0.92,
            game.height * 0.78,
            "dpad",
            "button2-up",
            "button2-down"
          );
          if (game.width < 1e3) {
            this.stick.scale = 0.75;
            this.buttonA.scale = 0.8;
            this.buttonB.scale = 0.8;
          }
        };
        p.refresh = function() {
          if (this.stick) {
            this.stick.posX = game.width * 0.15;
            this.stick.posY = game.height * 0.8;
            this.buttonA.posX = game.width * 0.78;
            this.buttonA.posY = game.height * 0.85;
            this.buttonB.posX = game.width * 0.92;
            this.buttonB.posY = game.height * 0.78;
          }
        };
        module.exports = UserControl;
      },
      {}
    ],
    26: [
      function(require, module, exports) {
        var _ = require("lodash");
        var properties = require("../../properties");
        var sound = require("../../utils/sound");
        function MapAtlas(parentGroup, levelData, key, isAtlas) {
          this.isAtlas = isAtlas;
          this.hasBitmapGate = false;
          this.x = levelData.mapPosition.x;
          this.y = levelData.mapPosition.y;
          this.key = key;
          this.data = game.cache.getFrameData(this.key);
          this.group = game.add.group(parentGroup);
          this.parent = parentGroup;
          this.levelData = levelData;
          this.counter = 0;
          this.defaultTileSize = 96;
        }
        var p = MapAtlas.prototype;
        p.hasBitmapGate = false;
        p.counter = 0;
        p.physicsSprite = null;
        p.tweenDuration = 1.75;
        p.init = function() {
          this.spriteBatch = game.add.spriteBatch(this.group, "level-map");
          this.physicsSprite = new Phaser.Sprite(game, 0, 0, null, null);
          game.world.add(this.physicsSprite);
          this.group.x = this.x;
          this.group.y = this.y;
          if (this.isAtlas) {
            this.renderAtlas();
          } else {
            this.renderImage();
          }
          if (this.levelData.hasOwnProperty("gateImgKey")) {
            this.renderGate();
          } else if (this.levelData.hasOwnProperty("gateBitmap")) {
            this.renderBitmapGate();
          }
        };
        p.renderAtlas = function() {
          var frames = this.data.getFrames();
          var tile, x, y;
          var standardTileSize =
            this.levelData.tileSize || this.defaultTileSize;
          var tileWidth = standardTileSize * this.levelData.mapScale;
          var tileHeight = standardTileSize * this.levelData.mapScale;
          var numTilesWide = this.levelData.world.width / tileWidth;
          frames = _.filter(
            frames,
            function(frame) {
              return frame.name.indexOf(this.levelData.atlasData.levelKey) >= 0;
            }.bind(this)
          );
          _.each(
            frames,
            function(frame, index) {
              x = Math.floor(index % numTilesWide) * tileWidth;
              y = Math.floor(index / numTilesWide) * tileHeight;
              tile = game.add.sprite(
                x,
                y,
                this.key,
                frame.index,
                this.spriteBatch
              );
              tile.scale.setTo(this.levelData.mapScale);
            }.bind(this)
          );
        };
        p.renderImage = function() {
          this.sprite = game.add.sprite(
            0,
            0,
            this.levelData.mapImgKey,
            null,
            this.group
          );
          this.sprite.scale.setTo(this.levelData.mapScale);
        };
        p.renderGate = function() {
          console.log("renderGate");
          this.gateSprite = game.make.sprite(0, 0, this.levelData.gateImgKey);
          this.gateSprite.scale.setTo(this.levelData.mapScale);
          this.gateSprite.position.setTo(
            this.levelData.gatePosition.x,
            this.levelData.gatePosition.y
          );
          this.parent.add(this.gateSprite);
          if (this.levelData.linkSwitchToGate) {
            this.linkSwitchToGate();
          }
        };
        p.linkSwitchToGate = function() {
          var xTo = this.levelData.switches[0].x;
          var yTo = this.levelData.switches[0].y;
          var w = Math.abs(xTo - this.gateSprite.x);
          var h = Math.abs(yTo - this.gateSprite.y);
          console.warn("link switch to gate", w + 2e3, h + 2e3);
          var selector = game.make.bitmapData(2e3, 2e3);
          selector.ctx.beginPath();
          selector.ctx.strokeStyle = "#ffffff";
          selector.ctx.lineWidth = 2;
          selector.ctx.setLineDash([3, 2]);
          selector.ctx.moveTo(1, 1);
          var part1 = { x: w * 0.5, y: 0 };
          var part2 = { x: w * 0.5, y: h };
          var part3 = { x: w - this.gateSprite.width / 2, y: h };
          selector.ctx.lineTo(part1.x, part1.y);
          selector.ctx.lineTo(part2.x, part2.y);
          selector.ctx.lineTo(part3.x, part3.y);
          selector.ctx.stroke();
          this.linkSprite = game.make.sprite(0, 0, selector);
          this.linkSprite.position.setTo(
            this.levelData.gatePosition.x + this.gateSprite.width / 2,
            this.gateSprite.y
          );
          this.parent.add(this.linkSprite);
        };
        p.renderBitmapGate = function() {
          this.hasBitmapGate = true;
          var w = this.levelData.gateBitmap.size.w;
          var h = this.levelData.gateBitmap.size.h;
          var x = this.levelData.gateBitmap.position.x;
          var y = this.levelData.gateBitmap.position.y;
          var selector = game.make.bitmapData(w, h);
          selector.ctx.beginPath();
          selector.ctx.strokeStyle = "#c8048a";
          selector.ctx.lineWidth = 2;
          selector.ctx.setLineDash([3, 2]);
          selector.ctx.moveTo(0, 0);
          selector.ctx.lineTo(0, h);
          selector.ctx.stroke();
          this.gateSprite = game.make.sprite(x + w / 2, y + h / 2, selector);
          this.parent.add(this.gateSprite);
        };
        p.initPhysics = function(collisions) {
          this.physicsSprite.width = this.group.width;
          this.physicsSprite.height = this.group.height;
          this.physicsSprite.x = this.x;
          this.physicsSprite.y = this.y;
          game.physics.p2.enable(
            this.physicsSprite,
            properties.dev.debugPhysics
          );
          this.body = this.physicsSprite.body;
          this.body.static = true;
          this.body.clearShapes();
          this.body.loadPolygon(
            this.levelCacheKey(),
            this.levelData.mapDataKey
          );
          this.body.setCollisionGroup(collisions.terrain);
          collisions.set(this.physicsSprite, [
            collisions.players,
            collisions.orb,
            collisions.bullets,
            collisions.enemyBullets
          ]);
          this.body.x = this.group.x + this.group.width / 2;
          this.body.y = this.group.y + this.group.height / 2;
          if (this.levelData.hasOwnProperty("gateImgKey")) {
            game.physics.p2.enable(
              this.gateSprite,
              properties.dev.debugPhysics
            );
            this.gateSprite.body.static = true;
            this.gateSprite.body.clearShapes();
            this.gateSprite.body.loadPolygon(
              this.gateCacheKey(),
              this.levelData.gateDataKey
            );
            this.gateSprite.body.setCollisionGroup(collisions.terrain);
            collisions.set(this.gateSprite, [
              collisions.players,
              collisions.orb,
              collisions.bullets,
              collisions.enemyBullets
            ]);
          } else if (this.levelData.hasOwnProperty("gateBitmap")) {
            game.physics.p2.enable(
              this.gateSprite,
              properties.dev.debugPhysics
            );
            this.gateSprite.body.static = true;
            this.gateSprite.body.clearShapes();
            this.gateSprite.body.addRectangle(
              20,
              this.gateSprite.height,
              0,
              0,
              0
            );
            this.gateSprite.body.setCollisionGroup(collisions.terrain);
            collisions.set(this.gateSprite, [
              collisions.players,
              collisions.orb,
              collisions.bullets,
              collisions.enemyBullets
            ]);
          }
        };
        p.update = function() {
          if (this.counter++ % 120 === 0) {
            this.blink();
          }
        };
        p.blink = function() {
          this.spriteBatch.visible = !this.spriteBatch.visible;
          if (this.gateSprite) {
            this.gateSprite.visible = this.spriteBatch.visible;
          }
        };
        p.levelCacheKey = function() {
          return this.levelData.mapDataKey + properties.mapSuffix;
        };
        p.gateCacheKey = function() {
          return this.levelData.gateDataKey + properties.mapSuffix;
        };
        p.openGate = function() {
          if (this.gateSprite && !this.hasBitmapGate) {
            sound.playSound(sound.GATE_OPEN, 1, false);
            var xTo = this.levelData.gateTweenTo.x;
            var yTo = this.levelData.gateTweenTo.y;
            TweenMax.to(this.gateSprite.body, this.tweenDuration, {
              x: xTo,
              y: yTo,
              ease: Quad.easeOut
            });
          }
          if (this.linkSprite) {
            this.linkSprite.visible = false;
          }
        };
        p.allEnemiesDetroyed = function() {
          if (this.hasBitmapGate) {
            sound.playSound(sound.GATE_OPEN, 1, false);
            this.gateSprite.body.destroy();
            this.gateSprite.destroy();
          }
        };
        p.closeGate = function() {
          if (this.gateSprite) {
            sound.playSound(sound.GATE_CLOSE, 1, false);
            var xTo = this.levelData.gatePosition.x;
            var yTo = this.levelData.gatePosition.y;
            TweenMax.to(this.gateSprite.body, this.tweenDuration, {
              x: xTo,
              y: yTo,
              ease: Quad.easeOut
            });
          }
        };
        module.exports = MapAtlas;
      },
      { "../../properties": 31, "../../utils/sound": 71, lodash: 1 }
    ],
    27: [
      function(require, module, exports) {
        var particles = require("./manager");
        var ParticleSystem = require("./ParticleSystem");
        function FuelParticlesSystem() {}
        var p = (FuelParticlesSystem.prototype = Object.create(
          ParticleSystem.prototype,
          { constructor: FuelParticlesSystem }
        ));
        module.exports = FuelParticlesSystem;
        p.init = function(source) {
          ParticleSystem.prototype.init.call(this);
          this.well = this.emitter.createGravityWell(source.x, source.y, 2);
          this.circle = this.manager.createCircleZone(20);
          this.emitter.addToWorld(particles.group);
        };
        p.start = function(origin, target) {
          ParticleSystem.prototype.start.call(this, origin, target);
          if (particles.enabled) {
            this.emitter.emit("fuelEmitter", this.origin.x, this.origin.y, {
              zone: this.circle,
              total: 3,
              repeat: -1,
              frequency: 15
            });
            this.refuelEmitterEvent = this.emitter.timerEvent;
          }
        };
        p.update = function() {
          if (particles.enabled) {
            this.well.position.x = this.target.x;
            this.well.position.y = this.target.y;
            ParticleSystem.prototype.update.call(this);
          }
        };
        p.stop = function() {
          ParticleSystem.prototype.stop.call(this);
          if (particles.enabled) {
            game.time.events.remove(this.refuelEmitterEvent);
            this.refuelEmitterEvent.loop = false;
          }
        };
      },
      { "./ParticleSystem": 28, "./manager": 29 }
    ],
    28: [
      function(require, module, exports) {
        var particles = require("./manager");
        function ParticleSystem() {}
        var p = ParticleSystem.prototype;
        module.exports = ParticleSystem;
        p.isEmitting = false;
        p.start = null;
        p.target = null;
        p.emitter = null;
        p.init = function() {
          this.manager = particles.manager;
          this.emitter = this.manager.createEmitter(
            Phaser.ParticleStorm.SPRITE_BATCH
          );
          this.emitter.addToWorld(particles.group);
        };
        p.start = function(origin, target) {
          this.isEmitting = true;
          this.origin = origin;
          this.target = target;
        };
        p.update = function() {};
        p.stop = function() {
          this.isEmitting = false;
          this.target = null;
        };
      },
      { "./manager": 29 }
    ],
    29: [
      function(require, module, exports) {
        "use strict";
        module.exports = {
          group: null,
          manager: null,
          emitter: null,
          powerEmitter: null,
          enabled: true,
          init: function() {
            this.manager = game.plugins.add(Phaser.ParticleStorm);
          },
          enable: function() {
            this.enabled = true;
          },
          disable: function() {
            this.enabled = false;
          },
          create: function() {
            this.group = game.add.group();
            this.group.fixedToCamera = false;
            var explodeParticle = game.make.bitmapData(2, 2);
            explodeParticle.ctx.fillStyle = "#ffffff";
            explodeParticle.ctx.beginPath();
            explodeParticle.ctx.fillRect(0, 0, 2, 2);
            explodeParticle.ctx.closePath();
            var transporterParticle = game.make.bitmapData(2, 2);
            transporterParticle.ctx.fillStyle = "#f0ff00";
            transporterParticle.ctx.beginPath();
            transporterParticle.ctx.fillRect(0, 0, 2, 2);
            transporterParticle.ctx.closePath();
            var transporterOrbParticle = game.make.bitmapData(2, 2);
            transporterOrbParticle.ctx.fillStyle = "#42ff00";
            transporterOrbParticle.ctx.beginPath();
            transporterOrbParticle.ctx.fillRect(0, 0, 2, 2);
            transporterOrbParticle.ctx.closePath();
            var fuelParticle = game.make.bitmapData(2, 2);
            fuelParticle.ctx.fillStyle = "#3CFFFF";
            fuelParticle.ctx.fillRect(0, 0, 2, 2);
            game.cache.addBitmapData("transportParticle", transporterParticle);
            game.cache.addBitmapData(
              "transportOrbParticle",
              transporterOrbParticle
            );
            game.cache.addBitmapData("fuelParticle", fuelParticle);
            game.cache.addBitmapData("explodeParticle", explodeParticle);
            var teleportEmitterData = {
              lifespan: 400,
              image: game.cache.getBitmapData("fuelParticle")
            };
            var teleportEmitterDataOrb = {
              lifespan: 400,
              image: game.cache.getBitmapData("fuelParticle"),
              hsv: { initial: 0, value: 359, control: "linear" }
            };
            var fuelEmitterData = {
              lifespan: 850,
              image: game.cache.getBitmapData("fuelParticle"),
              vy: { min: 0, max: 0 },
              alpha: {
                initial: 0,
                value: 1,
                control: [{ x: 0, y: 1 }, { x: 1, y: 0 }]
              }
            };
            var lifeSpan = game.device.isMobile
              ? { min: 2e3, max: 4e3 }
              : { min: 1e3, max: 2e3 };
            var smokeData = {
              lifespan: lifeSpan,
              hsv: 299,
              image: "combined",
              frame: "smoke-particle.png",
              vx: { min: -0.1, max: 0.1 },
              vy: -1,
              scale: { min: 0.01, max: 0.1 },
              alpha: { value: 0, delta: 0.005 }
            };
            var fuelExplodeEmitter = {
              lifespan: { min: 500, max: 1250 },
              image: game.cache.getBitmapData("fuelParticle"),
              scale: { min: 0.25, max: 1.5 },
              rotation: { delta: 4 },
              velocity: {
                radial: { arcStart: -15, arcEnd: 15 },
                initial: { min: 1, max: 3 }
              }
            };
            var explodeEmitterData = {
              lifespan: { min: 500, max: 1e3 },
              image: game.cache.getBitmapData("explodeParticle"),
              scale: { min: 0.5, max: 2 },
              rotation: { delta: 3 },
              velocity: {
                radial: { arcStart: -30, arcEnd: 20 },
                initial: { min: 3, max: 6 }
              }
            };
            this.manager.addData("explode", explodeEmitterData);
            this.manager.addData("fuelEmitter", fuelEmitterData);
            this.manager.addData("transporter", teleportEmitterData);
            this.manager.addData("fuelExplode", fuelExplodeEmitter);
            this.manager.addData("smoke", smokeData);
            this.powerEmitter = this.manager.createEmitter(
              Phaser.ParticleStorm.SPRITE_BATCH
            );
            this.powerEmitter.addToWorld(this.group);
            this.emitter = this.manager.createEmitter(
              Phaser.ParticleStorm.SPRITE_BATCH
            );
            this.emitter.addToWorld(this.group);
          },
          playerTeleport: function(x, y, boundCallback) {
            var circle = this.manager.createCircleZone(25);
            this.emitter.force.y = 0;
            this.emitter.emit("transporter", x, y, {
              zone: circle,
              total: 20,
              repeat: 10,
              frequency: 100
            });
            if (boundCallback) {
              game.time.events.add(1e3, boundCallback);
            }
          },
          orbTeleport: function(x, y) {
            var circle = this.manager.createCircleZone(25);
            this.emitter.force.y = 0;
            this.emitter.emit("transporter", x, y, {
              zone: circle,
              total: 20,
              repeat: 10,
              frequency: 100
            });
          },
          explode: function(x, y) {
            this.emitter.force.y = 0.1;
            this.emitter.emit("explode", x, y, { total: 20 });
          },
          fuelExplode: function(x, y) {
            this.emitter.force.y = -0.005;
            this.emitter.emit("fuelExplode", x, y, { total: 80 });
          },
          emitPower: function(x, y) {
            console.log(
              "particle-manager :: emitPower :: x,y",
              x,
              y,
              this.enabled
            );
            if (this.enabled) {
              var freqency = game.device.isMobile ? 100 : 50;
              this.powerEmitter.force.y = -1e-4;
              this.powerEmitter.emit("smoke", x, y, {
                repeat: -1,
                frequency: freqency
              });
              this.powerEmitter.timer.resume();
            }
          },
          stopPower: function() {
            this.powerEmitter.timer.pause();
          }
        };
      },
      {}
    ],
    30: [
      function(require, module, exports) {
        var launcher = require("./states/launcher");
        window.onload = function() {
          launcher.renderMode = Phaser.CANVAS;
          launcher.enableHiResMode();
          launcher.setCustomOptions({
            options: { gameModes: { allLevels: true } }
          });
          launcher.start();
        };
      },
      { "./states/launcher": 33 }
    ],
    31: [
      function(require, module, exports) {
        (function(global) {
          "use strict";
          var Phaser = global.Phaser;
          module.exports = {
            backgroundColour: 2071,
            collideWorldBounds: true,
            enableTouchPad: false,
            enableJoyPad: false,
            fatalCollisions: true,
            drawBackground: true,
            width: 800,
            height: 500,
            scale: {
              bestFit: true,
              hires: true,
              web: Phaser.ScaleManager.NO_SCALE,
              device: Phaser.ScaleManager.NO_SCALE
            },
            dev: {
              mode: false,
              debugPhysics: false,
              debugPositions: false,
              stats: false,
              skipIntro: false
            },
            gamePlay: {
              firingMagnitude: 350,
              tractorBeamLength: 100,
              tractorBeamVariation: 10,
              lockingDuration: 800,
              parallax: true,
              freeOrbLocking: false,
              autoOrbLocking: true
            },
            mapSuffix: "-map",
            actors: { key: "combined" },
            levels: {
              training: {
                mapImgUrl: "assets/levels/training.png",
                mapImgKey: "training",
                mapDataUrl: "assets/physics/training.json",
                mapDataKey: "training",
                mapScale: 2,
                useAtlas: false,
                mapPosition: { x: 0, y: 1700 },
                missionSwipe: {
                  title: "Flight Training",
                  desc: "Welcome to flight training pilot",
                  color: "rgba(124, 255, 0, 0.7)"
                },
                world: { width: 3e3, height: 3e3 },
                spawns: [{ x: 1500, y: 1550, orb: false }],
                orbPosition: { x: 2600, y: 1732 },
                orbHolder: { x: 2600, y: 1770 }
              },
              startLevel: 1
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {}
    ],
    32: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var features = require("../utils/features");
        var UserControl = require("../environment/UserControl");
        var particles = require("../environment/particles/manager");
        var userControl;
        var optionsModel = require("../data/options-model");
        var _ = require("lodash");
        var version = require("../../../package.json").version;
        module.exports = {
          init: function(customScaleMode, customOptions) {
            this.customScaleMode = customScaleMode;
            this.customOptions = customOptions;
          },
          bootScreen: null,
          preload: function() {
            game.load.image("splash", "assets/images/splash-1.png");
          },
          create: function() {
            this.mergeOptions();
            game.stage.backgroundColor = properties.backgroundColour;
            features.init();
            particles.init();
            if (this.customScaleMode >= 0) {
              game.scale.scaleMode = this.customScaleMode;
            } else {
              game.scale.scaleMode = features.isTouchScreen
                ? properties.scale.device
                : properties.scale.web;
            }
            if (properties.dev.stats) {
              game.time.advancedTiming = true;
            }
            game.scale.canExpandParent = true;
            game.scale.fullScreenScaleMode = game.scale.NO_SCALE;
            userControl = new UserControl(features);
            game.controls = userControl;
            game.e2e = {};
            this.bootScreen = game.add.sprite(0, 0, "splash");
            this.bootScreen.inputEnabled = true;
            this.bootScreen.useHandCursor = true;
            this.bootScreen.width = game.width;
            this.bootScreen.height = game.height;
            this.bootScreen.alpha = 0;
            var style = {
              font: "18px thrust_regular",
              fill: "#ffffff",
              align: "left"
            };
            this.version = game.add.text(
              0,
              0,
              "THRUST 30 v" + version + optionsModel.versionSuffix,
              style
            );
            this.version.anchor.setTo(0.5, 0.5);
            this.version.x = game.width / 2;
            this.version.y = game.height * 0.75;
            this.version.alpha = 0;
            TweenMax.to(this.bootScreen, 3, {
              alpha: 1,
              ease: Quad.easeIn,
              onComplete: this.startLoad,
              callbackScope: this
            });
            TweenMax.to(this.version, 3, { alpha: 1, ease: Quad.easeIn });
            game.e2e.boot = this;
          },
          update: function() {},
          mergeOptions: function() {
            _.merge(optionsModel, this.customOptions);
            console.log("options-", optionsModel);
          },
          startLoad: function() {
            game.state.start(
              "load",
              false,
              false,
              this.bootScreen,
              this.version
            );
          }
        };
      },
      {
        "../../../package.json": 2,
        "../data/options-model": 20,
        "../environment/UserControl": 25,
        "../environment/particles/manager": 29,
        "../properties": 31,
        "../utils/features": 68,
        lodash: 1
      }
    ],
    33: [
      function(require, module, exports) {
        (function(global) {
          "use strict";
          var properties = require("../properties");
          module.exports = {
            renderMode: null,
            customScaleMode: null,
            customOptions: {},
            setCustomOptions: function(options) {
              this.customOptions = options.options;
            },
            enableHiResMode: function() {
              var parent = document.getElementById("gameContainer");
              if (parent) {
                properties.width = parent.clientWidth;
                properties.height = parent.clientHeight;
              } else {
                properties.width = window.innerWidth;
                properties.height = window.innerHeight;
              }
            },
            setCustomScale: function(scaleMode) {
              this.customScaleMode = scaleMode;
            },
            setRenderMode: function(renderMode) {
              this.renderMode = renderMode;
            },
            start: function() {
              var domParent = document.getElementById("gameContainer") || "";
              global.game = new Phaser.Game(
                properties.width,
                properties.height,
                this.renderMode,
                domParent,
                "boot",
                false,
                true
              );
              game.state.add("play", require("./play"));
              game.state.add("load", require("./load"));
              game.state.add("boot", require("./boot"));
              game.state.start(
                "boot",
                true,
                false,
                this.customScaleMode,
                this.customOptions
              );
              if (!this.customOptions.isCordova) {
                window.addEventListener(
                  "resize",
                  function() {
                    this.enableHiResMode();
                    game.scale.setGameSize(properties.width, properties.height);
                    game.controls.refresh();
                  }.bind(this)
                );
              }
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      { "../properties": 31, "./boot": 32, "./load": 34, "./play": 35 }
    ],
    34: [
      function(require, module, exports) {
        "use strict";
        var properties = require("../properties");
        var levelsLoader = require("../utils/levels-loader");
        var gameState = require("../data/game-state");
        var optionsModel = require("../data/options-model");
        module.exports = {
          init: function(bootScreen, versionTxt) {
            console.log("load state :: init", bootScreen);
            levelsLoader.init();
            this.bootScreen = bootScreen;
            this.versionTxt = versionTxt;
            var x = 0;
            var y = game.height * 0.7;
            var bmd = game.make.bitmapData(1, 1);
            bmd.rect(0, 0, 1, 1, "rgba(255, 0, 0, 0.5)");
            this.swipe = game.add.sprite(x, y, bmd);
            this.swipe.anchor.setTo(0);
            this.swipe.width = 1;
            this.swipe.height = 20;
          },
          preload: function() {
            game.load.onFileComplete.add(this.fileComplete, this);
            game.load.onLoadComplete.add(this.loadComplete, this);
            levelsLoader.loadLevelsJson(optionsModel.getLevelsJsonUrl());
            game.load.atlas(
              "dpad",
              "assets/images/virtualjoystick/skins/dpad.png",
              "assets/images/virtualjoystick/skins/dpad.json"
            );
            if (properties.dev.mode) {
              game.load.image("crossHair", "assets/images/cross-hair.png");
            }
            game.load.image(
              "coverImage",
              "assets/images/thrust-cover-styled-538x422.png"
            );
            game.load.image("pause", "assets/images/pause-button.png");
            this.preloadTrainingMap(properties.levels.training);
            game.load.physics("playerPhysics", "assets/physics/player.json");
            game.load.physics(
              "powerStationPhysics",
              "assets/physics/power-station.json"
            );
            game.load.physics(
              "orbHolderPhysics",
              "assets/physics/orb-holder.json"
            );
            this.loadSfx();
            this.loadMusic();
          },
          getSfxAudioFormats: function() {
            var formats;
            if (game.device.android) {
              formats = "assets/audiosprite/thrust-sfx.ogg";
            } else {
              formats = [
                "assets/audiosprite/thrust-sfx.mp3",
                "assets/audiosprite/thrust-sfx.m4a",
                "assets/audiosprite/thrust-sfx.ogg"
              ];
            }
            return formats;
          },
          getMusicAudioFormats: function() {
            var formats;
            if (game.device.android) {
              formats = "assets/audiosprite/thrust-music.ogg";
            } else {
              formats = [
                "assets/audiosprite/thrust-music.mp3",
                "assets/audiosprite/thrust-music.m4a",
                "assets/audiosprite/thrust-music.ogg"
              ];
            }
            return formats;
          },
          loadSfx: function() {
            game.load.audiosprite(
              "sfx",
              this.getSfxAudioFormats(),
              "assets/audiosprite/thrust-sfx.json"
            );
          },
          loadMusic: function() {
            game.load.audiosprite(
              "music",
              this.getMusicAudioFormats(),
              "assets/audiosprite/thrust-music.json"
            );
          },
          preloadTrainingMap: function(levelData) {
            game.load.image(levelData.mapImgKey, levelData.mapImgUrl);
            game.load.physics(
              levelData.mapDataKey + properties.mapSuffix,
              levelData.mapDataUrl
            );
          },
          fileComplete: function(progress, cacheKey) {
            console.log("load :: fileComplete", cacheKey);
            var percent = game.load.progress;
            this.tween = TweenMax.to(this.swipe, 0.1, {
              width: game.width * percent / 100
            });
          },
          loadComplete: function() {
            console.log("load :: loadComplete");
            this.decodeAudio();
          },
          decodeAudio: function() {
            console.log("load :: decodeAudio");
            var sfx = game.add.audioSprite("sfx");
            sfx.allowMultiple = true;
            var music = game.add.audioSprite("music");
            music.allowMultiple = true;
            game.sfx = sfx;
            game.music = music;
            game.sound.setDecodedCallback(
              ["sfx", "music"],
              this.transitionOut,
              this
            );
            console.log("load :: decodeAudio : end reach");
          },
          transitionOut: function() {
            if (this.bootScreen) {
              TweenMax.to(this.swipe, 1, { alpha: 0, ease: Quad.easeOut });
              TweenMax.to(this.bootScreen, 1, {
                alpha: 0,
                ease: Quad.easeOut,
                onComplete: this.startPlay,
                callbackScope: this
              });
              TweenMax.to(this.versionTxt, 1, { alpha: 0, ease: Quad.easeOut });
            } else {
              this.startPlay();
            }
          },
          startPlay: function() {
            console.log("load :: start play ", gameState);
            this.swipe.destroy();
            gameState.init();
            if (this.bootScreen) {
              this.bootScreen.destroy();
            }
            if (this.versionTxt) {
              this.versionTxt.destroy();
            }
            game.state.start("play", true, false);
          }
        };
      },
      {
        "../data/game-state": 18,
        "../data/options-model": 20,
        "../properties": 31,
        "../utils/levels-loader": 70
      }
    ],
    35: [
      function(require, module, exports) {
        (function(global) {
          "use strict";
          var properties = require("../properties");
          var Collisions = require("../environment/Collisions");
          var Groups = require("../environment/Groups");
          var ui = require("../ui/index");
          var Player = require("../actors/Player");
          var Fuel = require("../actors/Fuel");
          var Limpet = require("../actors/Limpet");
          var Switch = require("../actors/GateSwitch");
          var Orb = require("../actors/Orb");
          var Background = require("../actors/Background");
          var TractorBeam = require("../actors/TractorBeam");
          var _ = require("lodash");
          var particles = require("../environment/particles/manager");
          var levelManager = require("../data/level-manager");
          var PowerStation = require("../actors/PowerStation");
          var PhysicsActor = require("../actors/PhysicsActor");
          var gameState = require("../data/game-state");
          var sound = require("../utils/sound");
          var droneManager = require("../actors/drone-manager");
          var Stopwatch = require("../ui/Stopwatch");
          var TimelineMax = global.TimelineMax;
          var features = require("../utils/features");
          var MapAtlas = require("../environment/levels/MapAtlas");
          var options = require("../data/options-model");
          var StatusBar = global.StatusBar;
          module.exports = {
            isGameOver: true,
            startDebugLevel: false,
            cleaning: false,
            level: null,
            collisions: null,
            groups: null,
            player: null,
            orb: null,
            fuels: [],
            tractorBeam: null,
            background: null,
            limpetGuns: [],
            switches: [],
            buttonADown: false,
            buttonBDown: false,
            isXDown: false,
            inPlay: false,
            emitter: null,
            crossHair: null,
            crossHairSpeed: 15,
            menuMode: false,
            stopwatch: null,
            cameraPos: { x: 0, y: 0 },
            planetDeathTl: null,
            explosionsTimer: null,
            create: function() {
              this.initOptionsModel();
              this.initFullScreenHandling();
              this.level = levelManager.currentLevel;
              game.world.setBounds(
                0,
                0,
                this.level.world.width,
                this.level.world.height
              );
              this.createActors();
              this.createLevelMap();
              this.createUi();
              gameState.uiCreated = true;
              this.createGroupLayering();
              this.showCurrentScreenByState(gameState.currentState);
              gameState.levelsCompleted.add(this.levelsCompleted, this);
              if (StatusBar) {
                StatusBar.hide();
              }
            },
            initOptionsModel: function() {
              options.init();
              options.fxParticlesOn.add(this.fxParticlesOn, this);
              options.fxParticlesOff.add(this.fxParticlesOff, this);
              options.fxBackgroundOn.add(this.fxBackgroundOn, this);
              options.fxBackgroundOff.add(this.fxBackgroundOff, this);
              options.loadNewLevels.add(this.loadNewLevelPack, this);
              if (!options.display.fx.particles) {
                particles.disable();
              }
            },
            debugSpawns: function() {
              _.each(this.level.spawns, function(spawn) {
                var spawnBm = game.make.bitmapData(50, 50);
                spawnBm.ctx.fillStyle = "#ff93ff";
                spawnBm.ctx.beginPath();
                spawnBm.ctx.lineWidth = 1;
                spawnBm.ctx.arc(25, 25, 25, 0, Math.PI * 2, true);
                spawnBm.ctx.closePath();
                spawnBm.ctx.fill();
                var spawnSpr = game.add.sprite(spawn.x, spawn.y, spawnBm);
                spawnSpr.anchor.setTo(0.5);
                spawnSpr.alpha = 0.2;
              });
            },
            fxParticlesOff: function() {
              particles.disable();
              this.powerStation.stopParticles();
            },
            fxParticlesOn: function() {
              particles.enable();
              this.powerStation.startParticles();
            },
            fxBackgroundOn: function() {
              if (!this.background.enabled) {
                this.background.enable();
              }
            },
            fxBackgroundOff: function() {
              if (this.background.enabled) {
                this.background.disable();
              }
            },
            initFullScreenHandling: function() {
              game.scale.onFullScreenChange.add(this.fullScreenChange, this);
            },
            fullScreenChange: function() {
              options.display.fullscreen = game.scale.isFullScreen;
            },
            initStopwatch: function() {
              ui.drawStopwatch();
              this.stopwatch = new Stopwatch(ui.stopwatch);
            },
            update: function() {
              if (this.cleaning) {
                return;
              }
              this.checkPlayerInput();
              this.actorsUpdate();
              this.uiUpdate();
              this.checkGameCondition();
              if (droneManager.followOrb) {
                this.updateCamera(this.orb.sprite);
              } else {
                this.updateCamera(this.player);
              }
              if (this.uiMode || this.isGameOver) {
                ui.update(this.uiMode);
              }
              if (
                game.controls.useExternalJoypad &&
                gameState.trainingMode &&
                ui.missionDialog.enabled
              ) {
                ui.missionDialog.update();
              }
              if (this.isDevMode) {
                this.devModeUpdate();
              }
            },
            render: function() {
              if (properties.dev.stats === true) {
                var color = game.device.isMobile ? "#0000ff" : "#00ff00";
                game.debug.text(
                  game.time.fps || "--",
                  game.width - 50,
                  14,
                  color
                );
              }
              if (properties.dev.debugPositions) {
                game.debug.cameraInfo(game.camera, 400, 32);
                if (this.isDevMode) {
                  game.debug.spriteCoords(this.crossHair, 32, 450);
                } else {
                  game.debug.spriteCoords(this.player, 32, 450);
                }
              }
            },
            playGame: function() {
              gameState.isGameOver = false;
              this.isGameOver = false;
              if (gameState.cheats.startDebugLevel) {
                gameState.cheats.startDebugLevel = false;
                this.cleaning = true;
                this.nextLevel();
                return;
              }
              ui.showUser();
              if (
                options.gameModes.speedRun.enabled ||
                gameState.trainingMode
              ) {
                this.initStopwatch();
              }
              if (!properties.dev.skipIntro) {
                this.startLevelIntro();
              } else if (!properties.dev.mode) {
                this.missionStart();
              } else {
                this.initialiseDevMode();
              }
            },
            levelsCompleted: function() {
              sound.playMusic("thrust-in-game1", 0.7, true);
              gameState.currentState = gameState.PLAY_STATES.COMPLETE;
              this.showCurrentScreenByState(gameState.currentState);
            },
            showPauseButton: function() {
              if (this.pauseButton) {
                this.pauseButton.visible = true;
              }
            },
            hidePauseButton: function() {
              if (this.pauseButton) {
                this.pauseButton.visible = false;
              }
            },
            showCurrentScreenByState: function(state) {
              console.log("play :: showCurrentScreenByState :: ", state);
              this.uiMode =
                state === gameState.PLAY_STATES.MENU ||
                state === gameState.PLAY_STATES.OPTIONS;
              if (state === gameState.PLAY_STATES.PLAY) {
                ui.showUser();
                this.playGame();
                this.showPauseButton();
              } else {
                this.hidePauseButton();
                ui.hideUser();
              }
              var shouldFadeBackground =
                state === gameState.PLAY_STATES.COMPLETE ||
                state === gameState.PLAY_STATES.HIGH_SCORES ||
                state === gameState.PLAY_STATES.INTERSTITIAL;
              ui.showScreen(state, shouldFadeBackground);
              if (state === gameState.PLAY_STATES.MENU) {
                sound.playMusic("thrust-title-theme1", 0.5, true);
                ui.removeGameOver();
              }
              if (
                state === gameState.PLAY_STATES.HIGH_SCORES &&
                gameState.shouldEnterHighScore
              ) {
                ui.highscores.insertNewScore();
                gameState.shouldEnterHighScore = false;
              }
            },
            menuItemSelected: function(item) {
              switch (item.text.text) {
                case "PLAY THRUST":
                  sound.playMusic("thrust-in-game1", 0.7, true);
                  gameState.newPlayer();
                  gameState.trainingMode = false;
                  this.newGame();
                  break;
                case "TRAINING":
                  gameState.newPlayer();
                  gameState.trainingMode = true;
                  this.restartPlayState();
                  this.showCurrentScreenByState(gameState.PLAY_STATES.PLAY);
                  break;
                case "HIGH-SCORES":
                  this.showCurrentScreenByState(
                    gameState.PLAY_STATES.HIGH_SCORES
                  );
                  break;
                case "OPTIONS":
                  this.showCurrentScreenByState(gameState.PLAY_STATES.OPTIONS);
                  break;
                default:
                  break;
              }
            },
            updateCamera: function(target) {
              var lerp = 0.05;
              this.cameraPos.x += (target.x - this.cameraPos.x) * lerp;
              this.cameraPos.y += (target.y - this.cameraPos.y) * lerp;
              game.camera.focusOnXY(this.cameraPos.x, this.cameraPos.y);
            },
            loadNewLevelPack: function() {
              this.clearPlayWorld();
              game.state.start("load", true, true);
            },
            restartPlayState: function() {
              ui.countdown.clear();
              ui.destroy();
              options.dispose();
              this.clearPlayWorld();
              gameState.nextLevelCheck();
              game.state.restart();
            },
            restartLevel: function() {
              this.level = levelManager.currentLevel;
              game.world.setBounds(
                0,
                0,
                this.level.world.width,
                this.level.world.height
              );
              this.createActors();
              this.createLevelMap();
              this.createGroupLayering();
              this.playGame();
            },
            clearPlayWorld: function() {
              this.limpetGuns = [];
              this.fuels = [];
              if (this.orb) {
                this.orb.dispose();
                this.orb = null;
              }
              if (this.tractorBeam) {
                this.tractorBeam.dispose();
                this.tractorBeam = null;
                this.player.tractorBeam = null;
              }
              game.controls.destroy();
              this.groups.background.removeAll(true);
              this.groups.actors.removeAll(true);
              this.groups.fuels.removeAll(true);
              this.groups.enemies.removeAll(true);
              this.groups.terrain.removeAll(true);
            },
            newGame: function() {
              levelManager.newGame();
              gameState.currentState = gameState.PLAY_STATES.PLAY;
              this.restartPlayState();
            },
            nextLevel: function() {
              gameState.currentState = gameState.PLAY_STATES.PLAY;
              this.restartPlayState();
            },
            startLevelIntro: function() {
              ui.missionSwipe.missionStartSwipeIn(this.missionStart, this);
            },
            missionStart: function() {
              if (gameState.trainingMode) {
                this.createMissionDialog();
              } else {
                if (options.gameModes.speedRun.enabled) {
                  this.startSpeedRun();
                }
                this.playerStart();
              }
            },
            startSpeedRun: function() {
              this.stopwatch.start(ui.stopwatch);
            },
            playerStart: function() {
              this.player.start(this.playerWarpComplete, this);
            },
            playerWarpComplete: function() {
              this.inPlay = true;
              this.initControls();
              this.startEnemies();
              if (!gameState.trainingMode) {
                this.player.orbActivated = true;
              }
            },
            startEnemies: function() {
              _.each(this.limpetGuns, function(limpet) {
                limpet.start();
              });
            },
            checkPlayerInput: function() {
              if (!this.inPlay) {
                return;
              }
              if (game.controls.useExternalJoypad) {
                this.player.checkPlayerControlJoypad();
              } else {
                this.player.checkPlayerControl(this.cursors, this.buttonADown);
              }
            },
            checkGameCondition: function() {
              this.checkPlayerLocation();
              this.checkGameOver();
            },
            checkPlayerLocation: function() {
              if (this.player.alive) {
                if (this.player.y < 150 && this.player.inGameArea) {
                  this.player.inGameArea = false;
                  this.inPlay = false;
                  this.player.stop();
                  if (this.orb) {
                    this.orb.stop();
                  }
                  console.log("play :: ui.countdown.stop");
                  ui.countdown.stop();
                  sound.playSound(sound.PLAYER_TELEPORT_OUT);
                  this.player.levelExit();
                  this.stopStopwatch();
                  if (gameState.trainingMode) {
                    droneManager.trainingComplete();
                    gameState.playTime = this.stopwatch.getText();
                  }
                  particles.playerTeleport(
                    this.player.x,
                    this.player.y,
                    _.bind(this.levelTransition, this)
                  );
                  if (this.tractorBeam && this.tractorBeam.hasGrabbed) {
                    gameState.bonuses.orbRecovered = true;
                    this.tractorBeam.breakLink();
                    particles.orbTeleport(this.orb.sprite.x, this.orb.sprite.y);
                  }
                }
              }
            },
            checkGameOver: function() {
              if (gameState.isGameOver && !this.isGameOver) {
                this.isGameOver = true;
                ui.showGameOver();
                console.warn(
                  "play :: checkGameOver :: isGameOver",
                  this.isGameOver
                );
                sound.playSound(sound.UI_GAME_OVER);
                game.time.events.add(2e3, _.bind(this.gameOver, this));
              }
            },
            levelTransition: function() {
              var hasOrb = this.tractorBeam ? true : false;
              this.player.tweenOutAndRemove(hasOrb);
              game.time.events.add(
                1e3,
                _.bind(this.levelInterstitialStart, this)
              );
            },
            levelInterstitialStart: function() {
              gameState.currentState = gameState.PLAY_STATES.INTERSTITIAL;
              ui.showScreen(gameState.currentState, true);
            },
            gameOver: function() {
              console.warn("play :: gameOver called");
              ui.countdown.stop();
              this.stopStopwatch();
              if (gameState.trainingMode) {
                gameState.trainingMode = false;
                gameState.currentState = gameState.PLAY_STATES.MENU;
                gameState.newGame();
              } else {
                gameState.currentState = gameState.PLAY_STATES.HIGH_SCORES;
                if (gameState.isGameOver) {
                  gameState.doHighScoreCheck();
                }
              }
              this.restartPlayState();
            },
            stopStopwatch: function() {
              if (options.gameModes.speedRun.enabled) {
                this.stopwatch.stop();
              }
            },
            actorsUpdate: function() {
              this.player.update();
              if (this.tractorBeam) {
                this.tractorBeam.update();
              }
              if (this.powerStation) {
                this.powerStation.update();
              }
              this.checkForFuelDistance();
              this.groups.enemies.forEachAlive(function(enemy) {
                enemy.setPower(this.powerStation.health);
                enemy.update();
              }, this);
              if (this.background && this.background.enabled) {
                this.background.update();
              }
              if (this.map && levelManager.endlessData.blink) {
                this.map.update();
              }
            },
            checkForFuelDistance: function() {
              _.each(
                this.fuels,
                _.bind(function(fuel) {
                  fuel.update();
                }, this)
              );
            },
            uiUpdate: function() {
              ui.score.update(gameState.score, true);
              ui.fuel.update(gameState.fuel, true);
              ui.lives.update(Math.max(gameState.lives, 0), true);
              if (
                gameState.currentState === gameState.PLAY_STATES.HIGH_SCORES
              ) {
                ui.highscores.update();
              }
              if (game.externalJoypad) {
                if (
                  gameState.currentState === gameState.PLAY_STATES.INTERSTITIAL
                ) {
                  ui.interstitial.update();
                } else if (
                  gameState.currentState === gameState.PLAY_STATES.COMPLETE
                ) {
                  ui.levelsComplete.update();
                }
              }
            },
            createActors: function() {
              this.collisions = new Collisions();
              this.groups = new Groups(this.collisions);
              if (properties.drawBackground) {
                this.background = new Background(this.level, this.groups);
              }
              particles.create();
              this.player = new Player(this.collisions, this.groups);
              this.player.onKilled.add(this.playerKilled, this);
              this.player.earlyInterstitial.add(this.earlyInterstitial, this);
              if (this.level.orbPosition) {
                this.orb = new Orb(
                  this.groups,
                  this.level.orbPosition.x,
                  this.level.orbPosition.y,
                  this.collisions
                );
                this.orb.setPlayer(this.player);
                this.tractorBeam = new TractorBeam(
                  this.orb,
                  this.player,
                  this.groups
                );
                this.player.setTractorBeam(this.tractorBeam);
                this.orbHolder = new PhysicsActor(
                  this.collisions,
                  this.groups,
                  "combined",
                  "orb-holder.png",
                  this.level.orbHolder.x,
                  this.level.orbHolder.y
                );
              }
              if (!gameState.trainingMode) {
                _.each(this.level.enemies, _.bind(this.createLimpet, this));
                _.each(this.level.fuels, _.bind(this.createFuel, this));
                if (this.level.powerStation) {
                  this.powerStation = new PowerStation(
                    this.collisions,
                    this.groups,
                    "combined",
                    "power-station_001.png",
                    this.level.powerStation.x,
                    this.level.powerStation.y
                  );
                  this.powerStation.initPhysics(
                    "powerStationPhysics",
                    "power-station"
                  );
                  this.powerStation.destructionSequenceActivated.add(
                    this.startDestructionSequence,
                    this
                  );
                  this.powerStation.body.setCollisionGroup(
                    this.collisions.terrain
                  );
                  this.powerStation.initCollisions();
                }
                this.createMainPhysics();
              } else {
                this.createTrainingDrones();
                this.createTrainingPhysics();
              }
              this.cameraPos.x = this.player.x;
              this.cameraPos.y = this.player.y;
              game.e2e.player = this.player;
              game.e2e.enemies = this.limpetGuns;
              this.cleaning = false;
              if (game.device.webApp) {
                var bmd = game.make.bitmapData(50, 50);
                bmd.rect(0, 0, 50, 50, "rgba(255,0,0,1)");
                var testFlag = game.add.sprite(0, 0, bmd);
                testFlag.fixedToCamera = true;
              }
            },
            createMainPhysics: function() {
              if (this.orb) {
                if (this.powerStation) {
                  this.collisions.set(this.powerStation, [
                    this.collisions.players,
                    this.collisions.orb
                  ]);
                }
              }
            },
            createTrainingPhysics: function() {
              if (this.orb) {
                this.collisions.set(this.orb.sprite, [
                  this.collisions.players,
                  this.collisions.terrain
                ]);
              }
            },
            createLevelMap: function() {
              this.map = new MapAtlas(
                this.groups.terrain,
                this.level,
                "combined",
                this.level.useAtlas
              );
              this.map.init();
              this.map.initPhysics(this.collisions);
              _.each(this.level.switches, _.bind(this.createSwitch, this));
            },
            createMissionDialog: function() {
              ui.missionDialog.render(
                function() {
                  this.playerStart();
                  this.startSpeedRun();
                  droneManager.activateTimedRun(this.stopwatch);
                }.bind(this),
                this
              );
            },
            createTrainingDrones: function() {
              droneManager.init(this.player, this.groups, this.collisions);
              droneManager.newDrones();
              droneManager.newHoverDrones();
            },
            startDestructionSequence: function() {
              console.log("startDestructionSequence");
              ui.countdown.start();
              gameState.bonuses.planetBuster = true;
            },
            stopDestructSequence: function() {
              console.log("stopDestructionSequence");
              ui.countdown.stop();
            },
            countdownComplete: function() {
              this.player.alive = false;
              this.player.inPlay = false;
              this.planetDeathTl = new TimelineMax();
              this.planetDeathTl.addCallback(
                this.randomExplosions,
                0,
                null,
                this
              );
              this.planetDeathTl.addCallback(this.destroyPlayer, 3, null, this);
              this.planetDeathTl.addCallback(this.fadeToWhite, 3.5, null, this);
              this.planetDeathTl.addCallback(this.removePlanet, 4, null, this);
              this.planetDeathTl.addCallback(
                game.camera.resetFX,
                5,
                null,
                game.camera
              );
              this.planetDeathTl.addCallback(
                this.levelInterstitialStart,
                8,
                null,
                this
              );
            },
            removePlanet: function() {
              if (gameState.lives <= 0) {
                this.planetDeathTl.kill();
                game.camera.resetFX();
                gameState.isGameOver = true;
              }
              this.groups.actors.removeAll(true);
              this.groups.fuels.removeAll(true);
              this.groups.enemies.removeAll(true);
              this.groups.terrain.removeAll(true);
            },
            randomExplosions: function() {
              var numExplosions = 30;
              var duration = 2e3;
              var pos = new Phaser.Point(
                Math.random() * (game.camera.x + game.camera.width),
                Math.random() * (game.camera.y + game.camera.height)
              );
              particles.explode(pos.x, pos.y);
              sound.playSound(sound.LIMPET_EXPLODE);
              this.explosionsTimer = game.time.events.loop(
                duration / numExplosions,
                function() {
                  var pos = new Phaser.Point(
                    Math.random() * (game.camera.x + game.camera.width),
                    Math.random() * (game.camera.y + game.camera.height)
                  );
                  particles.explode(pos.x, pos.y);
                  sound.playSound(sound.PLAYER_EXPLOSION);
                },
                this
              );
            },
            destroyPlayer: function() {
              if (!gameState.cheats.infiniteLives) {
                gameState.lives--;
              }
              this.player.stop();
              this.player.explosion(true);
            },
            fadeToWhite: function() {
              game.time.events.remove(this.explosionsTimer);
              game.camera.fade(16777215, 740, true);
            },
            createUi: function() {
              var style = {
                font: "16px thrust_regular",
                fill: "#ffffff",
                align: "center",
                backgroundColor: "black"
              };
              if (this.uiPaused) {
                this.uiPaused.destroy();
              }
              this.uiPaused = game.add.text(
                game.width / 2,
                game.height / 2,
                "GAME PAUSED",
                style
              );
              this.uiPaused.anchor.setTo(0.5);
              this.uiPaused.fixedToCamera = true;
              this.uiPaused.visible = false;
              if (features.isTouchScreen) {
                if (this.pauseButton) {
                  this.pauseButton.destroy();
                }
                this.pauseButton = game.add.button(
                  game.width - 10,
                  10,
                  "combined",
                  this.onPauseClick,
                  this,
                  "pause-button.png",
                  "pause-button.png"
                );
                this.pauseButton.anchor.setTo(1, 0);
                this.pauseButton.fixedToCamera = true;
                this.pauseButton.visible = false;
              }
              if (
                game.controls.useVirtualJoypad &&
                !game.controls.useExternalJoypad
              ) {
                game.controls.initVirtualJoypad();
              }
              ui.init(this.menuItemSelected, this);
              if (gameState.trainingMode) {
              }
              ui.countdown.complete.add(this.countdownComplete, this);
            },
            onPauseClick: function() {
              this.escPressed();
              this.pauseButton.onInputUp.remove(this.onPauseClick, this);
              game.input.onDown.add(this.resume, this);
            },
            resume: function() {
              this.escPressed();
              this.pauseButton.onInputUp.add(this.onPauseClick, this);
              game.input.onDown.remove(this.resume, this);
            },
            createSwitch: function(data) {
              var gateSwitch = new Switch(
                this.collisions,
                this.groups,
                this.map,
                data.x,
                data.y,
                data.rotation,
                data.gateDuration
              );
              this.switches.push(gateSwitch);
            },
            createLimpet: function(data) {
              var limpet = new Limpet(
                this.collisions,
                this.groups,
                data.x,
                data.y,
                data.rotation,
                this.player
              );
              limpet.enemiesDestroyed.add(this.allEnemiesDestroyed, this);
              this.limpetGuns.push(limpet);
            },
            allEnemiesDestroyed: function() {
              this.map.allEnemiesDetroyed();
            },
            playerKilled: function() {
              this.stopDestructSequence();
              console.warn("play :: playerKilled lives=", gameState.lives);
              if (gameState.lives === 0 && this.stopwatch) {
                console.warn("hide stopwatch");
                this.stopStopwatch();
                ui.stopwatch.shiftDown();
              }
            },
            earlyInterstitial: function() {
              this.levelInterstitialStart();
            },
            createFuel: function(data) {
              var fuel = new Fuel(
                this.collisions,
                this.groups,
                "combined",
                "fuel.png",
                data.x,
                data.y,
                this.player
              );
              this.fuels.push(fuel);
            },
            createGroupLayering: function() {
              if (this.powerStation) {
                this.groups.actors.add(this.powerStation);
              }
              if (this.orbHolder) {
                this.groups.actors.add(this.orbHolder);
              }
              this.groups.swapTerrain();
              if (!gameState.trainingMode) {
                _.each(
                  this.switches,
                  _.bind(function(gateSwitch) {
                    this.groups.terrain.add(gateSwitch);
                  }, this)
                );
                _.each(
                  this.limpetGuns,
                  _.bind(function(limpet) {
                    this.groups.enemies.add(limpet);
                  }, this)
                );
                _.each(
                  this.fuels,
                  _.bind(function(fuel) {
                    this.groups.fuels.add(fuel);
                  }, this)
                );
              }
              game.world.add(ui.group);
            },
            initialiseDevMode: function() {
              this.isDevMode = true;
              this.cursors = game.controls.cursors;
              this.crossHair = new Phaser.Sprite(
                game,
                game.width / 2,
                game.height / 2,
                "crossHair"
              );
              this.crossHair.anchor.setTo(0.5);
              game.world.add(this.crossHair);
              game.camera.follow(this.crossHair);
            },
            initControls: function() {
              if (
                game.controls.useVirtualJoypad &&
                !game.controls.useExternalJoypad
              ) {
                game.controls.buttonA.onDown.add(this.pressButtonA, this);
                game.controls.buttonA.onUp.add(this.upButtonA, this);
                game.controls.buttonB.onDown.add(this.pressButtonB, this);
                game.controls.buttonB.onUp.add(this.upButtonB, this);
              }
              if (game.controls.useKeys || game.controls.useVirtualJoypad) {
                this.cursors = game.controls.cursors;
                game.controls.spacePress.onDown.add(
                  this.player.fire,
                  this.player
                );
                game.controls.xKey.onDown.add(this.xDown, this);
                game.controls.xKey.onUp.add(this.xUp, this);
                game.controls.esc.onUp.add(this.escPressed, this);
              }
            },
            escPressed: function() {
              game.paused = this.uiPaused.visible = !game.paused;
            },
            pressButtonA: function() {
              this.buttonADown = true;
            },
            upButtonA: function() {
              this.buttonADown = false;
            },
            pressButtonB: function() {
              this.buttonBDown = true;
              this.player.fire();
            },
            upButtonB: function() {
              this.buttonBDown = false;
            },
            xDown: function() {
              this.isXDown = true;
            },
            xUp: function() {
              this.isXDown = false;
              if (!properties.gamePlay.autoOrbLocking) {
                this.tractorBeam.lockingRelease();
              }
            },
            devModeUpdate: function() {
              var slow = function(thisArg) {
                thisArg.crossHairSpeed = 5;
              };
              var fast = function(thisArg) {
                thisArg.crossHairSpeed = 15;
              };
              var point = new Phaser.Point(this.crossHair.x, this.crossHair.y);
              this.checkUp(slow, fast, point);
              this.checkDown(slow, fast, point);
              this.checkLeft(slow, fast, point);
              this.checkRight(slow, fast, point);
              TweenMax.to(this.crossHair, 0.1, {
                x: point.x,
                y: point.y,
                ease: Power0.easeNone
              });
            },
            checkUp: function(slow, fast, point) {
              if (this.cursors.up.isDown) {
                this.cursors.up.shiftKey ? slow(this) : fast(this);
                point.y = this.crossHair.y - this.crossHairSpeed;
              }
            },
            checkDown: function(slow, fast, point) {
              if (this.cursors.down.isDown) {
                this.cursors.down.shiftKey ? slow(this) : fast(this);
                point.y = this.crossHair.y + this.crossHairSpeed;
              }
            },
            checkRight: function(slow, fast, point) {
              if (this.cursors.right.isDown) {
                this.cursors.right.shiftKey ? slow(this) : fast(this);
                point.x = this.crossHair.x + this.crossHairSpeed;
              }
            },
            checkLeft: function(slow, fast, point) {
              if (this.cursors.left.isDown) {
                this.cursors.right.shiftKey ? slow(this) : fast(this);
                point.x = this.crossHair.x - this.crossHairSpeed;
              }
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {
        "../actors/Background": 3,
        "../actors/Fuel": 6,
        "../actors/GateSwitch": 7,
        "../actors/Limpet": 9,
        "../actors/Orb": 10,
        "../actors/PhysicsActor": 11,
        "../actors/Player": 12,
        "../actors/PowerStation": 13,
        "../actors/TractorBeam": 14,
        "../actors/drone-manager": 16,
        "../data/game-state": 18,
        "../data/level-manager": 19,
        "../data/options-model": 20,
        "../environment/Collisions": 22,
        "../environment/Groups": 23,
        "../environment/levels/MapAtlas": 26,
        "../environment/particles/manager": 29,
        "../properties": 31,
        "../ui/Stopwatch": 36,
        "../ui/index": 41,
        "../utils/features": 68,
        "../utils/sound": 71,
        lodash: 1
      }
    ],
    36: [
      function(require, module, exports) {
        "use strict";
        var options = require("../data/options-model");
        var gameState = require("../data/game-state");
        function StopWatch(uiStopwatch) {
          this.uiStopwatch = uiStopwatch;
          this.timer = game.time.create(false);
          this.timer.loop(1, this.update, this);
          if (options.gameModes.speedRun.enabled) {
            this.timerString = gameState.getCachedTimeStr();
            this.cachedTime = gameState.getCachedTime();
            this.uiStopwatch.update(this.timerString);
          }
        }
        var p = StopWatch.prototype;
        p.timer = null;
        p.counter = 0;
        p.timerString = "00:00:00";
        p.cachedTime = 0;
        p.start = function() {
          this.timer.start();
        };
        p.pause = function() {
          this.timer.stop();
        };
        p.stop = function() {
          console.log("Stopwatch :: stop");
          this.timer.pause();
          if (options.gameModes.speedRun.enabled) {
            gameState.cacheTime(this.counter, this.getText());
          }
        };
        p.resume = function() {
          this.timer.resume();
        };
        p.destroy = function() {
          game.time.events.remove(this.timer);
          this.timer = null;
          this.timerString = null;
        };
        p.update = function() {
          this.counter = this.timer.ms + this.cachedTime;
          var mins = Math.floor(this.counter / 6e4) % 60;
          var s = Math.floor(this.counter / 1e3) % 60;
          var ms = Math.floor(this.counter / 10) % 100;
          if (ms < 10) {
            ms = "0" + ms;
          }
          if (s < 10) {
            s = "0" + s;
          }
          if (mins < 10) {
            mins = "0" + mins;
          }
          this.timerString = mins + ":" + s + ":" + ms;
          if (this.uiStopwatch) {
            this.uiStopwatch.update(this.timerString);
          }
        };
        p.getText = function() {
          return this.timerString;
        };
        module.exports = StopWatch;
      },
      { "../data/game-state": 18, "../data/options-model": 20 }
    ],
    37: [
      function(require, module, exports) {
        var gameState = require("../data/game-state");
        var sound = require("../utils/sound");
        module.exports = {
          group: null,
          fuelTf: null,
          currentFuel: 0,
          currentTime: 10,
          complete: null,
          init: function(group) {
            console.log("ui-countdown :: init");
            this.group = group;
            var style = {
              font: "24px thrust_regular",
              fill: "#ff0000",
              align: "left"
            };
            this.label = game.add.text(
              game.width / 2,
              game.height * 0.1,
              this.currentTime,
              style,
              this.group
            );
            this.timer = game.time.create(false);
            this.timer.loop(1e3, this.updateCount, this);
            this.label.visible = false;
            this.complete = new Phaser.Signal();
          },
          updateCount: function() {
            console.log("update count", this.currentTime);
            if (this.currentTime > 0) {
              sound.playSound(sound.UI_COUNTDOWN_SECOND);
              game.camera.shake(0.004, 1e3);
              this.currentTime--;
            } else {
              this.complete.dispatch();
              gameState.planetDestroyed = true;
              this.stop();
            }
            this.label.text = this.currentTime;
          },
          update: function() {},
          start: function() {
            console.log("ui-countdown-start");
            game.camera.shake(0.006, 1e3);
            this.label.visible = true;
            this.timer.start();
            sound.playSound(sound.UI_COUNTDOWN_START, 1, true);
          },
          stop: function() {
            console.log("ui-countdown-stop");
            game.sfx.stop(sound.UI_COUNTDOWN_START);
            this.label.visible = false;
            this.timer.stop(false);
          },
          clear: function() {
            console.log("ui-countdown-clear");
            this.label.visible = false;
            this.currentTime = 10;
          }
        };
      },
      { "../data/game-state": 18, "../utils/sound": 71 }
    ],
    38: [
      function(require, module, exports) {
        var gamepad = require("../subscreens/controls-options-gamepad");
        var touch = require("../subscreens/controls-options-touch");
        var keys = require("../subscreens/controls-options-keys");
        module.exports = {
          getControlsScreen: function() {
            if (game.controls.useVirtualJoypad) {
              return touch;
            } else if (game.controls.useExternalJoypad) {
              return gamepad;
            } else if (game.controls.useKeys) {
              return keys;
            }
          }
        };
      },
      {
        "../subscreens/controls-options-gamepad": 47,
        "../subscreens/controls-options-keys": 48,
        "../subscreens/controls-options-touch": 49
      }
    ],
    39: [
      function(require, module, exports) {
        (function(global) {
          var TweenLite = global.TweenLite;
          module.exports = {
            init: function(group) {
              this.group = game.add.group(group);
              var bmd = game.make.bitmapData(1, 1);
              bmd.rect(0, 0, 1, 1, "rgba(0, 0, 0, 1)");
              this.fader = game.add.sprite(0, 0, bmd);
              this.fader.anchor.setTo(0);
              this.fader.width = game.width;
              this.fader.height = game.height;
              this.group.add(this.fader);
              this.group.fixedToCamera = false;
              this.group.visible = false;
              this.fader.alpha = 0;
            },
            tweenIn: function() {
              this.group.visible = true;
              TweenLite.to(this.fader, 0.3, { alpha: 0.6, ease: Quad.easeIn });
            },
            tweenOut: function() {
              TweenLite.to(this.fader, 0.3, {
                alpha: 0,
                ease: Quad.easeOut,
                onComplete: function() {
                  this.group.visible = false;
                }.bind(this)
              });
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {}
    ],
    40: [
      function(require, module, exports) {
        module.exports = {
          group: null,
          fuelTf: null,
          currentFuel: 0,
          init: function(x, y, group) {
            this.group = group;
            var style = {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "center"
            };
            var fuelLabel = game.add.text(x, y + 5, "Fuel:", style, this.group);
            style.align = "center";
            this.fuelTf = game.add.text(
              x + fuelLabel.width + 5,
              y + 5,
              "999999",
              style,
              this.group
            );
          },
          update: function(fuel, shouldReset) {
            if (shouldReset) {
              this.currentFuel = fuel;
            } else {
              this.currentFuel += fuel;
            }
            this.fuelTf.text = this.currentFuel.toString();
          }
        };
      },
      {}
    ],
    41: [
      function(require, module, exports) {
        var gameState = require("../data/game-state");
        var UIMenu = require("./ui-menu");
        var UIHighScores = require("./ui-high-scores");
        var UIInterstitial = require("./ui-interstitial");
        var UIOptions = require("./ui-options");
        var manager = require("./manager");
        var UILevelsComplete = require("./ui-levels-complete");
        module.exports = {
          playState: null,
          init: function(menuSelectedCallback, playState) {
            this.playState = playState;
            manager.init(this);
            this.group = game.make.group();
            this.fade.init(this.group);
            this.scoreGroup = game.add.group(this.group);
            this.scoreGroup.x = 10;
            this.countdown.init(this.group);
            this.score.init(0, 10, this.scoreGroup);
            this.score.update(gameState.score, true);
            this.fuel.init(0, 30, this.scoreGroup);
            this.fuel.update(gameState.fuel, true);
            this.lives.init(0, 50, this.scoreGroup);
            this.lives.update(gameState.lives, true);
            this.missionSwipe.init(
              0,
              this.lives.textfield.y + this.lives.textfield.height + 10,
              game.width * 0.5,
              game.height * 0.1,
              this.group
            );
            this.interstitial = new UIInterstitial(
              this.group,
              "INTERSTITIAL",
              playState
            );
            this.interstitial.onExitComplete.add(
              this.levelTransitionCompleted,
              this
            );
            this.interstitial.trainingComplete.add(
              this.onTrainingCompleted,
              this
            );
            this.interstitial.levelComplete.add(this.onLevelCompleted, this);
            this.interstitial.trainingFailed.add(this.onTrainingFailed, this);
            this.menu = new UIMenu(
              this.group,
              "MENU",
              menuSelectedCallback,
              playState
            );
            this.highscores = new UIHighScores(
              this.group,
              "HIGH_SCORES",
              playState
            );
            this.options = new UIOptions(this.group, "OPTIONS", playState);
            this.levelsComplete = new UILevelsComplete(
              this.group,
              gameState.PLAY_STATES.COMPLETE,
              playState
            );
            this.missionDialog.init(this.group);
            this.gameOver.init(this.group);
          },
          onTrainingFailed: function() {
            console.log("training not complete, restart training / game over");
            this.playState.gameOver();
          },
          onTrainingCompleted: function() {
            console.log("training complete - return to menu");
            this.playState.gameOver();
          },
          onLevelCompleted: function() {
            this.playState.nextLevel();
          },
          showGameOver: function() {
            this.gameOver.blink();
          },
          removeGameOver: function() {
            this.gameOver.stop();
          },
          drawStopwatch: function() {
            this.stopwatch.init(
              game.width / 2,
              this.score.scoreLabel.y,
              this.scoreGroup
            );
          },
          drawTrainingUi: function() {
            this.drawStopwatch();
            this.score.trainingMode();
          },
          update: function(uiMode) {
            if (uiMode) {
              this.menu.update();
              this.options.update();
            } else {
              this.gameOver.update();
            }
          },
          levelTransitionCompleted: function() {
            this.fade.tweenOut();
          },
          showScreen: function(name, fadeIn) {
            gameState.currentState = name;
            manager.showScreen(name);
            if (fadeIn) {
              this.fade.tweenIn();
            } else {
              this.fade.tweenOut();
            }
          },
          hideUser: function() {
            this.scoreGroup.visible = false;
          },
          showUser: function() {
            this.scoreGroup.visible = true;
          },
          destroy: function() {
            this.group.removeAll(true);
            this.group.destroy();
          },
          gameOver: require("./ui-game-over"),
          stopwatch: require("./ui-stopwatch"),
          fade: require("./fade"),
          missionSwipe: require("./mission-swipe"),
          score: require("./score"),
          fuel: require("./fuel"),
          lives: require("./lives"),
          countdown: require("./countdown"),
          missionDialog: require("./mission-dialog")
        };
      },
      {
        "../data/game-state": 18,
        "./countdown": 37,
        "./fade": 39,
        "./fuel": 40,
        "./lives": 42,
        "./manager": 43,
        "./mission-dialog": 44,
        "./mission-swipe": 45,
        "./score": 46,
        "./ui-game-over": 56,
        "./ui-high-scores": 57,
        "./ui-interstitial": 58,
        "./ui-levels-complete": 59,
        "./ui-menu": 61,
        "./ui-options": 62,
        "./ui-stopwatch": 65
      }
    ],
    42: [
      function(require, module, exports) {
        module.exports = {
          group: null,
          textfield: null,
          currentAmount: 0,
          init: function(x, y, group) {
            this.group = group;
            var style = {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "center"
            };
            var label = game.add.text(x, y + 5, "Ships:", style, this.group);
            style.align = "center";
            this.textfield = game.add.text(
              x + label.width + 5,
              y + 5,
              "5",
              style,
              this.group
            );
          },
          update: function(val, shouldReset) {
            if (shouldReset) {
              this.currentAmount = val;
            } else {
              this.currentAmount += val;
            }
            this.textfield.text = this.currentAmount.toString();
          }
        };
      },
      {}
    ],
    43: [
      function(require, module, exports) {
        var _ = require("lodash");
        module.exports = {
          screens: null,
          subScreens: null,
          init: function(ui) {
            this.ui = ui;
            this.screens = [];
            this.subScreens = [];
          },
          add: function(screen) {
            var existingScreen = _.find(this.screens, { name: screen.name });
            if (!existingScreen) {
              this.screens.push(screen);
            }
          },
          showScreen: function(name, isSubScreen) {
            var screensCheck = isSubScreen ? this.subScreens : this.screens;
            var activeScreen = null;
            _.each(
              screensCheck,
              function(screen) {
                if (screen.name.toLowerCase() === name.toLowerCase()) {
                  activeScreen = screen;
                  activeScreen.showAndAdd();
                } else {
                  screen.hideAndRemove();
                }
              }.bind(this)
            );
            return activeScreen;
          },
          addSubScreen: function(subScreen) {
            this.subScreens.push(subScreen);
          },
          clearSubscreens: function() {
            this.subScreens = [];
          },
          getScreenByName: function(name) {
            var screen = _.find(this.screens, function(screen) {
              return screen.name.toLowerCase() === name.toLowerCase();
            });
            if (!screen) {
              screen = _.find(this.subScreens, function(screen) {
                return screen.name.toLowerCase() === name.toLowerCase();
              });
            }
            if (!screen) {
              throw new Error("Can't find a screen by name", name);
            }
            return screen;
          }
        };
      },
      { lodash: 1 }
    ],
    44: [
      function(require, module, exports) {
        (function(global) {
          var TweenMax = global.TweenMax;
          var textData = require("../data/dialogs");
          var gameState = require("../data/game-state");
          module.exports = {
            joypadFireButton: false,
            dialogCallback: null,
            dialogCallbackContext: null,
            group: null,
            textIndex: 0,
            init: function(group) {
              this.textIndex = 0;
              this.group = game.add.group(group);
              this.initLayout();
              this.textData = textData.training;
            },
            initLayout: function() {
              this.layoutRect = new Phaser.Rectangle(
                0,
                0,
                game.width * 0.8,
                game.height * 0.225
              );
            },
            render: function(dialogCallback, context) {
              this.dialogCallback = dialogCallback;
              this.dialogCallbackContext = context;
              this.renderBg();
              this.renderText();
              this.startTweenIn();
            },
            startTweenIn: function() {
              var toY;
              if (game.controls.useVirtualJoypad) {
                toY = game.height / 2 - this.layoutRect.height / 2;
                this.group.y = -this.layoutRect.height;
              } else {
                toY = game.height - this.layoutRect.height - 20;
                this.group.y = game.height + this.layoutRect.height;
              }
              this.group.x = game.width / 2 - this.group.width / 2;
              TweenMax.to(this.group, 0.25, {
                y: toY,
                ease: Quad.easeOut,
                onComplete: function() {
                  this.enable();
                }.bind(this)
              });
            },
            startTweenOut: function() {
              var toY;
              if (game.controls.useVirtualJoypad) {
                toY = -this.layoutRect.height;
              } else {
                toY = game.height + this.layoutRect.height;
              }
              TweenMax.to(this.group, 0.25, {
                y: toY,
                ease: Quad.easeOut,
                onComplete: function() {
                  this.transitionExitComplete();
                }.bind(this)
              });
            },
            renderBg: function() {
              var lineW = 4;
              var w = this.layoutRect.width;
              var h = this.layoutRect.height;
              var bmd = game.make.bitmapData(1, 1);
              bmd.rect(0, 0, 1, 1, "rgba(0,100,0, 1)");
              this.bg = game.add.sprite(0, 0, bmd, null, this.group);
              this.bg.width = w + lineW * 2;
              this.bg.height = h + lineW * 2;
              this.bg = game.add.sprite(0, 0, bmd, null, this.group);
              this.bg.x = this.layoutRect.x = 0;
              this.bg.y = this.layoutRect.y = 0;
            },
            renderText: function() {
              var style = {
                font: "18px Arial",
                fill: "#fff",
                align: "center",
                boundsAlignH: "center",
                boundsAlignV: "center",
                wordWrap: true,
                wordWrapWidth: this.layoutRect.width - 20
              };
              style.font = this.scaleFontSize(style.font);
              var text = game.add.text(
                0,
                0,
                this.textData[this.textIndex],
                style
              );
              text.setTextBounds(
                10,
                10,
                this.layoutRect.width - 20,
                this.layoutRect.height - 10
              );
              this.group.add(text);
            },
            scaleFontSize: function(style) {
              var fontsizeStr = style.split("px")[0];
              var fontsize = parseInt(fontsizeStr, 10) * gameState.gameScale;
              return style.replace(fontsizeStr, fontsize);
            },
            enable: function() {
              this.enabled = true;
              if (game.controls.useKeys) {
                game.controls.spacePress.onDown.add(this.spacePressed, this);
              }
              if (game.controls.useVirtualJoypad) {
                game.controls.buttonB.onDown.add(this.spacePressed, this);
              }
            },
            disable: function() {
              this.enabled = false;
              if (game.controls.useKeys) {
                game.controls.spacePress.onDown.remove(this.spacePressed, this);
              }
              if (game.controls.useVirtualJoypad) {
                game.controls.buttonB.onDown.remove(this.spacePressed, this);
              }
            },
            spacePressed: function() {
              this.textIndex++;
              this.startTweenOut();
              this.disable();
            },
            transitionExitComplete: function() {
              this.dialogCallback.call(this.dialogCallbackContext);
              this.group.removeAll();
            },
            update: function() {
              game.input.gamepad.pad1.onUpCallback = function(buttonCode) {
                if (buttonCode === Phaser.Gamepad.BUTTON_1) {
                  this.joypadFireButton = true;
                }
              }.bind(this);
              game.input.gamepad.pad1.onDownCallback = function(buttonCode) {
                if (
                  buttonCode === Phaser.Gamepad.BUTTON_1 &&
                  this.joypadFireButton
                ) {
                  this.joypadFireButton = false;
                  this.spacePressed();
                }
              }.bind(this);
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      { "../data/dialogs": 17, "../data/game-state": 18 }
    ],
    45: [
      function(require, module, exports) {
        (function(global) {
          "use strict";
          var levelManager = require("../data/level-manager");
          var sound = require("../utils/sound");
          var TimelineMax = global.TimelineMax;
          module.exports = {
            isReversed: false,
            swipe: null,
            swipeTl: null,
            group: null,
            fullW: 0,
            fullH: 0,
            callback: function() {},
            cbContext: null,
            init: function(x, y, fullWidth, fullHeight, group) {
              var style;
              this.fullW = fullWidth;
              this.fullH = fullHeight;
              this.group = group;
              var level = levelManager.currentLevel;
              var bmd = game.make.bitmapData(1, 1);
              bmd.rect(0, 0, 1, 1, level.missionSwipe.color);
              this.swipe = game.make.sprite(x, y, bmd);
              this.swipe.anchor.setTo(0);
              this.swipe.width = 5;
              this.swipe.height = 5;
              this.group.add(this.swipe);
              this.group.fixedToCamera = true;
              this.isReversed = false;
              console.log("levelIndex=", levelManager.levelIndex);
              console.log("levels.length=", levelManager.levels.length);
              console.log(
                "levels.endlessModeIndex=",
                levelManager.endlessModeIndex
              );
              console.log("levels.endlessCycle=", levelManager.endlessCycle);
              var levelNo =
                levelManager.levelIndex +
                1 +
                levelManager.levels.length * levelManager.endlessModeIndex +
                levelManager.endless.length * levelManager.endlessCycle;
              console.log("levels.levelNo = ", levelNo);
              var title = level.missionSwipe.title.replace(
                "%n",
                levelNo.toString()
              );
              var repl1 = levelManager.endlessData.flip
                ? "\nReverse Gravity"
                : "";
              var repl2 = levelManager.endlessData.blink ? "\nBlink Map" : "";
              var desc;
              desc = level.missionSwipe.desc.replace("%s1", repl1);
              desc = desc.replace("%s2", repl2);
              style = {
                font: "24px thrust_regular",
                fill: "#ffffff",
                align: "left"
              };
              this.title = game.add.text(
                x + 5,
                y + 5,
                title,
                style,
                this.group
              );
              style = {
                font: "12px thrust_regular",
                fill: "#ffffff",
                align: "left"
              };
              this.desc = game.add.text(
                this.title.x,
                this.title.y + this.title.height + 2,
                desc,
                style,
                this.group
              );
              this.fullH = (this.desc.y + this.desc.height - this.title.y) * 2;
              this.hideSwipe();
              this.tl = new TimelineMax({
                delay: 0.2,
                onComplete: this.missionStartSwipeOut,
                callbackScope: this,
                onReverseComplete: this.missionReady
              });
              this.tl.add(
                TweenMax.to(this.swipe, 0.2, { alpha: 1, ease: Quad.easeOut })
              );
              this.tl.add(
                TweenMax.to(this.swipe, 0.2, {
                  height: this.fullH,
                  ease: Quad.easeOut
                })
              );
              this.tl.add(
                function() {
                  if (this.isReversed) {
                    sound.playSound(sound.UI_SWIPE_OUT);
                  } else {
                    sound.playSound(sound.UI_SWIPE_IN);
                  }
                }.bind(this)
              );
              this.tl.add(
                TweenMax.to(this.swipe, 0.4, {
                  width: this.fullW,
                  ease: Quad.easeOut
                })
              );
              this.tl.add(
                TweenMax.to(this.title, 0.25, { alpha: 1, ease: Quad.easeOut })
              );
              this.tl.add(
                TweenMax.to(this.desc, 0.25, { alpha: 1, ease: Quad.easeOut })
              );
              this.tl.add(TweenMax.to(this, 1));
              this.tl.pause();
            },
            hideSwipe: function() {
              this.title.alpha = 0;
              this.title.visible = false;
              this.desc.alpha = 0;
              this.desc.visibe = false;
              this.swipe.visible = false;
              this.swipe.alpha = 0;
            },
            showSwipe: function() {
              this.title.visible = true;
              this.desc.visibe = true;
              this.swipe.visible = true;
            },
            missionStartSwipeIn: function(callback, context) {
              this.callback = callback;
              this.cbContext = context;
              this.showSwipe();
              this.tl.play();
            },
            missionStartSwipeOut: function() {
              this.isReversed = true;
              this.tl.reverse();
            },
            missionReady: function() {
              this.hideSwipe();
              this.callback.call(this.cbContext);
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      { "../data/level-manager": 19, "../utils/sound": 71 }
    ],
    46: [
      function(require, module, exports) {
        module.exports = {
          group: null,
          scoreLabel: null,
          scoreTf: null,
          currentScore: 0,
          init: function(x, y, group) {
            this.group = group;
            var style = {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "center"
            };
            this.scoreLabel = game.add.text(
              x,
              y + 5,
              "Score:",
              style,
              this.group
            );
            style.align = "center";
            this.scoreTf = game.add.text(
              x + this.scoreLabel.width + 5,
              y + 5,
              "999999",
              style,
              this.group
            );
          },
          trainingMode: function() {
            this.scoreLabel.text = "Drones: ";
            this.scoreTf.x = this.scoreLabel.width + 5;
          },
          update: function(score, override) {
            if (override) {
              this.currentScore = score;
            } else {
              this.currentScore += score;
            }
            this.scoreTf.text = this.currentScore.toString();
          }
        };
      },
      {}
    ],
    47: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var p = (ControlOptions.prototype = Object.create(
          UiComponent.prototype,
          { constructor: ControlOptions }
        ));
        module.exports = ControlOptions;
        p.group = null;
        function ControlOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var spr = game.add.sprite(
            0,
            0,
            "combined",
            "gamepad.png",
            this.group
          );
          spr.anchor.setTo(0.5);
          if (this.isFullLayout) {
            spr.scale.setTo(1.5);
          }
          spr.x = this.layoutRect.width * 0.5;
          spr.y = this.layoutRect.height * 0.5;
          var text1 = game.add.text(
            0,
            0,
            "ROTATE\nRIGHT",
            this.style,
            this.group
          );
          var text2 = game.add.text(
            0,
            0,
            "ROTATE\nLEFT",
            this.style,
            this.group
          );
          var text3 = game.add.text(0, 0, "THRUST", this.style, this.group);
          var text4 = game.add.text(0, 0, "FIRE", this.style, this.group);
          text1.anchor.setTo(0.5);
          text2.anchor.setTo(0.5);
          text1.x = this.layoutRect.halfWidth * 0.5;
          text1.y = this.layoutRect.height * 0.3;
          text2.x = this.layoutRect.halfWidth * 0.45;
          text2.y = this.layoutRect.height * 0.45;
          text3.x = this.layoutRect.width * 0.7;
          text3.y = this.layoutRect.height * 0.3;
          text4.x = this.layoutRect.width * 0.7;
          text4.y = this.layoutRect.height * 0.4;
          var graphics = game.add.graphics(0, 0, this.group);
          graphics.lineStyle(1, 16711878, 1);
          var fraction = spr.height * 0.007;
          var buttonRightPos = new Phaser.Point(
            spr.x - spr.width * 0.075,
            spr.y + spr.height * 0.06
          );
          var buttonLeftPos = new Phaser.Point(
            spr.x - spr.width * 0.14,
            buttonRightPos.y
          );
          var aButtonPos = new Phaser.Point(
            spr.x + spr.width * 0.23,
            spr.y - spr.height * 0.05
          );
          var bButtonPos = new Phaser.Point(
            spr.x + spr.width * 0.3,
            spr.y - spr.height * 0.15
          );
          var coords = [
            { x: text1.x + text1.width * 0.5, y: text1.y },
            { x: buttonLeftPos.x, y: text1.y },
            { x: buttonLeftPos.x, y: buttonLeftPos.y - fraction },
            { x: text2.x, y: text2.y + text2.height * 0.5 },
            { x: text2.x, y: buttonRightPos.y + fraction },
            { x: buttonRightPos.x, y: buttonRightPos.y + fraction },
            { x: text3.x, y: text3.y + text3.height * 0.5 },
            { x: bButtonPos.x, y: text3.y + text3.height * 0.5 },
            { x: bButtonPos.x, y: bButtonPos.y },
            { x: text4.x + text4.width * 0.5, y: text4.y + text4.height * 0.5 },
            { x: text4.x + text4.width * 0.5, y: aButtonPos.y },
            { x: aButtonPos.x, y: aButtonPos.y }
          ];
          graphics.moveTo(coords[0].x, coords[0].y);
          graphics.lineTo(coords[1].x, coords[1].y);
          graphics.lineTo(coords[2].x, coords[2].y);
          graphics.moveTo(coords[3].x, coords[3].y);
          graphics.lineTo(coords[4].x, coords[4].y);
          graphics.lineTo(coords[5].x, coords[5].y);
          graphics.moveTo(coords[6].x, coords[6].y);
          graphics.lineTo(coords[7].x, coords[7].y);
          graphics.lineTo(coords[8].x, coords[8].y);
          graphics.moveTo(coords[9].x, coords[9].y);
          graphics.lineTo(coords[10].x, coords[10].y);
          graphics.lineTo(coords[11].x, coords[11].y);
          var gamePadEnabled = new UiSwitch(this.group, "GAMEPAD ENABLED");
          gamePadEnabled.render();
          gamePadEnabled.group.x =
            this.layoutRect.halfWidth - gamePadEnabled.originPos.x;
          gamePadEnabled.group.y = this.layoutRect.height * 0.8;
          this.components.push(gamePadEnabled);
        };
        p.renderDefaults = function() {};
        p.dispose = function() {
          _.each(this.components, function(component) {});
          UiComponent.prototype.dispose.call(this);
        };
        p.virtualJoypadOn = function() {
          optionsModel.controls.virtualJoypad = true;
        };
        p.virtualJoypadOff = function() {
          optionsModel.controls.virtualJoypad = false;
        };
      },
      {
        "../../data/options-model": 20,
        "../ui-component": 55,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    48: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var p = (ControlOptions.prototype = Object.create(
          UiComponent.prototype,
          { constructor: ControlOptions }
        ));
        module.exports = ControlOptions;
        p.group = null;
        function ControlOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var leftTexts = [
            "ROTATE LEFT",
            "ROTATE RIGHT",
            "THRUST",
            "FIRE",
            "PAUSE"
          ];
          var leftText;
          var fraction = this.layoutRect.height * 0.05;
          _.each(
            leftTexts,
            function(str, index) {
              leftText = game.add.text(0, 0, str, this.style, this.group);
              leftText.anchor.setTo(1, 0);
              leftText.x = this.layoutRect.width * 0.45;
              leftText.y =
                this.marginTop + index * (leftText.height + fraction);
            }.bind(this)
          );
          var rightTexts = [
            "LEFT ARROW",
            "RIGHT ARROW",
            "UP ARROW",
            "SPACE",
            "ESC"
          ];
          var rightText;
          _.each(
            rightTexts,
            function(str, index) {
              leftText = game.add.text(0, 0, str, this.style, this.group);
              leftText.anchor.setTo(0, 0);
              leftText.x = this.layoutRect.width * 0.55;
              leftText.y =
                this.marginTop + index * (leftText.height + fraction);
            }.bind(this)
          );
        };
        p.renderDefaults = function() {};
        p.dispose = function() {
          _.each(this.components, function(component) {
            component.switchOn.removeAll();
            component.switchOff.removeAll();
          });
          UiComponent.prototype.dispose.call(this);
        };
        p.virtualJoypadOn = function() {
          optionsModel.controls.virtualJoypad = true;
        };
        p.virtualJoypadOff = function() {
          optionsModel.controls.virtualJoypad = false;
        };
      },
      {
        "../../data/options-model": 20,
        "../ui-component": 55,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    49: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var user;
        var p = (ControlOptions.prototype = Object.create(
          UiComponent.prototype,
          { constructor: ControlOptions }
        ));
        module.exports = ControlOptions;
        p.group = null;
        p.marginTop = 0;
        function ControlOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var style = this.getStyle();
          var rightAlignedStyle = _.clone(style);
          rightAlignedStyle.align = "right";
          var centerStyle = _.clone(style);
          centerStyle.align = "center";
          var text1 = game.add.text(0, 0, "ROTATE\nLEFT", style, this.group);
          var text2 = game.add.text(
            0,
            0,
            "ROTATE\nRIGHT",
            rightAlignedStyle,
            this.group
          );
          var text3 = game.add.text(0, 0, "THRUST", style, this.group);
          var text4 = game.add.text(0, 0, "FIRE", style, this.group);
          text1.x = this.layoutRect.halfWidth * 0.05;
          text1.y = this.layoutRect.height * 0.45;
          text2.x = this.layoutRect.halfWidth * 0.45;
          text2.y = this.layoutRect.height * 0.45;
          text3.x = this.layoutRect.width * 0.65;
          text3.y = this.layoutRect.height * 0.6;
          text4.x = this.layoutRect.width * 0.85;
          text4.y = this.layoutRect.height * 0.5;
          var graphics = game.add.graphics(0, 0, this.group);
          graphics.lineStyle(1, 16711878, 1);
          var dpad = game.controls.stick;
          var aButton = game.controls.buttonA;
          var bButton = game.controls.buttonB;
          var buttonLeftPos = new Phaser.Point(
            dpad.posX - dpad.sprite.width * 0.25 - this.group.parent.position.x,
            dpad.posY - this.group.parent.position.y
          );
          var buttonRightPos = new Phaser.Point(
            dpad.posX + dpad.sprite.width * 0.25 - this.group.parent.position.x,
            buttonLeftPos.y
          );
          var aButtonPos = new Phaser.Point(
            aButton.posX - this.group.parent.position.x,
            aButton.posY - this.group.parent.position.y
          );
          var bButtonPos = new Phaser.Point(
            bButton.posX - this.group.parent.position.x,
            bButton.posY - this.group.parent.position.y
          );
          var coords = [
            { x: text1.x + text1.width * 0.5, y: text1.y + text1.height },
            { x: buttonLeftPos.x, y: text1.y + text1.height },
            { x: buttonLeftPos.x, y: buttonLeftPos.y },
            { x: text2.x + text2.width * 0.5, y: text2.y + text2.height },
            { x: text2.x + text2.width * 0.5, y: buttonRightPos.y },
            { x: buttonRightPos.x, y: buttonRightPos.y },
            { x: text3.x + text3.width * 0.5, y: text3.y + text3.height },
            { x: text3.x + text3.width * 0.5, y: aButtonPos.y },
            { x: aButtonPos.x, y: aButtonPos.y },
            { x: text4.x + text4.width * 0.5, y: text4.y + text4.height },
            { x: text4.x + text4.width * 0.5, y: bButtonPos.y },
            { x: bButtonPos.x, y: bButtonPos.y }
          ];
          graphics.moveTo(coords[0].x, coords[0].y);
          graphics.lineTo(coords[1].x, coords[1].y);
          graphics.lineTo(coords[2].x, coords[2].y);
          graphics.moveTo(coords[3].x, coords[3].y);
          graphics.lineTo(coords[4].x, coords[4].y);
          graphics.lineTo(coords[5].x, coords[5].y);
          graphics.moveTo(coords[6].x, coords[6].y);
          graphics.lineTo(coords[7].x, coords[7].y);
          graphics.lineTo(coords[8].x, coords[8].y);
          graphics.moveTo(coords[9].x, coords[9].y);
          graphics.lineTo(coords[10].x, coords[10].y);
          graphics.lineTo(coords[11].x, coords[11].y);
          var style = this.getStyle();
          var helperTxt = game.add.text(
            0,
            0,
            "Control ship using the virutual joypad\nConnect joypad and restart app\nto enable joypad",
            centerStyle,
            this.group
          );
          helperTxt.anchor.setTo(0.5);
          helperTxt.x = this.layoutRect.halfWidth;
          helperTxt.y = this.marginTop;
        };
        p.renderDefaults = function() {};
        p.dispose = function() {
          _.each(this.components, function(component) {});
          UiComponent.prototype.dispose.call(this);
        };
        p.virtualJoypadOn = function() {
          game.controls.show();
          optionsModel.controls.virtualJoypad = true;
        };
        p.virtualJoypadOff = function() {
          game.controls.hide();
          optionsModel.controls.virtualJoypad = false;
        };
      },
      {
        "../../data/options-model": 20,
        "../ui-component": 55,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    50: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var p = (DisplayOptions.prototype = Object.create(
          UiComponent.prototype,
          { constructor: DisplayOptions }
        ));
        module.exports = DisplayOptions;
        p.group = null;
        function DisplayOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var paddingFaction = this.layoutRect.height * 0.025;
          var switches = ["FULL SCREEN", "PARTICLE FX", "BACKGROUND", "FPS 60"];
          var x = this.isFullLayout ? 0.5 : 0.5;
          _.each(
            switches,
            function(name, index) {
              var lock = false;
              if (name === "FULL SCREEN" && !game.device.fullscreen) {
                lock = true;
              }
              var uiSwitch = new UiSwitch(this.group, name, lock);
              uiSwitch.render();
              uiSwitch.group.x =
                this.layoutRect.width * x - uiSwitch.originPos.x;
              uiSwitch.group.y =
                this.marginTop +
                (uiSwitch.group.height + paddingFaction) * index;
              uiSwitch.switchedOn.add(this.onSwitch, this, 0, name);
              uiSwitch.switchedOff.add(this.offSwitch, this, 0, name);
              this.components.push(uiSwitch);
            }.bind(this)
          );
        };
        p.onSwitch = function(name) {
          switch (name) {
            case "FPS 60":
              this.fpsToggleOn();
              break;
            case "FULL SCREEN":
              this.fullscreenOn();
              break;
            case "PARTICLE FX":
              this.particlesOn();
              break;
            case "BACKGROUND":
              this.backgroundOn();
              break;
          }
        };
        p.offSwitch = function(name) {
          switch (name) {
            case "FPS 60":
              this.fpsToggleOff();
              break;
            case "FULL SCREEN":
              this.fullscreenOff();
              break;
            case "PARTICLE FX":
              this.particlesOff();
              break;
            case "BACKGROUND":
              this.backgroundOff();
              break;
          }
        };
        p.fpsToggleOn = function() {
          optionsModel.display.fps = 60;
          game.time.desiredFps = optionsModel.display.fps;
          console.warn("fpsToggleOn :: FPS", optionsModel.display.fps);
          var fpsSwitch = this.getComponentByName("FPS 60");
          fpsSwitch.label.text = "FPS 60";
        };
        p.fpsToggleOff = function() {
          optionsModel.display.fps = 30;
          game.time.desiredFps = optionsModel.display.fps;
          console.warn("fpsToggleOff :: FPS", optionsModel.display.fps);
          var fpsSwitch = this.getComponentByName("FPS 60");
          fpsSwitch.label.text = "FPS 30";
        };
        p.update = function() {
          var uiSwitch = this.getComponentByName("FULL SCREEN");
          if (!uiSwitch) return;
          if (game.scale.isFullScreen) {
            uiSwitch.switchOn(true);
          } else {
            uiSwitch.switchOff(true);
          }
        };
        p.fullscreenOn = function() {
          optionsModel.display.fullscreen = true;
          game.scale.startFullScreen(false);
        };
        p.fullscreenOff = function() {
          optionsModel.display.fullscreen = false;
          game.scale.stopFullScreen();
        };
        p.particlesOn = function() {
          optionsModel.display.fx.particles = true;
          optionsModel.fxParticlesOn.dispatch();
        };
        p.backgroundOn = function() {
          optionsModel.display.fx.background = true;
          optionsModel.fxBackgroundOn.dispatch();
        };
        p.particlesOff = function() {
          optionsModel.display.fx.particles = false;
          optionsModel.fxParticlesOff.dispatch();
        };
        p.backgroundOff = function() {
          optionsModel.display.fx.background = false;
          optionsModel.fxBackgroundOff.dispatch();
        };
        p.renderDefaults = function() {
          var particlesSwitch = this.getComponentByName("PARTICLE FX");
          var backgroundSwitch = this.getComponentByName("BACKGROUND");
          var fpsSwitch = this.getComponentByName("FPS 60");
          if (optionsModel.display.fx.background) {
            backgroundSwitch.switch(true);
          }
          if (optionsModel.display.fx.particles) {
            particlesSwitch.switch(true);
          }
          if (optionsModel.display.fps === 60) {
            fpsSwitch.switch(true);
            fpsSwitch.label.text = "FPS 60";
          } else {
            fpsSwitch.label.text = "FPS 30";
          }
        };
        p.dispose = function() {
          _.each(this.components, function(component) {});
          UiComponent.prototype.dispose.call(this);
        };
      },
      {
        "../../data/options-model": 20,
        "../ui-component": 55,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    51: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var UiSelect = require("../ui-select");
        var p = (GeneralOptions.prototype = Object.create(
          UiComponent.prototype,
          { constructor: GeneralOptions }
        ));
        module.exports = GeneralOptions;
        p.group = null;
        function GeneralOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.levelsSelected = function(option) {
          console.log("levelsSelected=", option);
          optionsModel.setLevels(option);
          if (optionsModel.gameModes.levels.dirty) {
            optionsModel.gameModes.levels.current = option;
            optionsModel.loadNewLevels.dispatch();
          }
        };
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.currentOptionIndex = function(optionsData) {
          _.findIndex(optionsData, function(data) {
            return data.value === optionsModel.gameModes.levels.current;
          });
        };
        p.createDisplay = function() {
          var paddingFaction = this.layoutRect.height * 0.025;
          var optionsData = [
            { str: "Classic Levels", value: "classic" },
            { str: "2016 Levels", value: "2016" }
          ];
          var speedRunLocked = !optionsModel.gameModes.speedRun.unlocked;
          var endlessLocked = !optionsModel.gameModes.endlessMode.unlocked;
          var gravitySwitchIsEnabled = optionsModel.gameModes.gravity.unlocked;
          var style = this.getStyle();
          if (speedRunLocked || endlessLocked) {
            this.lockedInfo = game.add.text(
              this.layoutRect.halfWidth,
              this.marginTop,
              "Purchase More Levels to Unlock Game Modes",
              style,
              this.group
            );
            this.lockedInfo.anchor.setTo(0.5);
          }
          var switch1 = new UiSwitch(this.group, "Speed Run", speedRunLocked);
          switch1.render();
          var switch2 = new UiSwitch(this.group, "Endless", endlessLocked);
          switch2.render();
          var switch3 = new UiSwitch(
            this.group,
            "Strong gravity",
            !gravitySwitchIsEnabled
          );
          switch3.render();
          switch1.group.x = this.layoutRect.width * 0.5 - switch1.originPos.x;
          switch1.group.y = this.lockedInfo
            ? this.lockedInfo.y + this.lockedInfo.height + paddingFaction
            : this.marginTop;
          switch1.switchedOn.add(this.speedRunOn, this);
          switch1.switchedOff.add(this.speedRunOff, this);
          this.components.push(switch1);
          switch2.group.x = this.layoutRect.width * 0.5 - switch2.originPos.x;
          switch2.group.y =
            switch1.group.y + switch1.group.height + paddingFaction;
          switch2.switchedOn.add(this.endlessOn, this);
          switch2.switchedOff.add(this.endlessOff, this);
          this.components.push(switch2);
          switch3.group.x = this.layoutRect.width * 0.5 - switch3.originPos.x;
          switch3.group.y =
            switch2.group.y + switch2.group.height + paddingFaction;
          switch3.switchedOn.add(this.heavyGravityOn, this);
          switch3.switchedOff.add(this.lightGravityOn, this);
          this.components.push(switch3);
        };
        p.heavyGravityOn = function() {
          optionsModel.gameModes.gravity.enabled = true;
        };
        p.lightGravityOn = function() {
          optionsModel.gameModes.gravity.enabled = false;
        };
        p.renderDefaults = function() {
          var endlessSwitch = this.getComponentByName("Endless");
          if (optionsModel.gameModes.endlessMode.enabled) {
            endlessSwitch.switch(true);
          }
          var speedRunSwitch = this.getComponentByName("Speed Run");
          if (optionsModel.gameModes.speedRun.enabled) {
            speedRunSwitch.switch(true);
          }
        };
        p.speedRunOn = function() {
          optionsModel.gameModes.speedRun.enabled = true;
        };
        p.speedRunOff = function() {
          optionsModel.gameModes.speedRun.enabled = false;
          console.warn("speedRunOff", optionsModel);
        };
        p.endlessOn = function() {
          console.info("endlessOn", optionsModel);
          optionsModel.gameModes.endlessMode.enabled = true;
        };
        p.endlessOff = function() {
          console.info("endlessOff", optionsModel);
          optionsModel.gameModes.endlessMode.enabled = false;
        };
        p.resetHighScores = function() {
          window.localStorage.clear();
        };
        p.dispose = function() {
          _.each(this.components, function(component) {
            component.dispose();
          });
          UiComponent.prototype.dispose.call(this);
        };
        p.update = function() {
          if (this.uiSelect) {
            this.uiSelect.update();
          }
        };
      },
      {
        "../../data/options-model": 20,
        "../ui-component": 55,
        "../ui-select": 64,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    52: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var gameState = require("../../data/game-state");
        var UiSelect = require("../ui-select");
        var properties = require("../../properties");
        var levelManager = require("../../data/level-manager");
        var p = (Sandbox.prototype = Object.create(UiComponent.prototype, {
          constructor: Sandbox
        }));
        module.exports = Sandbox;
        p.group = null;
        function Sandbox(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var paddingFaction = this.layoutRect.height * 0.025;
          var switch1 = new UiSwitch(this.group, "Infinite Lives");
          switch1.render();
          var switch2 = new UiSwitch(this.group, "Infinite Fuel");
          switch2.render();
          var switch3 = new UiSwitch(this.group, "Collision Hack");
          switch3.render();
          var optionsData = _.map(levelManager.levels, function(level, index) {
            var level = parseInt(index + 1, 10);
            return { str: "LEVEL " + level, value: index };
          });
          this.uiSelect = new UiSelect(
            this.group,
            "Starting Level:",
            optionsData
          );
          this.uiSelect.optionSelected.add(this.startLevelSelected, this);
          this.uiSelect.render();
          this.uiSelect.overrideUserControl.add(
            function() {
              this.overrideUserControl.dispatch();
            }.bind(this),
            this
          );
          this.uiSelect.restoreUserControl.add(
            function() {
              this.restoreUserControl.dispatch();
            }.bind(this),
            this
          );
          switch1.group.x = this.layoutRect.width * 0.5 - switch1.originPos.x;
          switch1.group.y = this.marginTop;
          switch1.switchedOn.add(this.infiniteLivesOn, this);
          switch1.switchedOff.add(this.infiniteLivesOff, this);
          this.components.push(switch1);
          switch2.group.x = this.layoutRect.width * 0.5 - switch2.originPos.x;
          switch2.group.y =
            switch1.group.y + switch1.group.height + paddingFaction;
          switch2.switchedOn.add(this.infiniteFuelOn, this);
          switch2.switchedOff.add(this.infiniteFuelOff, this);
          this.components.push(switch2);
          switch3.group.x = this.layoutRect.width * 0.5 - switch3.originPos.x;
          switch3.group.y =
            switch2.group.y + switch2.group.height + paddingFaction;
          switch3.switchedOn.add(this.fatalCollisionsOff, this);
          switch3.switchedOff.add(this.fatalCollisionsOn, this);
          this.components.push(switch3);
          this.uiSelect.group.x = this.layoutRect.width * 0.3;
          this.uiSelect.group.y =
            switch3.group.y + switch3.group.height + paddingFaction * 4;
          this.components.push(this.uiSelect);
        };
        p.startLevelSelected = function(val) {
          if (levelManager.setNewLevel(val)) {
            gameState.cheats.startDebugLevel = true;
          }
        };
        p.infiniteLivesOn = function() {
          gameState.cheats.infiniteLives = true;
        };
        p.infiniteLivesOff = function() {
          gameState.cheats.infiniteLives = false;
        };
        p.infiniteFuelOn = function() {
          gameState.cheats.infiniteFuel = true;
        };
        p.infiniteFuelOff = function() {
          gameState.cheats.infiniteFuel = false;
        };
        p.fatalCollisionsOff = function() {
          gameState.cheats.fatalCollisions = false;
        };
        p.fatalCollisionsOn = function() {
          gameState.cheats.fatalCollisions = true;
        };
        p.renderDefaults = function() {};
        p.dispose = function() {
          _.each(this.components, function(component) {
            component.dispose();
          });
          UiComponent.prototype.dispose.call(this);
        };
        p.update = function() {};
      },
      {
        "../../data/game-state": 18,
        "../../data/level-manager": 19,
        "../../data/options-model": 20,
        "../../properties": 31,
        "../ui-component": 55,
        "../ui-select": 64,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    53: [
      function(require, module, exports) {
        var _ = require("lodash");
        var UiComponent = require("../ui-component");
        var UiSwitch = require("../ui-switch");
        var optionsModel = require("../../data/options-model");
        var sound = require("../../utils/sound");
        var p = (SoundOptions.prototype = Object.create(UiComponent.prototype, {
          constructor: SoundOptions
        }));
        module.exports = SoundOptions;
        p.group = null;
        function SoundOptions(group, name, layoutRect) {
          UiComponent.call(this, group, name, true, false);
          this.layoutRect = layoutRect;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.renderDefaults();
        };
        p.createDisplay = function() {
          var paddingFraction = this.layoutRect.height * 0.025;
          var switch1 = new UiSwitch(this.group, "Music");
          switch1.render();
          switch1.group.x = this.layoutRect.halfWidth - switch1.originPos.x;
          switch1.group.y = this.marginTop;
          switch1.switchedOn.add(this.musicOn, this);
          switch1.switchedOff.add(this.musicOff, this);
          var switch2 = new UiSwitch(this.group, "Sound FX");
          switch2.render();
          switch2.group.x = this.layoutRect.halfWidth - switch2.originPos.x;
          switch2.group.y =
            switch1.group.y + switch1.group.height + paddingFraction;
          switch2.switchedOn.add(this.soundOn, this);
          switch2.switchedOff.add(this.soundOff, this);
          this.components = [switch1, switch2];
        };
        p.renderDefaults = function() {
          if (optionsModel.sound.soundFx) {
            this.components[1].switch(true);
          }
          if (optionsModel.sound.music) {
            this.components[0].switch(true);
          }
        };
        p.soundOn = function() {
          optionsModel.sound.soundFx = true;
        };
        p.soundOff = function() {
          optionsModel.sound.soundFx = false;
        };
        p.musicOn = function() {
          optionsModel.sound.music = true;
        };
        p.musicOff = function() {
          sound.stopMusic();
          optionsModel.sound.music = false;
        };
        p.dispose = function() {
          _.each(this.components, function(component) {});
          UiComponent.prototype.dispose.call(this);
        };
      },
      {
        "../../data/options-model": 20,
        "../../utils/sound": 71,
        "../ui-component": 55,
        "../ui-switch": 66,
        lodash: 1
      }
    ],
    54: [
      function(require, module, exports) {
        module.exports = UiButton;
        var canvas = require("../utils/canvas");
        var UiComponent = require("./ui-component");
        function UiButton(group, name) {
          UiComponent.call(this, group, name, true, false);
          this.label = this.name;
          this.onItemSelected = new Phaser.Signal();
        }
        var p = (UiButton.prototype = Object.create(UiComponent.prototype, {
          constructor: UiButton
        }));
        p.margin = 2;
        p.padding = 10;
        p.selectionPadding = 5;
        p.leftPressed = false;
        p.rightPressed = false;
        p.onItemSelected = null;
        p.buttonElements = {};
        p.gamepadSelector = null;
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.drawItem();
          this.drawSelector();
          this.initEvents();
        };
        p.drawPosition = p.padding + p.margin;
        p.drawItem = function() {
          var text = game.make.text(0, 0, this.label, this.getDarkStyle());
          var x = this.selectionPadding,
            y = this.selectionPadding;
          var width = text.width + this.padding * 2;
          var height = text.height + this.padding * 2;
          var backgroundSkin = game.make.bitmapData(width, height);
          backgroundSkin.ctx.fillStyle = "rgba(225, 225, 225, 0.7)";
          canvas.drawRoundRect(
            backgroundSkin.ctx,
            0,
            0,
            width,
            height,
            5,
            true,
            false
          );
          var spr = game.add.sprite(x, y, backgroundSkin, "", this.group);
          text.x = spr.x + this.padding;
          text.y = spr.y + this.padding * 1.25;
          this.group.add(text);
          this.buttonElements = { id: this.label, tf: text, spr: spr };
        };
        p.drawSelector = function() {
          var w = this.group.width + this.selectionPadding * 2,
            h = this.group.height + this.selectionPadding * 2;
          var selector = game.make.bitmapData(w, h);
          selector.ctx.translate(0.5, 0.5);
          selector.ctx.beginPath();
          selector.ctx.strokeStyle = "#ffffff";
          selector.ctx.lineWidth = 2;
          selector.ctx.setLineDash([3, 2]);
          canvas.drawRoundRect(
            selector.ctx,
            2,
            2,
            w - 4,
            h - 4,
            2,
            false,
            true
          );
          var bg = this.buttonElements.spr;
          this.gamepadSelector = game.add.sprite(
            bg.x - this.selectionPadding,
            bg.y - this.selectionPadding,
            selector,
            "",
            this.group
          );
          this.userDeselected();
        };
        p.userSelected = function() {
          this.gamepadSelector.alpha = 1;
        };
        p.userDeselected = function() {
          this.gamepadSelector.alpha = 0;
        };
        p.hideSelectionBackground = function() {
          this.buttonElements.spr.alpha = 0;
        };
        p.initEvents = function() {
          var spr = this.buttonElements.spr;
          spr.inputEnabled = true;
          spr.useHandCursot = true;
          spr.events.onInputDown.add(
            this.componentMouseDown,
            this,
            0,
            this.buttonElements.id
          );
        };
        p.dispose = function() {
          var spr = this.buttonElements.spr;
          spr.inputEnabled = false;
          spr.useHandCursot = false;
          spr.events.onInputDown.remove(this.componentMouseDown, this);
          this.onItemSelected.removeAll();
          this.onItemSelected = null;
        };
        p.componentMouseDown = function(arg1, arg2, id) {
          this.selectOption(id);
        };
        p.apiSelect = function() {
          this.selectOption(this.buttonElements.id);
        };
        p.selectOption = function(id) {
          this.onItemSelected.dispatch(id, this);
        };
        p.selectComponent = function() {
          var component = this.buttonElements;
          component.spr.tint = 5354301;
        };
        p.deselectComponent = function() {
          var component = this.buttonElements;
          component.spr.tint = 16777215;
        };
      },
      { "../utils/canvas": 67, "./ui-component": 55 }
    ],
    55: [
      function(require, module, exports) {
        var manager = require("./manager");
        var _ = require("lodash");
        function UiComponent(group, name, shouldAddNewGroup, shouldAutoManage) {
          this.group = shouldAddNewGroup ? game.add.group(group) : group;
          this.name = this.group.name = name;
          if (shouldAutoManage) {
            manager.add(this);
          }
          this.components = [];
          this.overrideUserControl = new Phaser.Signal();
          this.restoreUserControl = new Phaser.Signal();
        }
        var p = (UiComponent.prototype = Object.create(UiComponent.prototype, {
          constructor: UiComponent
        }));
        module.exports = UiComponent;
        UiComponent.VERTICAL = "VERTICAL";
        UiComponent.HORIZONTAL = "HORIZONTAL";
        p.group = null;
        p.style = {
          font: "16px thrust_regular",
          fill: "#ffffff",
          align: "left"
        };
        p.darkStyle = {
          font: "16px thrust_regular",
          fill: "#000000",
          align: "left"
        };
        p.minStyle = {
          font: "10px thrust_regular",
          fill: "#ffffff",
          align: "left"
        };
        p.darkMinStyle = {
          font: "10px thrust_regular",
          fill: "#000000",
          align: "left"
        };
        p.isFullLayout = false;
        p.name = "not set";
        p.preventAutoEnable = false;
        p.isRendered = false;
        p.components = [];
        p.layoutRect = new Phaser.Rectangle(0, 0, 10, 10);
        p.marginTop = 0;
        p.isActive = false;
        p.addAsSubScreen = function() {
          manager.addSubScreen(this);
        };
        p.add = function(component) {
          this.components.push(component);
        };
        p.render = function() {
          this.initLayout();
          this.isRendered = true;
        };
        p.setTopMargin = function(marginTop) {
          this.marginTop = marginTop;
        };
        p.renderDebug = function(group) {
          var debugGroup = group || this.group;
          console.log("ui-component :: renderDebug", debugGroup);
          var colour = group ? 65535 : 65280;
          var bgDebug = game.add.graphics(0, 0, debugGroup);
          bgDebug.beginFill(colour, 0.3);
          bgDebug.drawRect(0, 0, debugGroup.width, debugGroup.height);
          bgDebug.endFill();
        };
        p.remove = function() {
          this.isRendered = false;
          this.group.removeAll();
          this.dispose();
        };
        p.dispose = function() {
          _.each(this.components, function(component) {
            component.dispose();
          });
          this.components = [];
        };
        p.enable = function() {};
        p.disable = function() {};
        p.show = function() {
          this.group.visible = true;
          if (!this.preventAutoEnable) {
            this.enable();
          }
        };
        p.hide = function() {
          this.group.visible = false;
          this.disable();
        };
        p.showAndAdd = function() {
          if (!this.isRendered) {
            this.render();
            this.show();
          }
        };
        p.hideAndRemove = function() {
          if (this.isRendered) {
            this.remove();
            this.hide();
          }
        };
        p.initLayout = function() {
          if (game.device.desktop && game.width >= 1e3) {
            this.initFullLayout();
          } else {
            this.initSmallLayout();
          }
        };
        p.initFullLayout = function() {
          this.isFullLayout = true;
        };
        p.initSmallLayout = function() {
          this.isFullLayout = false;
        };
        p.getDarkStyle = function() {
          if (game.device.iPhone || game.device.iPhone4) {
            return this.darkMinStyle;
          }
          return this.isFullLayout ? this.darkStyle : this.darkMinStyle;
        };
        p.getStyle = function() {
          if (game.device.iPhone || game.device.iPhone4) {
            return this.minStyle;
          }
          return this.isFullLayout ? this.style : this.minStyle;
        };
        p.centerDisplay = function() {
          this.group.x = game.width / 2 - this.layoutRect.width / 2;
          this.group.y = game.height / 2 - this.layoutRect.height / 2;
        };
        p.update = function() {};
        p.getComponentByName = function(name) {
          return _.find(this.components, { name: name });
        };
      },
      { "./manager": 43, lodash: 1 }
    ],
    56: [
      function(require, module, exports) {
        module.exports = {
          counter: 1,
          blinking: false,
          init: function(group) {
            this.counter = 1;
            this.group = group;
            var x = game.width / 2;
            var y = game.height * 0.05;
            var style = {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "center"
            };
            this.text = game.add.text(x, y, "GAME OVER", style, this.group);
            this.text.anchor.setTo(0.5);
            this.text.visible = false;
          },
          blink: function() {
            this.text.visible = true;
            this.blinking = true;
          },
          stop: function() {
            this.text.visible = false;
            this.blinking = false;
          },
          update: function() {
            if (this.blinking) {
              if (this.counter++ % 80 === 0) {
                this.text.visible = !this.text.visible;
              }
            }
          }
        };
      },
      {}
    ],
    57: [
      function(require, module, exports) {
        var UIComponent = require("./ui-component");
        var _ = require("lodash");
        var gameState = require("../data/game-state");
        var levelManager = require("../data/level-manager");
        var p = (UIHighScores.prototype = Object.create(UIComponent.prototype, {
          constructor: UIHighScores
        }));
        module.exports = UIHighScores;
        function UIHighScores(group, name, playState) {
          UIComponent.call(this, group, name, true, true);
          this.playState = playState;
          _.bindAll(this, "keyboardOnPress");
          _.bindAll(this, "swallowBackspace");
        }
        p.joypadThrustButton = true;
        p.joypadDownButton = true;
        p.joypadUpButton = true;
        p.joypadFireButton = true;
        p.highScoreInputEnabled = false;
        p.items = [];
        p.padding = 30;
        p.maxY = 0;
        p.styles = {
          title: {
            font: "26px thrust_regular",
            fill: "#ffffff",
            align: "left"
          },
          scores: {
            font: "16px thrust_regular",
            fill: "#ffffff",
            align: "left"
          },
          subtitle: {
            font: "18px thrust_regular",
            fill: "#ffffff",
            align: "left"
          }
        };
        p.selectedIndex = 0;
        p.itemSelected = null;
        p.layoutRect = null;
        p.newScoreName = "";
        p.mobileCharsIndex = 0;
        p.mobileChars = [
          " ",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          ":)",
          "END"
        ];
        p.mobileCharDirty = false;
        p.render = function() {
          UIComponent.prototype.render.call(this);
          this.items = [];
          this.initSignals();
          this.createDisplay();
          this.drawPressFire();
        };
        p.initFullLayout = function() {
          UIComponent.prototype.initFullLayout.call(this);
          this.padding = game.width * 0.1;
          this.layoutRect = new Phaser.Rectangle(
            this.padding,
            this.padding,
            game.width - this.padding * 2,
            game.height - this.padding * 2
          );
        };
        p.initSmallLayout = function() {
          UIComponent.prototype.initSmallLayout.call(this);
          this.padding = game.width * 0.1;
          this.layoutRect = new Phaser.Rectangle(
            this.padding,
            this.padding,
            game.width - this.padding * 2,
            game.height - this.padding * 2
          );
          this.styles = {
            title: {
              font: "14px thrust_regular",
              fill: "#ffffff",
              align: "left"
            },
            scores: {
              font: "10px thrust_regular",
              fill: "#ffffff",
              align: "left"
            },
            subtitle: {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "left"
            }
          };
        };
        p.initSignals = function() {};
        p.createDisplay = function() {
          var rect = game.add.graphics(0, 0, this.group);
          rect.beginFill(16711680, 0.35);
          rect.drawRect(
            this.layoutRect.x,
            this.layoutRect.y,
            this.layoutRect.width,
            this.layoutRect.height
          );
          rect.endFill();
          this.createTitle();
          _.each(gameState.highScoreTable, _.bind(this.addHighScore, this));
          this.drawBestTime();
          this.createSubtitles();
        };
        p.centerDisplay = function() {
          this.group.x = game.width / 2 - this.layoutRect.width / 2;
          this.group.y = game.height / 2 - this.layoutRect.height / 2;
        };
        p.createTitle = function() {
          this.title = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            0,
            "HIGH SCORES",
            this.styles.title,
            this.group
          );
          this.title.anchor.setTo(0.5);
          this.title.y = this.layoutRect.y + this.layoutRect.height * 0.075;
        };
        p.addHighScore = function(highscore, index) {
          var numberTf = game.add.text(
            0,
            0,
            index + 1,
            this.styles.scores,
            this.group
          );
          var nameTf = game.add.text(
            0,
            0,
            highscore.name,
            this.styles.scores,
            this.group
          );
          var scoreTf = game.add.text(
            0,
            0,
            highscore.score,
            this.styles.scores,
            this.group
          );
          var y =
            this.layoutRect.y +
            this.layoutRect.height * 0.2 +
            (numberTf.height + 5) * index;
          numberTf.x = this.layoutRect.x + this.padding / 2;
          numberTf.y = nameTf.y = scoreTf.y = y;
          nameTf.x = numberTf.x + numberTf.width + this.layoutRect.width * 0.04;
          scoreTf.x =
            this.layoutRect.x +
            this.layoutRect.width -
            scoreTf.width -
            this.padding / 2;
          this.items.push({ number: numberTf, name: nameTf, score: scoreTf });
          this.paddingLeft = numberTf.x;
          this.lineHeight = nameTf.height + 5;
          this.maxY = y;
        };
        p.renderHighScores = function() {
          _.each(
            gameState.highScoreTable,
            function(highScore, index) {
              this.items[index].name.text = highScore.name;
              var scoreTf = this.items[index].score;
              scoreTf.text = highScore.score;
              scoreTf.x =
                this.layoutRect.x +
                this.layoutRect.width -
                scoreTf.width -
                this.padding / 2;
            }.bind(this)
          );
        };
        p.insertNewScore = function() {
          var scoreIndex = gameState.getScoreIndex();
          if (scoreIndex >= 0) {
            var currentScoreItem = this.items[scoreIndex];
            this.cursor = game.add.text(
              this.layoutRect.x + 20,
              this.layoutRect.y + 20,
              "_",
              this.styles.scores,
              this.group
            );
            this.cursor.x = currentScoreItem.name.x;
            this.cursor.y = currentScoreItem.name.y;
            gameState.insertNewHighScore(scoreIndex);
            this.renderHighScores();
            this.newHighScoreSubTitle();
            this.enableKeyboardEntry();
          } else {
            this.gameOverSubTitle();
          }
        };
        p.drawPressFire = function() {
          this.subTitle3.visible = true;
        };
        p.drawBestTime = function() {
          var style = this.styles.subtitle;
          this.bestTimeLabel = game.add.text(
            this.paddingLeft,
            this.maxY + this.lineHeight * 2,
            "Fastest Run: ",
            style,
            this.group
          );
          this.bestTimeValue = game.add.text(
            this.bestTimeLabel.x + this.bestTimeLabel.width,
            this.bestTimeLabel.y,
            "-- : -- : --",
            style,
            this.group
          );
          if (gameState.bestTimeMs > 0) {
            this.bestTimeValue.text = gameState.bestTimeStr;
          }
        };
        p.createSubtitles = function() {
          var style = this.styles.subtitle;
          this.subTitle1 = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            this.layoutRect.y + this.layoutRect.height * 0.8,
            "",
            style,
            this.group
          );
          this.subTitle1.anchor.setTo(0.5);
          this.subTitle2 = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            this.subTitle1.y + this.subTitle1.height + 10,
            "",
            style,
            this.group
          );
          this.subTitle2.anchor.setTo(0.5);
          this.subTitle3 = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            0,
            "PRESS FIRE",
            this.styles.scores,
            this.group
          );
          this.subTitle3.anchor.setTo(0.5);
          this.subTitle3.y =
            this.layoutRect.y +
            this.layoutRect.height -
            this.layoutRect.height * 0.075;
          this.subTitle1.visible = false;
          this.subTitle2.visible = false;
          this.subTitle3.visible = false;
        };
        p.newHighScoreSubTitle = function() {
          this.subTitle1.visible = this.subTitle2.visible = true;
          this.subTitle1.text = "NEW HIGH SCORE";
          this.subTitle2.text = "ENTER YOUR NAME";
        };
        p.gameOverSubTitle = function() {
          this.subTitle1.visible = this.subTitle2.visible = true;
          this.subTitle1.text = "GAME OVER";
          this.subTitle2.text =
            "YOU REACHED LEVEL " + parseInt(levelManager.levelIndex + 1, 10);
          this.subTitle3.visible = true;
          if (gameState.gameComplete) {
            gameState.newGame();
            this.subTitle2.text = "YOU COMPLETED ALL LEVELS";
          }
        };
        p.checkTouchInput = function() {
          if (!this.highScoreInputEnabled) {
            return;
          }
          var stick = game.controls.stick;
          if (stick) {
            if (stick.isDown) {
              if (stick.direction === Phaser.UP) {
                this.stickUpPressed = true;
                this.stickDownPressed = false;
              } else if (stick.direction === Phaser.DOWN) {
                this.stickUpPressed = false;
                this.stickDownPressed = true;
              }
            } else {
              if (this.stickDownPressed) {
                this.stickDownPressed = false;
                this.stepDownMobileChar();
              }
              if (this.stickUpPressed) {
                this.stickUpPressed = false;
                this.stepUpMobileChar();
              }
            }
          }
          this.renderMobileChar();
        };
        p.checkJoypadInput = function() {
          game.input.gamepad.pad1.onUpCallback = function(buttonCode) {
            if (buttonCode === Phaser.Gamepad.BUTTON_1) {
              this.joypadFireButton = true;
            }
            if (buttonCode === Phaser.Gamepad.BUTTON_0) {
              this.joypadThrustButton = true;
            }
            if (buttonCode === Phaser.Gamepad.BUTTON_12) {
              this.joypadUpButton = true;
            }
            if (buttonCode === Phaser.Gamepad.BUTTON_13) {
              this.joypadDownButton = true;
            }
          }.bind(this);
          game.input.gamepad.pad1.onDownCallback = function(buttonCode) {
            if (
              buttonCode === Phaser.Gamepad.BUTTON_1 &&
              this.joypadFireButton
            ) {
              this.joypadFireButton = false;
              if (this.highScoreInputEnabled) {
                this.upButtonA();
              } else {
                this.spacePressed();
              }
            }
            if (!this.highScoreInputEnabled) {
              return;
            }
            if (
              buttonCode === Phaser.Gamepad.BUTTON_12 &&
              this.joypadUpButton
            ) {
              this.joypadUpButton = false;
              this.stepUpMobileChar();
              this.renderMobileChar();
            }
            if (
              buttonCode === Phaser.Gamepad.BUTTON_13 &&
              this.joypadDownButton
            ) {
              this.joypadDownButton = false;
              this.stepDownMobileChar();
              this.renderMobileChar();
            }
            if (
              buttonCode === Phaser.Gamepad.BUTTON_0 &&
              this.joypadThrustButton
            ) {
              this.joypadThrustButton = false;
              this.upButtonB();
            }
          }.bind(this);
        };
        p.stepUpMobileChar = function() {
          if (this.mobileCharsIndex + 1 === this.mobileChars.length) {
            this.mobileCharsIndex = 0;
          } else {
            this.mobileCharsIndex++;
          }
          this.mobileCharDirty = true;
        };
        p.stepDownMobileChar = function() {
          if (this.mobileCharsIndex === 0) {
            this.mobileCharsIndex = this.mobileChars.length - 1;
          } else {
            this.mobileCharsIndex--;
          }
          this.mobileCharDirty = true;
        };
        p.renderMobileChar = function() {
          if (this.mobileCharDirty) {
            this.mobileCharDirty = false;
            this.char = this.mobileChars[this.mobileCharsIndex];
            this.renderScoreInput(this.newScoreName + this.char);
          }
        };
        p.assignMobileChar = function() {
          if (this.char === this.mobileChars[this.mobileChars.length - 1]) {
            this.commitScore();
            return;
          }
          if (this.newScoreName.length < 13) {
            this.newScoreName = this.newScoreName + this.char;
            this.mobileCharsIndex = 0;
            this.char = this.mobileChars[this.mobileCharsIndex];
            this.renderScoreInput(this.newScoreName + this.char);
          } else {
            this.char = this.mobileChars[this.mobileChars.length - 1];
            this.renderScoreInput(this.newScoreName + this.char);
          }
        };
        p.update = function() {
          if (game.controls.useVirtualJoypad) {
            this.checkTouchInput();
          } else if (game.controls.useExternalJoypad) {
            this.checkJoypadInput();
          }
        };
        p.enable = function() {
          if (game.controls.useKeys) {
            game.controls.spacePress.onDown.add(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonB.onDown.add(this.spacePressed, this);
          }
        };
        p.disable = function() {
          if (game.controls.useKeys) {
            game.controls.spacePress.onDown.remove(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonB.onDown.remove(this.spacePressed, this);
          }
        };
        p.spacePressed = function() {
          this.playState.showCurrentScreenByState.call(
            this.playState,
            gameState.PLAY_STATES.MENU
          );
        };
        p.upButtonB = function() {
          this.assignMobileChar();
        };
        p.upButtonA = function() {
          this.assignMobileChar();
        };
        p.enableKeyboardEntry = function() {
          this.subTitle3.visible = false;
          this.highScoreInputEnabled = true;
          if (game.controls.stick) {
            this.char = this.mobileChars[this.mobileCharsIndex];
            this.renderScoreInput(this.newScoreName + this.char);
            game.controls.buttonB.onUp.add(this.upButtonB, this);
            game.controls.buttonA.onUp.add(this.upButtonA, this);
          }
          this.disable();
          window.addEventListener("keydown", this.swallowBackspace);
          window.addEventListener("keypress", this.keyboardOnPress);
        };
        p.disableKeyboardEntry = function() {
          this.subTitle3.visible = true;
          this.highScoreInputEnabled = false;
          if (game.controls.stick) {
            game.controls.buttonB.onUp.remove(this.upButtonB, this);
            game.controls.buttonA.onUp.remove(this.upButtonA, this);
          }
          window.removeEventListener("keydown", this.swallowBackspace);
          window.removeEventListener("keypress", this.keyboardOnPress);
          this.enable();
        };
        p.swallowBackspace = function(e) {
          if (e.keyCode === 8) {
            e.preventDefault();
            if (this.newScoreName.length) {
              this.newScoreName = this.newScoreName.substring(
                0,
                this.newScoreName.length - 1
              );
              this.renderScoreInput(this.newScoreName);
            }
          }
        };
        p.keyboardOnPress = function(e) {
          var char = String.fromCharCode(e.keyCode);
          if (e.keyCode === 8) {
            this.swallowBackspace(e);
          }
          if (e.keyCode === 13) {
            this.commitScore();
          } else {
            this.newScoreName = this.newScoreName + char;
            this.renderScoreInput(this.newScoreName);
          }
        };
        p.renderScoreInput = function(str) {
          this.cursor.text = str + "_";
        };
        p.commitScore = function() {
          this.disableKeyboardEntry();
          this.group.remove(this.cursor);
          this.cursor.text = "";
          this.cursor = null;
          gameState.newScoreEntered(this.newScoreName);
          this.newScoreName = "";
          this.renderHighScores();
          this.gameOverSubTitle();
        };
      },
      {
        "../data/game-state": 18,
        "../data/level-manager": 19,
        "./ui-component": 55,
        lodash: 1
      }
    ],
    58: [
      function(require, module, exports) {
        (function(global) {
          var UIComponent = require("./ui-component");
          var _ = require("lodash");
          var gameState = require("../data/game-state");
          var TweenLite = global.TweenLite;
          var TimelineLite = global.TimelineLite;
          var Quad = global.Quad;
          var dialog = require("./mission-dialog");
          var sound = require("../utils/sound");
          var p = (UIInterstial.prototype = Object.create(
            UIComponent.prototype,
            { constructor: UIInterstial }
          ));
          module.exports = UIInterstial;
          p.scoreCalculator = 0;
          function UIInterstial(group, name, playState) {
            UIComponent.call(this, group, name, true, true);
            this.playState = playState;
            this.initSignals();
          }
          p.initSignals = function() {
            this.onExitComplete = new Phaser.Signal();
            this.trainingFailed = new Phaser.Signal();
            this.trainingComplete = new Phaser.Signal();
            this.levelComplete = new Phaser.Signal();
          };
          p.clearSignals = function() {
            this.onExitComplete = null;
            this.trainingFailed = null;
            this.trainingComplete = null;
            this.levelComplete = null;
          };
          p.onExitComplete = null;
          p.trainingSectionComplete = null;
          p.trainingComplete = null;
          p.levelComplete = null;
          p.preventAutoEnable = true;
          p.planetKillerFields = [
            {
              successLabel: "Mission Complete",
              failLabel: "Mission Failed",
              yPos: 0.3,
              style: {
                font: "18px thrust_regular",
                fill: "#ffffff",
                align: "left"
              },
              center: true
            },
            {
              successLabel: "Limpets Destroyed",
              failLabel: "Limpets Missed",
              valueId: "LIMPETS_DESTROYED",
              yPos: 0.4,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Planet Destroyed",
              failLabel: "Planet Survived",
              valueId: "PLANET_BUSTER",
              yPos: 0.45,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Timed Run",
              failLabel: "Time Invalidated",
              valueId: "TIMED_RUN",
              yPos: 0.5,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Press Fire",
              failLabel: "Press Fire",
              yPos: 0.6,
              style: {
                font: "18px thrust_regular",
                fill: "#00ff00",
                align: "left"
              },
              center: true
            }
          ];
          p.trainingFields = [
            {
              successLabel: "Training Complete",
              failLabel: "Training Failed",
              yPos: 0.3,
              style: {
                font: "18px thrust_regular",
                fill: "#ffffff",
                align: "left"
              },
              center: true
            },
            {
              successLabel: "Drones Passed",
              failLabel: "Drones Missed",
              valueId: "DRONES_PASSED",
              yPos: 0.4,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Orb Recovered",
              failLabel: "Orb Not Recovered",
              valueId: "ORB_RECOVERED",
              yPos: 0.45,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Timed Run",
              failLabel: "Time Invalidated",
              valueId: "TIMED_RUN",
              yPos: 0.5,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Press Fire",
              failLabel: "Press Fire",
              yPos: 0.6,
              style: {
                font: "18px thrust_regular",
                fill: "#00ff00",
                align: "left"
              },
              center: true
            }
          ];
          p.fields = [
            {
              successLabel: "Mission Complete",
              failLabel: "Mission Failed",
              yPos: 0.3,
              style: {
                font: "18px thrust_regular",
                fill: "#ffffff",
                align: "left"
              },
              center: true
            },
            {
              successLabel: "Orb Recovered",
              failLabel: "Orb Not Recovered",
              valueId: "ORB_RECOVERED",
              yPos: 0.4,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Planet Destroyed",
              failLabel: "",
              valueId: "PLANET_BUSTER",
              yPos: 0.45,
              style: {
                font: "14px thrust_regular",
                fill: "#ffffff",
                align: "left"
              }
            },
            {
              successLabel: "Prepare for warp",
              failLabel: "Retry Mission",
              yPos: 0.55,
              style: {
                font: "18px thrust_regular",
                fill: "#00ffff",
                align: "left"
              },
              center: true
            },
            {
              successLabel: "Press Fire",
              failLabel: "Press Fire",
              yPos: 0.6,
              style: {
                font: "18px thrust_regular",
                fill: "#00ff00",
                align: "left"
              },
              center: true
            }
          ];
          p.scaleFontSize = function(style) {
            var fontsizeStr = style.split("px")[0];
            var fontsize = parseInt(fontsizeStr, 10) * gameState.gameScale;
            return style.replace(fontsizeStr, fontsize);
          };
          p.createLabels = function(x, field, index, label) {
            var fontStyle = this.scaleFontSize(field.style.font);
            if (gameState.bonuses.planetBuster || gameState.trainingMode) {
            } else {
              if (index === 2) {
                label = field.failLabel;
              }
            }
            field.tf = game.add.text(
              x,
              game.height * field.yPos,
              label,
              {
                font: fontStyle,
                fill: field.style.fill,
                align: field.style.align
              },
              this.group
            );
            field.tf.alpha = 0;
            return label;
          };
          p.createValues = function(x, field, label) {
            var fontStyle = this.scaleFontSize(field.style.font);
            if (field.center) {
              field.tf.anchor.setTo(0.5, 0);
            } else {
              field.tf.x = field.tf.x - 200 * gameState.gameScale;
            }
            if (field.valueId) {
              if (label === field.successLabel) {
                field.score = gameState.getScoreByValueId(field.valueId);
              } else {
                field.score = 0;
              }
              console.log("field.valueId / score", field.valueId, field.score);
              if (label.length) {
                field.valueTf = game.add.text(
                  x + 150 * gameState.gameScale,
                  game.height * field.yPos,
                  field.score,
                  {
                    font: fontStyle,
                    fill: field.style.fill,
                    align: field.style.align
                  },
                  this.group
                );
                field.valueTf.alpha = 0;
              }
            }
          };
          p.render = function() {
            UIComponent.prototype.render.call(this);
            var isSuccess = false;
            var x = game.width / 2;
            _.each(
              this.getFields(),
              function(field, index) {
                var labelText;
                if (gameState.planetBusterMode) {
                  isSuccess = gameState.bonuses.planetBuster;
                  labelText = isSuccess ? field.successLabel : field.failLabel;
                } else {
                  console.log(
                    "ui-interstitial :: render : orbRecovered? ",
                    gameState.bonuses.orbRecovered
                  );
                  isSuccess = gameState.bonuses.orbRecovered;
                  labelText = isSuccess ? field.successLabel : field.failLabel;
                }
                var label = this.createLabels(x, field, index, labelText);
                this.createValues(x, field, label);
              }.bind(this)
            );
            this.transitionEnter(isSuccess);
          };
          p.update = function() {
            if (!this.enabled) {
              return;
            }
            if (game.controls.gamepad.justPressed(Phaser.Gamepad.BUTTON_1)) {
              this.spacePressed();
            }
          };
          p.enable = function() {
            this.enabled = true;
            if (game.controls.useKeys) {
              game.controls.spacePress.onDown.add(this.spacePressed, this);
            }
            if (game.controls.useVirtualJoypad) {
              game.controls.buttonB.onDown.add(this.spacePressed, this);
            }
          };
          p.disable = function() {
            this.enabled = false;
            if (game.controls.useKeys) {
              game.controls.spacePress.onDown.remove(this.spacePressed, this);
            }
            if (game.controls.useVirtualJoypad) {
              game.controls.buttonB.onDown.remove(this.spacePressed, this);
            }
          };
          p.spacePressed = function() {
            sound.playSound(sound.UI_PRESS_FIRE);
            this.disable();
            this.transitionExit();
          };
          p.transitionEnter = function(isSuccess) {
            this.scoreCalculator = gameState.score;
            this.tl = new TimelineLite({
              delay: 0.25,
              onComplete: this.transitionEnterComplete,
              callbackScope: this
            });
            this.tl.add(function() {
              if (isSuccess) {
                sound.playSound(sound.UI_INTERSTITIAL_MISSION_COMPLETE);
              } else {
                sound.playSound(sound.UI_INTERSTITIAL_MISSION_FAILED);
              }
            });
            _.each(
              this.getFields(),
              function(field) {
                this.tl.add(
                  TweenLite.to(field.tf, 0.2, { alpha: 1, ease: Quad.easeIn })
                );
              }.bind(this)
            );
            this.tl.add(TweenLite.to(this, 0.5));
            _.each(
              this.getFields(),
              function(field) {
                console.log(
                  "do score transition :: field",
                  field.tf.text,
                  field
                );
                if (field.valueTf) {
                  this.tl.add(
                    TweenLite.to(field.valueTf, 0.2, {
                      alpha: 1,
                      ease: Quad.easeIn
                    })
                  );
                  if (field.score > 0 && !gameState.trainingMode) {
                    this.scoreCalculator = this.scoreCalculator + field.score;
                    sound.playSound(sound.UI_SCORE_ROLLUP);
                    this.tl.add(
                      TweenMax.to(gameState, 0.3, {
                        score: this.scoreCalculator,
                        roundProps: "score",
                        onComplete: function() {
                          gameState.setScore(this.scoreCalculator);
                        }.bind(this)
                      })
                    );
                  }
                }
              }.bind(this)
            );
          };
          p.getFields = function() {
            if (gameState.trainingMode) {
              return this.trainingFields;
            } else if (gameState.planetBusterMode) {
              return this.planetKillerFields;
            } else {
              return this.fields;
            }
          };
          p.transitionExit = function() {
            this.tl = new TimelineLite({
              delay: 0,
              onComplete: this.transitionExitComplete,
              callbackScope: this
            });
            _.each(
              this.getFields(),
              function(field) {
                this.tl.add(
                  TweenLite.to(field.tf, 0.2, { y: -100, ease: Quad.easeIn })
                );
                if (field.valueTf) {
                  this.tl.add(
                    TweenLite.to(field.valueTf, 0.2, {
                      x: game.width + 100,
                      ease: Quad.easeIn
                    })
                  );
                }
              }.bind(this)
            );
            this.onExitComplete.dispatch();
          };
          p.transitionEnterComplete = function() {
            this.enable();
          };
          p.transitionExitComplete = function() {
            this.group.removeAll();
            if (gameState.trainingMode && gameState.bonuses.orbRecovered) {
              dialog.render(
                function() {
                  this.trainingComplete.dispatch();
                }.bind(this),
                this
              );
            } else if (
              gameState.trainingMode &&
              !gameState.bonuses.orbRecovered
            ) {
              this.trainingFailed.dispatch();
            } else {
              this.levelComplete.dispatch();
              this.clearSignals();
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {
        "../data/game-state": 18,
        "../utils/sound": 71,
        "./mission-dialog": 44,
        "./ui-component": 55,
        lodash: 1
      }
    ],
    59: [
      function(require, module, exports) {
        var UiComponent = require("./ui-component");
        var gameState = require("../data/game-state");
        var dialogs = require("../data/dialogs");
        var p = (UiLevelsComplete.prototype = Object.create(
          UiComponent.prototype,
          { constructor: UiLevelsComplete }
        ));
        module.exports = UiLevelsComplete;
        p.group = null;
        p.padding = 20;
        function UiLevelsComplete(group, name, playState) {
          UiComponent.call(this, group, name, true, true);
          this.playState = playState;
          this.scale = gameState.gameScale;
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
          this.enable();
        };
        p.createDisplay = function() {
          var titleFontSize = Math.floor(24 * this.scale);
          var defaultFontSize = Math.floor(16 * this.scale);
          this.styles = {
            title: {
              font: titleFontSize + "px thrust_regular",
              fill: "#ffffff",
              align: "left"
            },
            default: {
              font: defaultFontSize + "px thrust_regular",
              fill: "#ffffff",
              align: "left"
            }
          };
          this.renderImage();
          this.renderText();
        };
        p.renderText = function() {
          this.title = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            0,
            "CONGRATULATIONS",
            this.styles.title,
            this.group
          );
          this.title.anchor.setTo(0.5);
          this.title.y = this.layoutRect.y + this.layoutRect.height * 0.1;
          var para1Str = dialogs.getLevelsCompleteText();
          this.paragraph1 = game.add.text(
            this.layoutRect.x + this.padding * 2,
            0,
            para1Str,
            this.styles.default,
            this.group
          );
          this.paragraph1.width = this.layoutRect.width - this.padding * 4;
          this.paragraph1.x = this.layoutRect.x + this.layoutRect.halfWidth;
          this.paragraph1.y = this.layoutRect.y + this.layoutRect.halfHeight;
          this.paragraph1.anchor.setTo(0.5);
          this.pressFire = game.add.text(
            this.layoutRect.x + this.layoutRect.halfWidth,
            0,
            "PRESS FIRE TO CONTINUE",
            this.styles.default,
            this.group
          );
          this.pressFire.anchor.setTo(0.5);
          this.pressFire.y = this.layoutRect.y + this.layoutRect.height * 0.9;
          this.title.stroke = this.paragraph1.stroke = this.pressFire.stroke =
            "#000000";
          this.title.strokeThickness = this.paragraph1.strokeThickness = this.pressFire.strokeThickness = 6;
          this.title.fill = this.paragraph1.fill = this.pressFire.fill =
            "#ffffff";
        };
        p.renderImage = function() {
          var image = game.add.image(0, 0, "coverImage", "", this.group);
          var scaleX = (game.width - game.width / 30) / image.width;
          image.alpha = 0.5;
          image.scale.setTo(scaleX);
          image.x = image.y = game.width / 2 - image.width / 2;
          this.layoutRect = new Phaser.Rectangle(
            this.padding,
            this.padding,
            game.width - this.padding * 2,
            game.height - this.padding * 2
          );
          var mask = game.add.graphics(0, 0, this.group);
          mask.beginFill(16711680, 1);
          mask.drawRect(
            this.layoutRect.x,
            this.layoutRect.y,
            this.layoutRect.width,
            this.layoutRect.height
          );
          mask.endFill();
          var rect = game.add.graphics(0, 0, this.group);
          rect.lineStyle(2, 16777215, 1);
          rect.drawRect(
            this.layoutRect.x,
            this.layoutRect.y,
            this.layoutRect.width,
            this.layoutRect.height
          );
          rect.endFill();
          image.mask = mask;
        };
        p.enable = function() {
          this.enabled = true;
          if (game.controls.useKeys) {
            game.controls.spacePress.onDown.add(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonB.onDown.add(this.spacePressed, this);
          }
        };
        p.disable = function() {
          this.enabled = false;
          if (game.controls.useKeys) {
            game.controls.spacePress.onDown.remove(this.spacePressed, this);
          }
          if (game.controls.stick) {
            game.controls.buttonB.onDown.remove(this.spacePressed, this);
          }
        };
        p.update = function() {
          if (!this.enabled) {
            return;
          }
          if (game.controls.gamepad.justPressed(Phaser.Gamepad.BUTTON_1)) {
            this.spacePressed();
          }
        };
        p.spacePressed = function() {
          gameState.doHighScoreCheck(true);
          gameState.doBestTimeCheck();
          this.playState.showCurrentScreenByState.call(
            this.playState,
            gameState.PLAY_STATES.HIGH_SCORES
          );
        };
      },
      { "../data/dialogs": 17, "../data/game-state": 18, "./ui-component": 55 }
    ],
    60: [
      function(require, module, exports) {
        module.exports = UiList;
        var _ = require("lodash");
        var UiComponent = require("./ui-component");
        var UiButton = require("./ui-button");
        function UiList(group, name, listItems) {
          UiComponent.call(this, group, name, true, false);
          this.listItems = listItems || [];
          this.listComponents = [];
        }
        var p = (UiList.prototype = Object.create(UiComponent.prototype, {
          constructor: UiList
        }));
        p.listComponents = [];
        p.listItems = [];
        p.margin = 0;
        p.padding = 0;
        p.layout = [];
        p.layoutType = UiComponent.VERTICAL;
        p.selectedIndex = 0;
        p.leftPressed = false;
        p.rightPressed = false;
        p.onItemSelected = new Phaser.Signal();
        p.currentSelectedId = null;
        p.setAutoLayout = function(layoutType) {
          this.layoutType = layoutType;
        };
        p.render = function() {
          UiComponent.prototype.render.call(this);
          _.each(this.listItems, _.bind(this.drawItem, this));
          this.initEvents();
        };
        p.drawPosition = p.padding + p.margin;
        p.drawItem = function(label, index) {
          var button = new UiButton(this.group, label);
          button.render();
          var x, y;
          if (this.layoutType === UiComponent.HORIZONTAL) {
            x = this.drawPosition;
            this.drawPosition +=
              button.group.width + this.padding * 2 + this.margin * 2;
            y = 0;
          } else if (this.layoutType === UiComponent.VERTICAL) {
            x = 0;
            y = this.drawPosition;
            this.drawPosition +=
              button.group.height + this.padding * 2 + this.margin * 2;
          } else {
            x = this.layout[index].x;
            y = this.layout[index].y;
          }
          button.group.x = x;
          button.group.y = y;
          this.listComponents.push({ id: label, button: button });
        };
        p.hideSelectionBackgrounds = function() {
          _.each(this.listComponents, function(component) {
            component.spr.alpha = 0;
          });
        };
        p.initEvents = function() {
          _.each(
            this.listComponents,
            function(component, index) {
              component.button.onItemSelected.add(
                this.selectOption,
                this,
                0,
                index
              );
            }.bind(this)
          );
        };
        p.dispose = function() {
          UiComponent.prototype.dispose.call(this);
          _.each(
            this.listComponents,
            function(component) {
              component.button.onItemSelected.remove(this.selectOption, this);
              component.button.dispose();
            }.bind(this)
          );
          this.listComponents = [];
        };
        p.componentMouseDown = function(arg1, arg2, id) {
          this.selectOption(id, null, this.selectedIndex);
        };
        p.selectOption = function(id, button, index) {
          this.selectedIndex = index + 1;
          if (id !== this.currentSelectedId) {
            _.each(this.listComponents, this.deselectComponent);
            if (!button) {
              button = this.getButtonById(id);
            }
            this.selectComponent(button);
            this.onItemSelected.dispatch(id, this.selectedIndex);
            this.currentSelectedId = id;
          }
        };
        p.getButtonById = function(id) {
          var listComponent = _.find(this.listComponents, function(component) {
            return component.id === id;
          });
          return listComponent.button;
        };
        p.selectComponent = function(button) {
          button.selectComponent();
        };
        p.deselectComponent = function(component) {
          component.button.deselectComponent();
        };
      },
      { "./ui-button": 54, "./ui-component": 55, lodash: 1 }
    ],
    61: [
      function(require, module, exports) {
        var UiComponent = require("./ui-component");
        var _ = require("lodash");
        var sound = require("../utils/sound");
        var version = require("../../../package.json").version;
        var options = require("../data/options-model");
        var p = (UIMenu.prototype = Object.create(UiComponent.prototype, {
          constructor: UIMenu
        }));
        module.exports = UIMenu;
        function UIMenu(group, name, menuSelectedCallback, playState) {
          UiComponent.call(this, group, name, true, true);
          this.menuSelectedCallback = menuSelectedCallback;
          this.playState = playState;
          this.dataProvider = [
            "PLAY THRUST",
            "TRAINING",
            "HIGH-SCORES",
            "OPTIONS"
          ];
        }
        p.joypadFireButton = true;
        p.group = null;
        p.items = [];
        p.itemSelected = new Phaser.Signal();
        p.style = {
          font: "16px thrust_regular",
          fill: "#ffffff",
          align: "left"
        };
        p.padding = 5;
        p.selectedIndex = 0;
        p.stickUpPressed = false;
        p.stickDownPressed = false;
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.items = [];
          _.each(this.dataProvider, _.bind(this.menuItem, this));
          var style = {
            font: "14px thrust_regular",
            fill: "#ffffff",
            align: "left"
          };
          this.version = game.make.text(
            0,
            0,
            "v" + version + options.versionSuffix,
            style
          );
          this.version.anchor.setTo(0, 0);
          this.version.x = game.width - this.version.width - 10;
          this.version.y = 10;
          this.group.add(this.version);
        };
        p.update = function() {
          var stick = game.controls.stick;
          var joypad = game.externalJoypad;
          if (joypad) {
            if (joypad.up.isDown) {
              this.stickUpPressed = true;
              this.stickDownPressed = false;
            } else if (joypad.down.isDown) {
              this.stickUpPressed = false;
              this.stickDownPressed = true;
            } else {
              this.checkPressed();
            }
            game.input.gamepad.pad1.onUpCallback = function(buttonCode) {
              if (buttonCode === Phaser.Gamepad.BUTTON_1) {
                this.joypadFireButton = true;
              }
            }.bind(this);
            game.input.gamepad.pad1.onDownCallback = function(buttonCode) {
              if (
                buttonCode === Phaser.Gamepad.BUTTON_1 &&
                this.joypadFireButton
              ) {
                this.joypadFireButton = false;
                this.spacePressed();
              }
            }.bind(this);
          } else if (stick) {
            if (stick.isDown) {
              if (stick.direction === Phaser.UP) {
                this.stickUpPressed = true;
                this.stickDownPressed = false;
              } else if (stick.direction === Phaser.DOWN) {
                this.stickUpPressed = false;
                this.stickDownPressed = true;
              }
            } else {
              this.checkPressed();
            }
          }
        };
        p.checkPressed = function() {
          if (this.stickDownPressed) {
            this.stickDownPressed = false;
            this.downPressed();
          }
          if (this.stickUpPressed) {
            this.stickUpPressed = false;
            this.upPressed();
          }
        };
        p.menuItem = function(label, index) {
          var text = game.add.text(
            game.width / 2,
            game.height / 2 - 35 + 35 * index,
            label,
            this.style,
            this.group
          );
          text.anchor.setTo(0.5);
          var graphic = game.add.graphics(0, 0, this.group);
          graphic.beginFill(16711680, 0.8);
          graphic.drawRect(
            0,
            0,
            text.width + this.padding * 2,
            text.height + this.padding * 2
          );
          graphic.endFill();
          graphic.x = text.x - text.width / 2 - this.padding;
          graphic.y = text.y - text.height / 2 - this.padding;
          text.bringToTop();
          this.items.push({ text: text, graphic: graphic });
        };
        p.selectItemByIndex = function(index) {
          _.each(this.items, this.deselectItem);
          this.items[index].graphic.visible = true;
          sound.playSound(sound.UI_MENU_SELECT, 1);
        };
        p.deselectItem = function(item) {
          item.graphic.visible = false;
        };
        p.enable = function() {
          this.selectedIndex = 0;
          this.selectItemByIndex(this.selectedIndex);
          if (game.controls.useKeys) {
            game.controls.cursors.up.onDown.add(this.upPressed, this);
            game.controls.cursors.down.onDown.add(this.downPressed, this);
            game.controls.spacePress.onDown.add(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonA.onDown.add(this.spacePressed, this);
            game.controls.buttonB.onDown.add(this.spacePressed, this);
          }
          this.itemSelected.add(this.menuSelectedCallback, this.playState);
        };
        p.disable = function() {
          if (game.controls.useKeys) {
            game.controls.cursors.up.onDown.remove(this.upPressed, this);
            game.controls.cursors.down.onDown.remove(this.downPressed, this);
            game.controls.spacePress.onDown.remove(this.spacePressed, this);
          }
          if (game.controls.stick) {
            game.controls.buttonA.onDown.remove(this.spacePressed, this);
            game.controls.buttonB.onDown.remove(this.spacePressed, this);
          }
          this.itemSelected.remove(this.menuSelectedCallback, this.playState);
        };
        p.upPressed = function() {
          if (this.selectedIndex > 0) {
            this.selectedIndex--;
          } else {
            this.selectedIndex = this.items.length - 1;
          }
          this.selectItemByIndex(this.selectedIndex);
        };
        p.downPressed = function() {
          if (this.selectedIndex < this.items.length - 1) {
            this.selectedIndex++;
          } else {
            this.selectedIndex = 0;
          }
          this.selectItemByIndex(this.selectedIndex);
        };
        p.spacePressed = function() {
          this.itemSelected.dispatch(this.items[this.selectedIndex]);
        };
        p.dispose = function() {
          UiComponent.prototype.dispose.call(this);
          this.version.destroy();
        };
      },
      {
        "../../../package.json": 2,
        "../data/options-model": 20,
        "../utils/sound": 71,
        "./ui-component": 55,
        lodash: 1
      }
    ],
    62: [
      function(require, module, exports) {
        var UiComponent = require("./ui-component");
        var SoundOptions = require("./subscreens/sound-options");
        var DisplayOptions = require("./subscreens/display-options");
        var GeneralOptions = require("./subscreens/general-options");
        var Sandbox = require("./subscreens/sandbox");
        var UiPanel = require("./ui-panel");
        var UiList = require("./ui-list");
        var manager = require("./manager");
        var UiButton = require("./ui-button");
        var gameState = require("../data/game-state");
        var _ = require("lodash");
        var controlsFactory = require("./factories/controls-factory");
        var p = (UiOptions.prototype = Object.create(UiComponent.prototype, {
          constructor: UiOptions
        }));
        module.exports = UiOptions;
        p.subScreenLabels = ["SOUND", "DISPLAY", "CONTROLS", "GENERAL"];
        p.subScreens = [];
        p.panel = null;
        p.group = null;
        p.playState = null;
        p.components = [];
        p.selectedOptionIndex = 0;
        p.activeOptions = [];
        p.numMainOptions = 0;
        p.stickUpPressed = false;
        p.stickDownPressed = false;
        p.stickLeftPressed = false;
        p.stickRightPressed = false;
        function UiOptions(group, name, playState) {
          UiComponent.call(this, group, name, true, true);
          this.playState = playState;
          this.panel = new UiPanel(this.group, name, playState);
          this.selectedOptionIndex = 0;
          this.activeOptions = [];
        }
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.selectedOptionIndex = 0;
          this.activeOptions = [];
          this.panel.render();
          this.layoutRect = this.panel.layoutRect;
          this.styles = this.panel.styles;
          this.createDisplay();
          this.initSubScreens();
          this.initEvents();
          this.centerDisplay();
          this.renderSubScreens();
          this.components = [
            this.optionsList,
            this.exitButton,
            this.soundOptions,
            this.displayOptions,
            this.controlsOptions,
            this.generalOptions
          ];
          if (gameState.cheats.enabled) {
            this.components.push(this.sandbox);
          }
        };
        p.createDisplay = function() {
          var paddingPerc = this.isFullLayout ? 0.05 : 0.05;
          this.exitButton = new UiButton(this.group, "<");
          this.exitButton.render();
          this.exitButton.group.x = this.layoutRect.height * 0.02;
          this.exitButton.group.y = this.layoutRect.height * 0.02;
          if (
            gameState.cheats.enabled &&
            this.subScreenLabels.indexOf("SANDBOX") === -1
          ) {
            this.subScreenLabels.push("SANDBOX");
          }
          this.optionsList = new UiList(
            this.group,
            "OPTIONS_LIST",
            this.subScreenLabels
          );
          this.optionsList.setAutoLayout(UiComponent.HORIZONTAL);
          this.optionsList.render();
          this.optionsList.group.y = this.layoutRect.height * paddingPerc;
          this.optionsList.group.x =
            this.layoutRect.halfWidth - this.optionsList.group.width / 2;
          this.activeOptions.push(this.exitButton);
          _.each(
            this.optionsList.listComponents,
            function(component) {
              this.activeOptions.push(component.button);
            }.bind(this)
          );
          this.numMainOptions = this.activeOptions.length;
        };
        p.initSubScreens = function() {
          var topMargin =
            this.optionsList.group.y +
            this.optionsList.group.height +
            this.layoutRect.height * 0.1;
          this.soundOptions = new SoundOptions(
            this.group,
            "SOUND_OPTIONS",
            this.layoutRect
          );
          this.soundOptions.setTopMargin(topMargin);
          this.soundOptions.addAsSubScreen();
          this.displayOptions = new DisplayOptions(
            this.group,
            "DISPLAY_OPTIONS",
            this.layoutRect
          );
          this.displayOptions.setTopMargin(topMargin);
          this.displayOptions.addAsSubScreen();
          var ControlsScreen = controlsFactory.getControlsScreen();
          this.controlsOptions = new ControlsScreen(
            this.group,
            "CONTROLS_OPTIONS",
            this.layoutRect
          );
          this.controlsOptions.setTopMargin(topMargin);
          this.controlsOptions.addAsSubScreen();
          this.generalOptions = new GeneralOptions(
            this.group,
            "GENERAL_OPTIONS",
            this.layoutRect
          );
          this.generalOptions.setTopMargin(topMargin);
          this.generalOptions.addAsSubScreen();
          this.generalOptions.overrideUserControl.add(
            this.removeActiveEvents,
            this
          );
          this.generalOptions.restoreUserControl.add(
            this.addActiveEvents,
            this
          );
          if (gameState.cheats.enabled) {
            this.sandbox = new Sandbox(
              this.group,
              "SANDBOX_OPTIONS",
              this.layoutRect
            );
            this.sandbox.setTopMargin(topMargin);
            this.sandbox.addAsSubScreen();
            this.sandbox.overrideUserControl.add(this.removeActiveEvents, this);
            this.sandbox.restoreUserControl.add(this.addActiveEvents, this);
          }
        };
        p.update = function() {
          this.updateChildComponents();
          if (!this.isActive) {
            return;
          }
          var stick = game.controls.stick;
          if (stick) {
            if (stick.isDown) {
              this.preparePress(stick.direction);
            } else {
              if (this.stickDownPressed) {
                this.stickDownPressed = false;
                this.downPressed();
              }
              if (this.stickUpPressed) {
                this.stickUpPressed = false;
                this.upPressed();
              }
              if (this.stickLeftPressed) {
                this.stickLeftPressed = false;
                this.leftPressed();
              }
              if (this.stickRightPressed) {
                this.stickRightPressed = false;
                this.rightPressed();
              }
            }
          }
        };
        p.updateChildComponents = function() {
          if (this.generalOptions) {
            this.generalOptions.update();
          }
          if (this.displayOptions) {
            this.displayOptions.update();
          }
        };
        p.preparePress = function(directionStr) {
          this.stickUpPressed = directionStr === Phaser.UP;
          this.stickDownPressed = directionStr === Phaser.DOWN;
          this.stickLeftPressed = directionStr === Phaser.LEFT;
          this.stickRightPressed = directionStr === Phaser.RIGHT;
        };
        p.renderSubScreens = function() {
          this.optionsList.selectOption("SOUND", null, 0);
        };
        p.initEvents = function() {
          this.optionsList.onItemSelected.add(this.itemSelected, this);
          this.exitButton.onItemSelected.add(this.exit, this);
          this.addActiveEvents();
        };
        p.addActiveEvents = function() {
          this.isActive = true;
          if (game.controls.useKeys) {
            game.controls.cursors.up.onDown.add(this.upPressed, this);
            game.controls.cursors.down.onDown.add(this.downPressed, this);
            game.controls.cursors.left.onDown.add(this.leftPressed, this);
            game.controls.cursors.right.onDown.add(this.rightPressed, this);
            game.controls.spacePress.onDown.add(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonA.onDown.add(this.spacePressed, this);
            game.controls.buttonB.onDown.add(this.spacePressed, this);
          }
          if (game.controls.useExternalJoypad) {
            game.externalJoypad.up.onDown.add(this.upPressed, this);
            game.externalJoypad.down.onDown.add(this.downPressed, this);
            game.externalJoypad.left.onDown.add(this.leftPressed, this);
            game.externalJoypad.right.onDown.add(this.rightPressed, this);
            game.externalJoypad.fireButton.onDown.add(this.spacePressed, this);
          }
        };
        p.dispose = function() {
          this.optionsList.onItemSelected.remove(this.itemSelected, this);
          this.exitButton.onItemSelected.remove(this.exit, this);
          this.removeActiveEvents();
          manager.clearSubscreens();
          this.isActive = false;
          UiComponent.prototype.dispose.call(this);
        };
        p.removeActiveEvents = function() {
          this.isActive = false;
          if (game.controls.useKeys) {
            game.controls.cursors.up.onDown.remove(this.upPressed, this);
            game.controls.cursors.down.onDown.remove(this.downPressed, this);
            game.controls.cursors.left.onDown.remove(this.leftPressed, this);
            game.controls.cursors.right.onDown.remove(this.rightPressed, this);
            game.controls.spacePress.onDown.remove(this.spacePressed, this);
          }
          if (game.controls.useVirtualJoypad) {
            game.controls.buttonA.onDown.remove(this.spacePressed, this);
            game.controls.buttonB.onDown.remove(this.spacePressed, this);
          }
          if (game.controls.useExternalJoypad) {
            game.externalJoypad.up.onDown.remove(this.upPressed, this);
            game.externalJoypad.down.onDown.remove(this.downPressed, this);
            game.externalJoypad.left.onDown.remove(this.leftPressed, this);
            game.externalJoypad.right.onDown.remove(this.rightPressed, this);
            game.externalJoypad.fireButton.onDown.remove(
              this.spacePressed,
              this
            );
          }
        };
        p.upPressed = function() {
          if (this.selectedOptionIndex > this.numMainOptions) {
            this.selectedOptionIndex--;
          } else if (this.selectedOptionIndex === 1) {
            this.selectedOptionIndex = 0;
          } else if (this.selectedOptionIndex > 0) {
            this.selectedOptionIndex = 1;
          }
          this.selectActiveOption();
        };
        p.downPressed = function() {
          if (this.selectedOptionIndex === 0) {
            this.selectedOptionIndex = 1;
          } else if (this.selectedOptionIndex < this.numMainOptions) {
            this.selectedOptionIndex = this.numMainOptions;
          } else if (this.selectedOptionIndex < this.activeOptions.length - 1) {
            this.selectedOptionIndex++;
          }
          this.selectActiveOption();
        };
        p.leftPressed = function() {
          if (this.selectedOptionIndex > 0) {
            this.selectedOptionIndex--;
          }
          this.selectActiveOption();
        };
        p.rightPressed = function() {
          if (this.selectedOptionIndex < this.activeOptions.length - 1) {
            this.selectedOptionIndex++;
          }
          this.selectActiveOption();
        };
        p.selectActiveOption = function() {
          _.each(this.activeOptions, function(button) {
            button.userDeselected();
          });
          this.activeOptions[this.selectedOptionIndex] &&
            this.activeOptions[this.selectedOptionIndex].userSelected();
        };
        p.spacePressed = function() {
          this.pressActiveButton();
        };
        p.pressActiveButton = function() {
          var activeButton = this.activeOptions[this.selectedOptionIndex];
          activeButton && activeButton.apiSelect();
        };
        p.itemSelected = function(id, index) {
          var screen = manager.showScreen(id + "_OPTIONS", true);
          this.activeOptions.splice(this.numMainOptions);
          if (screen) {
            _.each(
              screen.components,
              function(component) {
                this.activeOptions.push(component);
              }.bind(this)
            );
          }
          this.selectedOptionIndex = index;
          this.selectActiveOption();
        };
        p.exit = function() {
          this.clearState();
          this.playState.showCurrentScreenByState.call(
            this.playState,
            gameState.PLAY_STATES.MENU
          );
        };
        p.clearState = function() {
          p.subScreenLabels = ["SOUND", "DISPLAY", "CONTROLS", "GENERAL"];
          p.subScreens = [];
        };
      },
      {
        "../data/game-state": 18,
        "./factories/controls-factory": 38,
        "./manager": 43,
        "./subscreens/display-options": 50,
        "./subscreens/general-options": 51,
        "./subscreens/sandbox": 52,
        "./subscreens/sound-options": 53,
        "./ui-button": 54,
        "./ui-component": 55,
        "./ui-list": 60,
        "./ui-panel": 63,
        lodash: 1
      }
    ],
    63: [
      function(require, module, exports) {
        var UiComponent = require("./ui-component");
        var canvas = require("../utils/canvas");
        var p = (UiPanel.prototype = Object.create(UiComponent.prototype, {
          constructor: UiPanel
        }));
        module.exports = UiPanel;
        function UiPanel(group, name, playState) {
          UiComponent.call(this, group, name, false, false);
          this.playState = playState;
        }
        p.group = null;
        p.fullLayout = false;
        p.padding = 30;
        p.maxY = 0;
        p.styles = {
          title: {
            font: "20px thrust_regular",
            fill: "#ffffff",
            align: "left"
          },
          scores: {
            font: "16px thrust_regular",
            fill: "#ffffff",
            align: "left"
          },
          subtitle: {
            font: "18px thrust_regular",
            fill: "#ffffff",
            align: "left"
          }
        };
        p.setSkin = function(bmd) {
          this.skinBitmap = bmd;
        };
        p.render = function() {
          UiComponent.prototype.render.call(this);
          this.createDisplay();
        };
        p.initFullLayout = function() {
          UiComponent.prototype.initFullLayout.call(this);
          this.lineHeight = 4;
          this.layoutRect = new Phaser.Rectangle(
            0,
            0,
            game.width * 0.65,
            game.height * 0.5
          );
        };
        p.initSmallLayout = function() {
          UiComponent.prototype.initSmallLayout.call(this);
          this.padding = 2;
          this.lineHeight = 3;
          this.layoutRect = new Phaser.Rectangle(
            this.padding,
            this.padding,
            game.width - this.padding * 2,
            game.height - this.padding * 2
          );
          this.styles = {
            title: {
              font: "14px thrust_regular",
              fill: "#ffffff",
              align: "left"
            },
            scores: {
              font: "10px thrust_regular",
              fill: "#ffffff",
              align: "left"
            },
            subtitle: {
              font: "12px thrust_regular",
              fill: "#ffffff",
              align: "left"
            }
          };
        };
        p.createDisplay = function() {
          if (game.device.iOS) {
            this.drawIOSBackground();
          } else {
            this.drawCanvasBackground();
          }
        };
        p.drawCanvasBackground = function() {
          var strokeWidth = 4;
          var width = this.layoutRect.width - strokeWidth * 2;
          var height = this.layoutRect.height - strokeWidth * 2;
          this.skinBitmap = game.make.bitmapData(
            this.layoutRect.width + strokeWidth * 2,
            this.layoutRect.height + strokeWidth * 2
          );
          var linearGradient1 = this.skinBitmap.ctx.createLinearGradient(
            0,
            0,
            0,
            height
          );
          linearGradient1.addColorStop(0, "rgb(25, 24, 24)");
          linearGradient1.addColorStop(0.5, "rgb(3, 31, 64)");
          this.skinBitmap.ctx.fillStyle = linearGradient1;
          this.skinBitmap.ctx.strokeStyle = "rgb(255,255,255)";
          this.skinBitmap.ctx.lineWidth = strokeWidth;
          canvas.drawRoundRect(
            this.skinBitmap.ctx,
            strokeWidth / 2,
            strokeWidth / 2,
            width,
            height,
            10,
            true,
            true
          );
          this.background = game.add.sprite(
            this.layoutRect.x,
            this.layoutRect.y,
            this.skinBitmap,
            "",
            this.group
          );
        };
        p.drawIOSBackground = function() {
          var strokeWidth = 4;
          var width = this.layoutRect.width - strokeWidth * 2;
          var height = this.layoutRect.height - strokeWidth * 2;
          var color = Phaser.Color.RGBtoString(25, 24, 24);
          this.background = game.add.graphics(0, 0, this.group);
          this.background.lineStyle(strokeWidth, 16777215);
          this.background.beginFill(color, 1);
          this.background.drawRoundedRect(
            this.layoutRect.x,
            this.layoutRect.y,
            width,
            height,
            10
          );
          this.background.endFill();
        };
      },
      { "../utils/canvas": 67, "./ui-component": 55 }
    ],
    64: [
      function(require, module, exports) {
        (function(global) {
          var UiComponent = require("./ui-component");
          var UiButton = require("./ui-button");
          var canvas = require("../utils/canvas");
          var TimelineMax = global.TimelineMax;
          var TweenMax = global.TweenMax;
          var Quad = global.Quad;
          var _ = require("lodash");
          var p = (UiSelect.prototype = Object.create(UiComponent.prototype, {
            constructor: UiSelect
          }));
          module.exports = UiSelect;
          p.backgroundSkin = null;
          p.buttonSkin = null;
          p.selectionSkin = null;
          p.isOn = false;
          p.switchedOn = null;
          p.switchedOff = null;
          p.gamepadSelector = null;
          p.originPos = null;
          p.dataProvider = [];
          p.padding = 10;
          p.optionTexts = [];
          p.selectedIndex = 0;
          function UiSelect(group, name, dataProvider) {
            UiComponent.call(this, group, name, true, false);
            this.originPos = new Phaser.Point();
            this.label = this.name;
            this.dataProvider = dataProvider;
            this.optionTexts = [];
            this.optionSelected = new Phaser.Signal();
          }
          p.render = function() {
            UiComponent.prototype.render.call(this);
            this.initOptions();
            this.createDisplay();
            this.addOptions();
            this.createLabel();
            this.alignToLabel();
            this.drawSelector();
            this.initEvents();
          };
          p.initOptions = function() {
            var style = this.getStyle();
            var option;
            var w = 1,
              h = 1;
            var optionSkin = game.make.bitmapData(w, h);
            optionSkin.ctx.fillStyle = "rgba(255, 0, 0, 1)";
            canvas.drawRoundRect(optionSkin.ctx, 0, 0, w, h, 0, true, false);
            this.optionBg = game.make.sprite(
              -this.padding,
              -this.padding,
              optionSkin,
              ""
            );
            this.optionBg.visible = false;
            this.optionBg.alpha = 0;
            _.each(
              this.dataProvider,
              function(optionData, index) {
                option = game.make.text(0, 0, optionData.str, style);
                option.x = 0;
                option.y = index * (option.height + this.padding * 2);
                if (option.width > w) {
                  w = option.width;
                  this.optionBg.width = w + this.padding * 2;
                  this.optionBg.height = option.height + this.padding * 2;
                }
                h = option.y + option.height;
                this.optionTexts.push(option);
                option.alpha = 0;
                option.visible = false;
              }.bind(this)
            );
            this.maxW = w + this.padding * 2;
            this.maxH = h + this.padding * 2;
          };
          p.addOptions = function() {
            this.group.add(this.optionBg);
            _.each(
              this.optionTexts,
              function(txt) {
                this.group.add(txt);
              }.bind(this)
            );
          };
          p.selectBoxOut = function() {
            game.input.deleteMoveCallback(this.moveCallback, this);
          };
          p.selectBoxOver = function() {
            game.input.addMoveCallback(this.moveCallback, this);
          };
          p.moveCallback = function(pointer) {
            var pos = pointer.position;
            if (
              pos.x > this.group.x &&
              pos.x < this.group.x + this.selectBoxBg.width
            ) {
              this.selectedIndex = Math.floor(
                (pos.y - this.group.y - this.selectBoxBg.y) /
                  this.optionBg.height
              );
              this.highlightOption();
            }
          };
          p.selectBoxDown = function(spr, pointer) {
            var pos = pointer.positionDown;
            this.selectedIndex = Math.floor(
              (pos.y - this.group.y - this.selectBoxBg.y) / this.optionBg.height
            );
            this.selectCurrentOption();
          };
          p.createDisplay = function() {
            this.button = new UiButton(this.group, "V");
            this.button.padding = 7.5;
            this.button.render();
            this.backgroundSkin = game.make.bitmapData(this.maxW, this.maxH);
            this.backgroundSkin.ctx.fillStyle = "rgba(20, 51, 87, 1)";
            canvas.drawRoundRect(
              this.backgroundSkin.ctx,
              0,
              0,
              this.maxW,
              this.maxH,
              0,
              true,
              false
            );
            this.selectBoxBg = game.make.sprite(
              -this.padding,
              -this.padding,
              this.backgroundSkin,
              ""
            );
            this.group.add(this.selectBoxBg);
            this.selectBoxBg.visible = false;
            this.selectBoxBg.alpha = 0;
          };
          p.createLabel = function() {
            var style = this.getStyle();
            this.label = game.add.text(0, 0, this.label, style, this.group);
            this.optionLabel = game.add.text(
              0,
              0,
              this.dataProvider[0].str,
              this.style,
              this.group
            );
            this.optionLabel.alpha = 0;
            this.optionLabel.visible = false;
          };
          p.alignToLabel = function() {
            this.button.group.x = this.label.x + this.label.width;
            this.button.group.y =
              this.label.y - this.button.buttonElements.spr.height * 0.5;
          };
          p.alignToNewLabel = function() {
            var bg = this.button.group;
            bg.x = this.optionLabel.x + this.optionLabel.width;
            this.gamepadSelector.x = bg.x - 5;
          };
          p.drawSelector = function() {
            var bg = this.button.group;
            var w = bg.width + 10,
              h = bg.height + 10;
            var selector = game.make.bitmapData(w, h);
            selector.ctx.translate(0.5, 0.5);
            selector.ctx.beginPath();
            selector.ctx.strokeStyle = "#ffffff";
            selector.ctx.lineWidth = 2;
            selector.ctx.setLineDash([3, 2]);
            canvas.drawRoundRect(
              selector.ctx,
              2,
              2,
              w - 4,
              h - 4,
              2,
              false,
              true
            );
            this.gamepadSelector = game.add.sprite(
              bg.x - 5,
              bg.y - 5,
              selector,
              "",
              this.group
            );
            this.gamepadSelector.visible = false;
            this.gamepadSelector.alpha = 0;
          };
          p.initEvents = function() {
            this.switchedOn = new Phaser.Signal();
            this.switchedOff = new Phaser.Signal();
            this.button.onItemSelected.add(this.switch, this);
          };
          p.dispose = function() {
            this.button.onItemSelected.remove(this.switch, this);
          };
          p.mouseDown = function() {};
          p.switch = function() {
            this.isOn = !this.isOn;
            var switchFunc = this.isOn ? this.switchOn : this.switchOff;
            switchFunc.call(this);
          };
          p.switchOn = function(noAnimation) {
            this.optionLabel.visible = false;
            this.optionLabel.alpha = 0;
            this.overrideUserControl.dispatch();
            this.addActiveEvents();
            if (this.closeAnim) {
              this.closeAnim.progress(1, false);
            }
            var scaleX = 0.5;
            var scaleY = 0.5;
            var posY = "-25";
            this.selectBoxBg.visible = true;
            this.optionBg.visible = true;
            this.openAnim = new TimelineMax();
            var tween1 = new TweenMax(this.label.scale, 0.2, {
              x: scaleX,
              y: scaleY,
              ease: Quad.easeOut
            });
            var tween2 = new TweenMax(this.label, 0.2, {
              y: posY,
              ease: Quad.easeOut
            });
            var bgTween = new TweenMax(this.optionBg, 0.2, {
              alpha: 1,
              ease: Quad.easOut
            });
            this.openAnim.add([tween1, tween2]);
            var txtTweens = [];
            _.each(this.optionTexts, function(txt) {
              txt.visible = true;
              var tween = new TweenMax(txt, 0.2, {
                alpha: 1,
                ease: Quad.easeOut
              });
              txtTweens.push(tween);
            });
            txtTweens.push(bgTween);
            this.openAnim.add(TweenMax.to(this.selectBoxBg, 0.2, { alpha: 1 }));
            this.openAnim.add(txtTweens);
            this.openAnim.addCallback(this.enableOptions);
            this.userDeselected();
            if (noAnimation) {
              this.openAnim.progress(1, false);
            }
          };
          p.enableOptions = function() {};
          p.disableOptions = function() {};
          p.switchOff = function(noAnimation) {
            var scaleX = 1;
            var scaleY = 1;
            var posY = 0;
            this.restoreUserControl.dispatch();
            this.removeActiveEvents();
            if (this.openAnim) {
              this.openAnim.progress(1, false);
            }
            this.closeAnim = new TimelineMax();
            var tween1 = new TweenMax(this.label.scale, 0.2, {
              x: scaleX,
              y: scaleY,
              ease: Quad.easeOut
            });
            var tween2 = new TweenMax(this.label, 0.2, {
              y: posY,
              ease: Quad.easeOut
            });
            var bgTween = new TweenMax(this.optionBg, 0.2, {
              alpha: 0,
              ease: Quad.easOut
            });
            var txtTweens = [];
            _.each(this.optionTexts, function(txt) {
              txt.visible = true;
              var tween = new TweenMax(txt, 0.2, {
                alpha: 0,
                ease: Quad.easeOut
              });
              txtTweens.push(tween);
            });
            txtTweens.push(bgTween);
            txtTweens.push(TweenMax.to(this.selectBoxBg, 0.2, { alpha: 0 }));
            this.closeAnim.addCallback(this.disableOptions);
            this.closeAnim.add(txtTweens);
            this.closeAnim.add([tween1, tween2]);
            if (noAnimation) {
              this.closeAnim.progress(1, false);
            }
            this.isOn = false;
          };
          p.userSelected = function() {
            this.gamepadSelector.visible = true;
            this.gamepadSelector.alpha = 1;
          };
          p.userDeselected = function() {
            this.gamepadSelector.visible = false;
            this.gamepadSelector.alpha = 0;
          };
          p.apiSelect = function() {
            this.switch();
          };
          p.removeActiveEvents = function() {
            this.isActive = false;
            this.selectBoxBg.inputEnabled = false;
            this.selectBoxBg.events.onInputOut.remove(this.selectBoxOut, this);
            this.selectBoxBg.events.onInputDown.remove(
              this.selectBoxDown,
              this
            );
            this.selectBoxBg.events.onInputOver.remove(
              this.selectBoxOver,
              this
            );
            if (game.controls.useKeys) {
              game.controls.cursors.up.onDown.remove(this.upPressed, this);
              game.controls.cursors.down.onDown.remove(this.downPressed, this);
              game.controls.cursors.left.onDown.remove(this.leftPressed, this);
              game.controls.cursors.right.onDown.remove(
                this.rightPressed,
                this
              );
              game.controls.spacePress.onDown.remove(this.spacePressed, this);
            }
            if (game.controls.useVirtualJoypad) {
              game.controls.buttonB.onDown.remove(this.spacePressed, this);
            }
            if (game.controls.useExternalJoypad) {
              game.externalJoypad.up.onDown.remove(this.upPressed, this);
              game.externalJoypad.down.onDown.remove(this.downPressed, this);
              game.externalJoypad.left.onDown.remove(this.leftPressed, this);
              game.externalJoypad.right.onDown.remove(this.rightPressed, this);
              game.externalJoypad.fireButton.onDown.remove(
                this.spacePressed,
                this
              );
            }
          };
          p.addActiveEvents = function() {
            this.isActive = true;
            this.selectBoxBg.inputEnabled = true;
            this.selectBoxBg.events.onInputOut.add(this.selectBoxOut, this);
            this.selectBoxBg.events.onInputDown.add(this.selectBoxDown, this);
            this.selectBoxBg.events.onInputOver.add(this.selectBoxOver, this);
            if (game.controls.useKeys) {
              game.controls.cursors.up.onDown.add(this.upPressed, this);
              game.controls.cursors.down.onDown.add(this.downPressed, this);
              game.controls.cursors.left.onDown.add(this.leftPressed, this);
              game.controls.cursors.right.onDown.add(this.rightPressed, this);
              game.controls.spacePress.onDown.add(this.spacePressed, this);
            }
            if (game.controls.useVirtualJoypad) {
              game.controls.buttonB.onDown.add(this.spacePressed, this);
            }
            if (game.controls.useExternalJoypad) {
              game.externalJoypad.up.onDown.add(this.upPressed, this);
              game.externalJoypad.down.onDown.add(this.downPressed, this);
              game.externalJoypad.left.onDown.add(this.leftPressed, this);
              game.externalJoypad.right.onDown.add(this.rightPressed, this);
              game.externalJoypad.fireButton.onDown.add(
                this.spacePressed,
                this
              );
            }
          };
          p.update = function() {
            if (!this.isActive) {
              return;
            }
            var stick = game.controls.stick;
            if (stick) {
              if (stick.isDown) {
                this.preparePress(stick.direction);
              } else {
                if (this.stickDownPressed) {
                  this.stickDownPressed = false;
                  this.downPressed();
                }
                if (this.stickUpPressed) {
                  this.stickUpPressed = false;
                  this.upPressed();
                }
                if (this.stickLeftPressed) {
                  this.stickLeftPressed = false;
                  this.leftPressed();
                }
                if (this.stickRightPressed) {
                  this.stickRightPressed = false;
                  this.rightPressed();
                }
              }
            }
          };
          p.preparePress = function(directionStr) {
            this.stickUpPressed = directionStr === Phaser.UP;
            this.stickDownPressed = directionStr === Phaser.DOWN;
            this.stickLeftPressed = directionStr === Phaser.LEFT;
            this.stickRightPressed = directionStr === Phaser.RIGHT;
          };
          p.upPressed = function() {
            if (this.selectedIndex > 0) {
              this.selectedIndex--;
            }
            this.highlightOption();
          };
          p.downPressed = function() {
            if (this.selectedIndex < this.dataProvider.length - 1) {
              this.selectedIndex++;
            }
            this.highlightOption();
          };
          p.leftPressed = function() {};
          p.rightPressed = function() {};
          p.spacePressed = function() {
            this.selectCurrentOption();
          };
          p.highlightOption = function() {
            if (this.optionTexts[this.selectedIndex]) {
              this.optionBg.y =
                this.optionTexts[this.selectedIndex].y - this.padding;
            }
          };
          p.selectCurrentOption = function(overrideIndex, silent) {
            if (overrideIndex) {
              this.selectedIndex = overrideIndex;
            }
            if (silent) {
              this.silent = silent;
            }
            this.optionLabel.text = this.dataProvider[this.selectedIndex].str;
            this.optionLabel.visible = true;
            this.optionLabel.alpha = 1;
            this.alignToNewLabel();
            if (!this.silent) {
              this.selectTween();
            }
          };
          p.onOptionSelected = function() {
            var option = this.dataProvider[this.selectedIndex];
            console.log("option", option);
            this.optionSelected.dispatch(option.value);
          };
          p.selectTween = function() {
            this.restoreUserControl.dispatch();
            this.removeActiveEvents();
            this.selectAnim = new TimelineMax({
              onComplete: this.onOptionSelected,
              callbackScope: this
            });
            var bgTween = new TweenMax(this.optionBg, 0.2, {
              alpha: 0,
              ease: Quad.easOut
            });
            var selectBg = new TweenMax(this.selectBoxBg, 0.2, {
              alpha: 0,
              ease: Quad.easeOut
            });
            var txtTweens = [];
            _.each(this.optionTexts, function(txt) {
              var tween = new TweenMax(txt, 0.2, {
                alpha: 0,
                ease: Quad.easeOut
              });
              txtTweens.push(tween);
            });
            txtTweens.push(bgTween);
            txtTweens.push(TweenMax.to(this.selectBoxBg, 0.2, { alpha: 0 }));
            this.selectAnim.addCallback(this.disableOptions);
            this.selectAnim.add(txtTweens);
            this.selectAnim.add([selectBg, bgTween]);
            this.isOn = false;
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      {
        "../utils/canvas": 67,
        "./ui-button": 54,
        "./ui-component": 55,
        lodash: 1
      }
    ],
    65: [
      function(require, module, exports) {
        module.exports = {
          group: null,
          timerLabel: null,
          timerValue: null,
          init: function(x, y, group) {
            this.group = group;
            var style = {
              font: "14px thrust_regular",
              fill: "#ffffff",
              align: "center"
            };
            this.timerValue = game.add.text(
              0,
              y,
              "00:00:00",
              style,
              this.group
            );
            this.timerValue.x = x;
            this.timerValue.anchor.setTo(0.5, 0);
          },
          trainingMode: function() {
            this.timerValue.visible = true;
            this.scoreLabel.text = "Drones: ";
          },
          shiftDown: function() {
            this.timerValue.y += 30;
          },
          hide: function() {
            if (this.value) {
              this.timerValue.visible = false;
            }
          },
          update: function(text) {
            this.timerValue.text = text;
          }
        };
      },
      {}
    ],
    66: [
      function(require, module, exports) {
        (function(global) {
          var UiComponent = require("./ui-component");
          var canvas = require("../utils/canvas");
          var TimelineMax = global.TimelineMax;
          var TweenMax = global.TweenMax;
          var Quad = global.Quad;
          var p = (UiSwitch.prototype = Object.create(UiComponent.prototype, {
            constructor: UiSwitch
          }));
          module.exports = UiSwitch;
          p.backgroundSkin = null;
          p.buttonSkin = null;
          p.selectionSkin = null;
          p.isOn = false;
          p.switchedOn = null;
          p.switchedOff = null;
          p.gamepadSelector = null;
          p.originPos = null;
          p.locked = false;
          function UiSwitch(group, name, locked) {
            UiComponent.call(this, group, name, true, false);
            this.locked = locked;
            this.originPos = new Phaser.Point();
            this.switchedOn = new Phaser.Signal();
            this.switchedOff = new Phaser.Signal();
          }
          p.render = function() {
            UiComponent.prototype.render.call(this);
            this.createDisplay();
            this.createLabel();
            this.alignToLabel();
            this.drawSelector();
            this.initEvents();
          };
          p.createDisplay = function() {
            if (!this.backgroundSkin) {
              this.backgroundSkin = game.make.bitmapData(60, 20);
              this.backgroundSkin.ctx.fillStyle = "rgba(225, 225, 225, 1)";
              canvas.drawRoundRect(
                this.backgroundSkin.ctx,
                0,
                0,
                60,
                20,
                5,
                true,
                false
              );
            }
            if (!this.buttonSkin) {
              this.buttonSkin = game.make.bitmapData(36, 24);
              this.buttonSkin.ctx.fillStyle = "rgba(161, 161, 161, 1)";
              canvas.drawRoundRect(
                this.buttonSkin.ctx,
                0,
                0,
                36,
                24,
                7,
                true,
                false
              );
            }
            if (!this.selectionSkin) {
              this.selectionSkin = game.make.bitmapData(36, 24);
              this.selectionSkin.ctx.fillStyle = "rgba(161, 161, 161, 0.5)";
              canvas.drawRoundRect(
                this.selectionSkin.ctx,
                0,
                0,
                36,
                24,
                7,
                true,
                false
              );
            }
            this.background = game.add.sprite(
              0,
              0,
              this.backgroundSkin,
              "",
              this.group
            );
            this.selection = game.add.sprite(
              0,
              0,
              this.selectionSkin,
              "",
              this.group
            );
            this.button = game.add.sprite(
              0,
              0,
              this.buttonSkin,
              "",
              this.group
            );
            this.selection.anchor.setTo(0.5);
            if (this.locked) {
              this.group.alpha = 0.3;
            }
          };
          p.createLabel = function() {
            var style = this.getStyle();
            this.label = game.add.text(0, 0, this.name, style, this.group);
            this.label.anchor.setTo(0, 0.5);
            this.label.y = this.backgroundSkin.height / 2 + 2;
          };
          p.alignToLabel = function() {
            this.originPos.setTo(
              this.label.x + this.label.width + 10,
              this.backgroundSkin.height / 2 - this.button.height / 2
            );
            this.background.x = this.originPos.x;
            this.button.x = this.originPos.x;
            this.button.y = this.originPos.y;
            this.selection.x = this.originPos.x + this.selection.width / 2;
            this.selection.y = this.originPos.y + this.selection.height / 2;
          };
          p.drawSelector = function() {
            var w = this.background.width + 10,
              h = this.background.height + 10;
            var selector = game.make.bitmapData(w, h);
            selector.ctx.translate(0.5, 0.5);
            selector.ctx.beginPath();
            selector.ctx.strokeStyle = "#ffffff";
            selector.ctx.lineWidth = 2;
            selector.ctx.setLineDash([3, 2]);
            canvas.drawRoundRect(
              selector.ctx,
              2,
              2,
              w - 4,
              h - 4,
              2,
              false,
              true
            );
            var bg = this.background;
            this.gamepadSelector = game.add.sprite(
              bg.x - 5,
              bg.y - 5,
              selector,
              "",
              this.group
            );
            this.gamepadSelector.alpha = 0;
            this.gamepadSelector.visible = false;
          };
          p.initEvents = function() {
            this.button.inputEnabled = true;
            this.background.inputEnabled = true;
            this.button.input.useHandCursor = true;
            this.button.events.onInputDown.add(this.mouseDown, this);
            this.background.inputEnabled = true;
            this.background.input.useHandCursor = true;
            this.background.events.onInputDown.add(this.mouseDown, this);
          };
          p.dispose = function() {
            this.button.inputEnabled = false;
            this.background.inputEnabled = false;
            this.button.input.useHandCursor = false;
            this.button.events.onInputDown.remove(this.mouseDown, this);
            this.background.inputEnabled = false;
            this.background.input.useHandCursor = false;
            this.background.events.onInputDown.remove(this.mouseDown, this);
            this.switchedOn = null;
            this.switchedOff = null;
          };
          p.mouseDown = function() {
            if (!this.locked) {
              this.switch();
            }
          };
          p.switch = function(noAnimation, silent) {
            this.isOn = !this.isOn;
            var switchFunc = this.isOn ? this.switchOn : this.switchOff;
            switchFunc.call(this, noAnimation, silent);
          };
          p.switchOn = function(noAnimation, silent) {
            var x =
              this.originPos.x + this.background.width - this.button.width;
            this.selection.scale.setTo(1);
            var sX = x + this.selection.width / 2;
            this.selection.alpha = 1;
            this.tl = new TimelineMax();
            var tween1 = new TweenMax(this.button, 0.2, {
              x: x,
              ease: Quad.easeOut
            });
            var tween2 = new TweenMax(this.selection, 0.2, {
              x: sX,
              ease: Quad.easeOut
            });
            this.tl.add([tween1, tween2]);
            this.tl.add(
              TweenMax.to(this.background, 0.2, {
                colorProps: { tint: 5354301, tintAmount: 1, format: "number" },
                ease: Quad.easeOut
              }),
              0.1
            );
            this.tl.add(
              TweenMax.to(this.button, 0.2, {
                colorProps: { tint: 3118623, tintAmount: 1, format: "number" },
                ease: Quad.easeOut
              }),
              0.1
            );
            this.tl.add(
              TweenMax.to(this.selection.scale, 0.25, {
                x: 3,
                y: 3,
                ease: Quad.easeOut
              }),
              0.2
            );
            this.tl.add(
              TweenMax.to(this.selection, 0.25, {
                alpha: 0,
                ease: Quad.easeOut
              }),
              0.2
            );
            if (!silent) {
              this.switchedOn.dispatch();
            }
            if (noAnimation) {
              this.tl.progress(1, false);
            }
          };
          p.switchOff = function(noAnimation, silent) {
            var x = this.originPos.x;
            this.selection.scale.setTo(1);
            var sX = this.originPos.x + this.selection.width / 2;
            this.selection.alpha = 1;
            this.tl = new TimelineMax();
            var tween1 = new TweenMax(this.button, 0.2, {
              x: x,
              ease: Quad.easeOut
            });
            var tween2 = new TweenMax(this.selection, 0.2, {
              x: sX,
              ease: Quad.easeOut
            });
            this.tl.add([tween1, tween2]);
            this.tl.add(
              TweenMax.to(this.background, 0.2, {
                colorProps: { tint: 16777215, tintAmount: 1, format: "number" },
                ease: Quad.easeOut
              }),
              0.1
            );
            this.tl.add(
              TweenMax.to(this.button, 0.2, {
                colorProps: { tint: 16777215, tintAmount: 1, format: "number" },
                ease: Quad.easeOut
              }),
              0.1
            );
            this.tl.add(
              TweenMax.to(this.selection.scale, 0.25, {
                x: 3,
                y: 3,
                ease: Quad.easeOut
              }),
              0.2
            );
            this.tl.add(
              TweenMax.to(this.selection, 0.25, {
                alpha: 0,
                ease: Quad.easeOut
              }),
              0.2
            );
            if (!silent) {
              this.switchedOff.dispatch();
            }
            if (noAnimation) {
              this.tl.progress(1, false);
            }
          };
          p.userSelected = function() {
            if (!this.locked) {
              this.gamepadSelector.visible = true;
              this.gamepadSelector.alpha = 1;
            }
          };
          p.userDeselected = function() {
            if (!this.locked) {
              this.gamepadSelector.visible = false;
              this.gamepadSelector.alpha = 0;
            }
          };
          p.apiSelect = function() {
            if (!this.locked) {
              this.switch();
            }
          };
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
              ? self
              : typeof window !== "undefined" ? window : {}
        ));
      },
      { "../utils/canvas": 67, "./ui-component": 55 }
    ],
    67: [
      function(require, module, exports) {
        var _ = require("lodash");
        module.exports = {
          drawRoundRect: function(
            ctx,
            x,
            y,
            width,
            height,
            radius,
            fill,
            stroke,
            cornerRadii
          ) {
            if (!cornerRadii) {
              cornerRadii = [radius, radius, radius, radius];
            }
            ctx.moveTo(x + cornerRadii[0], y);
            ctx.lineTo(x + width - cornerRadii[1], y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadii[1]);
            ctx.lineTo(x + width, y + height - cornerRadii[3]);
            ctx.quadraticCurveTo(
              x + width,
              y + height,
              x + width - cornerRadii[3],
              y + height
            );
            ctx.lineTo(x + cornerRadii[2], y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadii[2]);
            ctx.lineTo(x, y + cornerRadii[0]);
            ctx.quadraticCurveTo(x, y, x + cornerRadii[0], y);
            ctx.closePath();
            if (stroke) {
              ctx.stroke();
            }
            if (fill) {
              ctx.fill();
            }
            return ctx;
          },
          drawCircle: function(context, x, y, radius) {
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
            context.closePath();
            context.stroke();
          },
          drawRoundedRectangleWithPointer: function(
            context,
            x,
            y,
            width,
            height,
            radius,
            pointer
          ) {
            context.moveTo(x, y + radius);
            context.quadraticCurveTo(x, y, x + radius, y);
            this.drawSide(
              context,
              x + radius,
              y,
              x + width - radius,
              y,
              pointer.side === "N",
              -1 * pointer.size,
              pointer.basePosition,
              pointer.baseWidth
            );
            context.quadraticCurveTo(x + width, y, x + width, y + radius);
            this.drawSide(
              context,
              x + width,
              y + radius,
              x + width,
              y + height - radius,
              pointer.side === "E",
              pointer.size,
              pointer.basePosition,
              pointer.baseWidth
            );
            context.quadraticCurveTo(
              x + width,
              y + height,
              x + width - radius,
              y + height
            );
            this.drawSide(
              context,
              x + width - radius,
              y + height,
              x + radius,
              y + height,
              pointer.side === "S",
              pointer.size,
              pointer.basePosition,
              pointer.baseWidth
            );
            context.quadraticCurveTo(x, y + height, x, y + height - radius);
            this.drawSide(
              context,
              x,
              y + height - radius,
              x,
              y + radius,
              pointer.side === "W",
              -1 * pointer.size,
              pointer.basePosition,
              pointer.baseWidth
            );
          },
          drawSide: function(
            context,
            startX,
            startY,
            endX,
            endY,
            hasPointer,
            size,
            basePosition,
            baseWidth
          ) {
            if (hasPointer) {
              this.drawPointer(
                context,
                startX,
                startY,
                endX,
                endY,
                size,
                basePosition,
                baseWidth
              );
            }
            context.lineTo(endX, endY);
          },
          drawPointer: function(
            context,
            startX,
            startY,
            endX,
            endY,
            size,
            basePosition,
            baseWidth
          ) {
            var points = [
              { x: startX, y: startY },
              { x: startX, y: startY },
              { x: startX, y: startY }
            ];
            var axis = startX !== endX ? "x" : "y";
            var otherAxis = axis === "x" ? "y" : "x";
            var start = axis === "x" ? startX : startY;
            var end = axis === "x" ? endX : endY;
            var lengthOfSide = end - start;
            var drawingDirection = lengthOfSide > 0 ? 1 : -1;
            var position = basePosition * lengthOfSide;
            baseWidth = Math.min(Math.abs(lengthOfSide), baseWidth);
            var clamp = drawingDirection === 1 ? Math.max : Math.min;
            points[0][axis] = clamp(
              start,
              start + position + -1 * drawingDirection * baseWidth * 0.5
            );
            points[1][axis] = start + position;
            points[1][otherAxis] += size;
            points[2][axis] =
              start + position + drawingDirection * baseWidth * 0.5;
            _.each(points, function(point) {
              context.lineTo(point.x, point.y);
            });
          },
          drawSpinArrow: function(context, centerPoint, radius, lineWidth) {
            var colour = "rgba(255, 255, 255, 1)";
            var start = Math.PI * 0.15;
            var end = Math.PI * 1.75;
            context.fillStyle = colour;
            context.strokeStyle = colour;
            context.lineWidth = lineWidth;
            context.beginPath();
            context.arc(
              centerPoint.x,
              centerPoint.y,
              radius,
              start,
              end,
              false
            );
            context.stroke();
            context.beginPath();
            context.lineWidth = 1;
            this.drawPolygon(
              context,
              this.getPointsForArrowHead(centerPoint, radius, lineWidth, end)
            );
            context.closePath();
            context.stroke();
            context.fill();
          },
          getPointsForArrowHead: function(centerPoint, radius, lineWidth, end) {
            var cosEnd = Math.cos(end);
            var sinEnd = Math.sin(end);
            var radiusAndStroke = radius + lineWidth;
            var doubleLineWidth = lineWidth * 2;
            var points = [];
            var point = {
              x: centerPoint.x + cosEnd * radius,
              y: centerPoint.y + sinEnd * radius
            };
            points.push(point);
            point = {
              x: centerPoint.x + cosEnd * radiusAndStroke,
              y: centerPoint.y + sinEnd * radiusAndStroke
            };
            points.push(point);
            point = {
              x: points[0].x + Math.cos(end + Math.PI * 0.5) * doubleLineWidth,
              y: points[0].y + Math.sin(end + Math.PI * 0.5) * doubleLineWidth
            };
            points.push(point);
            point = {
              x: centerPoint.x + cosEnd * (radius - lineWidth),
              y: centerPoint.y + sinEnd * (radius - lineWidth)
            };
            points.push(point);
            return points;
          },
          drawPolygon: function(context, points) {
            var firstPosition = _.first(points);
            context.moveTo(firstPosition.x, firstPosition.y);
            _.each(points, function(position) {
              context.lineTo(position.x, position.y);
            });
          },
          drawCross: function(
            context,
            x,
            y,
            width,
            height,
            lineWidth,
            strokeStyle
          ) {
            context.lineWidth = lineWidth;
            context.strokeStyle = strokeStyle;
            context.beginPath();
            context.moveTo(x - width * 0.5, y - height * 0.5);
            context.lineTo(x + width * 0.5, y + height * 0.5);
            context.moveTo(x - width * 0.5, y + height * 0.5);
            context.lineTo(x + width * 0.5, y - height * 0.5);
            context.closePath();
            context.stroke();
          },
          drawEmbossedCircle: function(
            context,
            x,
            y,
            innerRadius,
            outerRadius
          ) {
            context.lineWidth = 0;
            context.strokeStyle = null;
            var point0 = { x: x - innerRadius, y: y + innerRadius };
            var point1 = { x: x + innerRadius, y: y - innerRadius };
            var metalGradient = context.createLinearGradient(
              point0.x,
              point0.y,
              point1.x,
              point1.y
            );
            metalGradient.addColorStop(0, "rgba(0, 0, 0, 0.6)");
            metalGradient.addColorStop(0.5, "rgba(0, 0, 0, 0)");
            metalGradient.addColorStop(1, "rgba(0, 0, 0, 0.6)");
            context.fillStyle = "#2b2b2b";
            context.beginPath();
            context.arc(x, y, outerRadius, 0, Math.PI * 2);
            context.fill();
            context.closePath();
            context.fillStyle = "#ffffff";
            context.beginPath();
            context.arc(x, y, innerRadius, 0, Math.PI * 2);
            context.fill();
            context.closePath();
            context.fillStyle = metalGradient;
            context.beginPath();
            context.arc(x, y, innerRadius, 0, Math.PI * 2);
            context.fill();
            context.closePath();
          },
          start: function(context, options) {
            _.each(options, function(option, key) {
              if (key in context) {
                if (typeof context[key] === "function") {
                  if (option) {
                    context[key]();
                  }
                } else {
                  context[key] = option;
                }
              }
            });
          },
          end: function(context, options) {
            if (options.closePath) {
              context.closePath();
            }
            if (options.stroke) {
              context.stroke();
            }
            if (options.fill) {
              context.fill();
            }
          }
        };
      },
      { lodash: 1 }
    ],
    68: [
      function(require, module, exports) {
        module.exports = {
          init: function() {
            this.isTouchScreen =
              "ontouchstart" in window ||
              navigator.MaxTouchPoints > 0 ||
              navigator.msMaxTouchPoints > 0;
            this.isLocalStorageAvailable = this.storageAvailable(
              "localStorage"
            );
          },
          storageAvailable: function(type) {
            try {
              var storage = window[type],
                x = "__storage_test__";
              storage.setItem(x, x);
              storage.removeItem(x);
              return true;
            } catch (e) {
              return false;
            }
          },
          isTouchScreen: this.isTouchScreen,
          isLocalStorageAvailable: this.isLocalStorageAvailable
        };
      },
      {}
    ],
    69: [
      function(require, module, exports) {
        module.exports = {
          canvas: require("./canvas"),
          features: require("./features"),
          levelsLoader: require("./levels-loader"),
          distAtoB: function(pointA, pointB) {
            var A = pointB.x - pointA.x;
            var B = pointB.y - pointA.y;
            return Math.sqrt(A * A + B * B);
          }
        };
      },
      { "./canvas": 67, "./features": 68, "./levels-loader": 70 }
    ],
    70: [
      function(require, module, exports) {
        var levelManager = require("../data/level-manager");
        var properties = require("../properties");
        var _ = require("lodash");
        module.exports = {
          levelsData: {},
          levelProgressTxt: null,
          init: function() {
            game.load.onFileComplete.add(this.fileComplete, this);
            game.load.onLoadComplete.add(this.loadComplete, this);
          },
          loadLevelsJson: function(levelsJsonUrl) {
            console.log("levels-loader :: loadLevelsJson", levelsJsonUrl);
            game.load.json("levels-data", levelsJsonUrl);
          },
          startLoad: function() {
            console.log("levels-loader :: startLoad", this.levelsData);
            this.loadAtlas(this.levelsData.atlas);
          },
          loadAtlas: function(atlas) {
            console.log(
              "levels-loader :: loadAtlas :: this.levelsData.atlas",
              atlas
            );
            game.load.atlas(atlas.key, atlas.imgUrl, atlas.dataUrl);
          },
          loadLevelsPack: function() {
            console.log(
              "levels-loader :: loadLevelsPack :",
              levelManager.levels
            );
            _.each(levelManager.levels, _.bind(this.loadLevel, this));
          },
          loadLevel: function(levelData) {
            this.loadLevelImg(levelData);
            this.loadLevelPhysics(levelData);
          },
          loadLevelImg: function(levelData) {
            console.log("levels-loader :: loadLevelImg", levelData);
            if (!levelData.useAtlas) {
              game.load.image(levelData.mapImgKey, levelData.mapImgUrl);
            }
          },
          loadLevelPhysics: function(levelData) {
            game.load.physics(
              levelData.mapDataKey + properties.mapSuffix,
              levelData.mapDataUrl
            );
            if (levelData.gateImgKey) {
              game.load.image(levelData.gateImgKey, levelData.gateImgUrl);
              game.load.physics(
                levelData.gateDataKey + properties.mapSuffix,
                levelData.gateDataUrl
              );
            }
          },
          isLevelData: function(cacheKey) {
            return (
              cacheKey.indexOf(properties.mapSuffix) >= 0 &&
              game.cache.getItem(cacheKey, Phaser.Cache.PHYSICS)
            );
          },
          isLevelsJson: function(cacheKey) {
            return cacheKey === "levels-data";
          },
          isLevelsAtlas: function(cacheKey) {
            return cacheKey === "combined";
          },
          getLevelByCacheKey: function(cacheKey) {
            var myLevel = _.find(
              levelManager.levels,
              function(levelData) {
                return levelData.mapDataKey + properties.mapSuffix === cacheKey;
              },
              this
            );
            if (!myLevel) {
              myLevel = _.find(levelManager.levels, function(levelData) {
                return (
                  levelData.gateDataKey + properties.mapSuffix === cacheKey
                );
              });
            }
            return myLevel;
          },
          fileComplete: function(progress, cacheKey) {
            console.log("levels-loader :: fileComplete cacheKey=", cacheKey);
            if (this.levelProgressTxt) {
              var percent = game.load.progress;
              this.loadProgressTxt.text = percent + "%";
            }
            if (this.isLevelsJson(cacheKey)) {
              console.log(
                "levels-loader :: isLevelsJson : cacheKey=",
                cacheKey
              );
              this.levelsData = game.cache.getJSON("levels-data");
              console.log(
                "levels-loader :: this.levelsData =",
                this.levelsData
              );
              levelManager.init(this.levelsData);
              this.startLoad();
            }
            if (this.isLevelsAtlas(cacheKey)) {
              this.loadLevelsPack();
            }
            if (this.isLevelData(cacheKey)) {
              console.log("levels-loader :: this.isLevelData loadPhysics");
              var levelPhysics = game.cache.getItem(
                cacheKey,
                Phaser.Cache.PHYSICS
              );
              var level = this.getLevelByCacheKey(cacheKey);
              if (!level) {
                level = properties.levels.training;
              }
              if (level.hasOwnProperty("mapScale")) {
                if (cacheKey.indexOf("gate") >= 0) {
                  this.scaleMapData(
                    levelPhysics.data,
                    level,
                    level.gateDataKey
                  );
                } else {
                  this.scaleMapData(levelPhysics.data, level, level.mapDataKey);
                }
              }
            }
          },
          loadComplete: function() {
            this.levelsLoadComplete();
          },
          scaleMapData: function(physicsData, level, key) {
            console.log("scaleMapData::", level);
            _.each(physicsData[key], function(node) {
              _.each(node.shape, function(value, n) {
                node.shape[n] = value * level.mapScale;
              });
            });
          },
          levelsLoadComplete: function() {
            console.log("levelsJson loadComplete :: levelsData");
            this.cleanUp();
          },
          finalLoadComplete: function() {
            console.log("finalLoadComplete");
          },
          cleanUp: function() {
            console.log("levels-loader :: cleanup");
            game.load.onFileComplete.remove(this.fileComplete, this);
            game.load.onLoadComplete.remove(this.finalLoadComplete, this);
          }
        };
      },
      { "../data/level-manager": 19, "../properties": 31, lodash: 1 }
    ],
    71: [
      function(require, module, exports) {
        var optionsModel = require("../data/options-model");
        module.exports = {
          GATE_OPEN: "gate-open",
          GATE_CLOSE: "gate-close",
          FUEL_EXPLODE: "fuel-explode",
          FUEL_REFUELLING: "fuel-refuelling",
          FUEL_REFUEL_COMPLETE: "fuel-refuel-complete",
          LIMPET_FIRE: "limpet-fire",
          LIMPET_EXPLODE: "limpet-explode",
          PLAYER_1UP: "player-1up2",
          PLAYER_THRUST_START: "player-thrust-start",
          PLAYER_THRUST_MID: "player-thrust-mid",
          PLAYER_THRUST_END: "player-thrust-end",
          PLAYER_FIRE: "player-fire",
          PLAYER_DEATH: "player-death",
          PLAYER_EXPLOSION: "player-explosion",
          PLAYER_TELEPORT_IN: "player-teleport-in",
          PLAYER_TELEPORT_OUT: "player-teleport-out",
          POWER_STATION_EXPLODE1: "power-station-explode1",
          POWER_STATION_EXPLODE2: "power-station-explode2",
          POWER_STATION_HIT: "power-station-hit",
          TRACTOR_BEAM_CONNECTING: "tractor-beam-connecting",
          TRACTOR_BEAM_RELEASE: "tractor-beam-release",
          TRACTOR_BEAM_GRAB: "tractor-beam-grab",
          TRACTOR_BEAM_BREAK: "tractor-beam-break",
          UI_COUNTDOWN_START: "ui-countdown-start",
          UI_COUNTDOWN_SECOND: "ui-countdown-second",
          UI_MENU_SELECT: "ui-menu-select",
          UI_SWIPE_IN: "ui-swipe-in",
          UI_SWIPE_OUT: "ui-swipe-out",
          UI_INTERSTITIAL_MISSION_COMPLETE: "ui-interstitial-mission-complete",
          UI_INTERSTITIAL_MISSION_FAILED: "ui-interstitial-mission-failed",
          UI_SCORE_ROLLUP: "ui-score-rollup",
          UI_PRESS_FIRE: "ui-press-fire",
          UI_GAME_OVER: "ui-game-over",
          TRAINING_DRONE_PASSED: "training-drone-connect",
          TRAINING_DRONE_HOVER1: "training-drone-hover1",
          TRAINING_DRONE_HOVER2: "training-drone-hover2",
          TRAINING_DRONE_HOVER3: "training-drone-hover3",
          TRAINING_DRONE_HOVER4: "training-drone-hover4",
          music: null,
          currentMusic: "",
          playSound: function(name, volume, loop) {
            if (optionsModel.sound.soundFx) {
              game.sfx.play(name, volume);
              var sound = game.sfx.get(name);
              if (loop) {
                sound.loop = loop;
              }
            }
          },
          shouldPlaySfx: function() {
            return optionsModel.sound.soundFx;
          },
          playMusic: function(name, volume, loop) {
            if (this.currentMusic !== name) {
              this.currentMusic = name;
              this.stopMusic();
              if (optionsModel.sound.music) {
                game.music.play(name, volume);
                this.music = game.music.get(name);
                if (loop) {
                  this.music.loop = loop;
                }
              }
            }
          },
          stopMusic: function() {
            if (this.music) {
              this.music.stop();
              this.music = null;
            }
          }
        };
      },
      { "../data/options-model": 20 }
    ]
  },
  {},
  [30]
);
//# sourceMappingURL=public/javascripts/browserify/thrust-engine.min.js.map
